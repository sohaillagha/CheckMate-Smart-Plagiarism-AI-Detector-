On Circuit Description Languages, Indexed Monads, and Resource Analysis KEN SAKAYORI, The University of Tokyo, Japan ANDREA COLLEDAN, University of Bologna, Italy and Centre Inria dâ€™UniversitÃ© CÃ´te dâ€™Azur, France UGO DAL LAGO, University of Bologna, Italy and Centre Inria dâ€™UniversitÃ© CÃ´te dâ€™Azur, France In this paper, a monad-based denotational model is introduced and shown adequate for the Proto-Quipper family of calculi, themselves being idealized versions of the Quipper programming language. The use of a monadic approach allows us to separate the value to which a term reduces from the circuit that the term itself produces as a side effect. In turn, this enables the denotational interpretation and validation of rich type systems in which the size of the produced circuit can be controlled. Notably, the proposed semantic framework, through the novel concept of circuit algebra, suggests forms of effect typing guaranteeing quantitative properties about the resulting circuit, even in presence of optimizations. CCS Concepts: â€¢ Theory of computation â†’Denotational semantics; Program analysis; â€¢ Software and its engineering â†’Domain specific languages; â€¢ Hardware â†’Quantum computation. 1 Introduction Quantum computing promises to revolutionize various sub-fields within computer science by solv- ing complex problems exponentially faster than classical computing [Shor 1994]. This technology leverages the concept of quantum bits (or qubits), a unit of information whose dynamics is governed by the rules of quantum mechanics, thus enabling superposition and entanglement, keys to the aforementioned speedup. To harness this potential, several programming languages have been developed specifically for quantum computing, such as Q# [Svore et al. 2018], Qiskit [Javadi-Abhari et al. 2024], and Cirq [2025]. In turn, fields like program verification have adapted well-known techniques like abstract interpretation [Perdrix 2008; Yu and Palsberg 2021], type systems [Amy 2019; Colledan and Dal Lago 2025], and Hoare logic [Liu et al. 2019; Ying et al. 2017; Zhou et al. 2019] to these languages. We can identify at least two ways to design a quantum programming language. On the one hand, we could simply allow programs written in traditional programming languages to access not only classical data but also quantum data. The latter cannot be used the same way as the former, and is rather supported by specific initialization, modification, and reading operations. As an example, the reading of a qubit value, often called a measurement, can alter its value and has, in general, a probabilistic outcome, thus being substantially different from the corresponding classical operation. In programming languages of this kind, the quantum data are assumed to be stored in an external device accessible interactively through the aforementioned operations. This model, often indicated with the acronym QRAM [Knill 2022], is adopted by a multitude of proposals in the literature (see e.g. [Bettelli et al. 2003; Sanders and Zuliani 2000; Selinger 2004; Selinger and Valiron 2005]). In theory, QRAM languages are the natural adaptation of classical programming languages to the quantum world. In practice, however, quantum hardware architectures can hardly be programmed interactively: not only is the number of qubits available very small, but the time within which computation must be completed should itself be minimized, given that the useful lifespan of a qubit is short. Consequently, quantum architectures typically take as input a whole quantum circuit, i.e. a precise description of all the necessary qubits and the operations to be performed on them. This circuit must therefore be available in its entirety, preferably already subjected to an Authorsâ€™ Contact Information: Ken Sakayori, The University of Tokyo, Japan; Andrea Colledan, University of Bologna, Italy and Centre Inria dâ€™UniversitÃ© CÃ´te dâ€™Azur, France; Ugo Dal Lago, University of Bologna, Italy and Centre Inria dâ€™UniversitÃ© CÃ´te dâ€™Azur, France. arXiv:2511.22419v1 [cs.PL] 27 Nov 2025 2 Ken Sakayori, Andrea Colledan, and Ugo Dal Lago aggressive optimization process. In such a context, so-called circuit description languages (CDLs for short) are to be preferred, and most mainstream languages in the field, including Qiskit and Cirq, are of this nature. CDLs are high-level languages used to describe and generate circuits, a quintessential example being the quantum circuit. Circuits are typically seen like any other ordinary data structure, with specific operations on them available through, e.g., methods or subroutines. Directly manipulating circuits from within a classical program offers the advantage of having more direct control over their shape and size. This is crucial given the state of quantum hardware architectures today, which provide a limited number of error-prone qubits, and for which not all operations can be implemented at the same cost. A peculiar circuit description language is Quipper [Green et al. 2013]. In Quipper, circuits are not just like any other data structure. Rather, they are seen as the by-product of certain effect-producing computations that modify some underlying quantum circuit when executed. This, combined with the presence of higher-order functions and operations meant to turn any term (of an appropriate type) into a circuit, makes Quipper a very powerful and flexible idiom. Its metatheory has been the subject of quite some investigations by the programming language community in the last years, with contributions ranging from advanced type systems [Fu et al. 2020, 2022a] to fancy features like dynamic lifting [Colledan and Dal Lago 2023; Fu et al. 2022b, 2023] to denotational semantics [Fu et al. 2022b, 2023, 2022a; Lindenhovius et al. 2018; Rios and Selinger 2017]. This last aspect of Quipper, in particular, has been studied by providing semantic models for some of the languages of the so-called Proto-Quipper family, which includes various calculi, such as Proto- Quipper-M [Rios and Selinger 2017], Proto-Quipper-D [Fu et al. 2022a], Proto-Quipper-Dyn [Fu et al. 2023], etc. In these cases, such semantics are built around concepts such as that of a presheaf and turn out to take the shape of a LNL model [Benton 1994]. A by-product of the use of presheaves is that the interpretation of the term and the underlying circuit are somehow merged into a single mathematical object. As a result, it is difficult to read interesting features of the underlying circuit from the interpretation of a term or closure: what the circuit does and what the program does to produce the circuit are inextricably coupled. This coupling, in turn, prevents those models from adequately accounting for variants of the Proto-Quipper family that are specifically designed to control the shape of the produced circuits, and more specifically to derive upper bounds on the size of the latter [Colledan and Dal Lago 2024, 2025]. The correctness of these systems has been proved by purely operational means, and a denotational semantics for them is still missing. This ultimately makes such systems somewhat rigid and complicates their definition. The aim of this paper is precisely to give a denotational semantics to languages in the Proto- Quipper family in which the interpretation of terms is kept separate from that of the produced circuit. This is achieved by seeing circuit building as an indexed monad [Atkey 2009].1 Remarkably, this new point of view allows us to give semantics to languages such as Colledan and Dal Lagoâ€™s Proto-Quipper-R, and even allows us to justify some of their peculiarities. The introduced semantic framework suggests a natural way to unify so-called local and global circuit metrics, at the same time allowing the definition of metrics that go substantially beyond those proposed by Colledan and Dal Lago, in particular accounting for simple forms of circuit optimization. The contributions of this paper can be thus summarized as follows: â€¢ First, we give a simple type system for Proto-Quipper. The introduced system is a slight variation on the theme of Proto-Quipper-M [Rios and Selinger 2017], whereas the input to the circuit produced by each effectful functional term needs to be exposed in its type 1Indexed monads are also known as and were originally called parameterized monads. We avoid this name since other â€œparametersâ€, such as parameters of circuits or grades of a monad, appear in this work. On Circuit Description Languages, Indexed Monads, and Resource Analysis 3 and thus becomes an integral part of the arrow type, turning it into a closure type. This change, as we will explain in the next section, seems inevitable since, without it, it would not be possible to know even the nature, i.e. the type, of the circuit produced by the term in question. Noticeably, closure types are present in Colledan and Dal Lagoâ€™s [2025] most recent contribution. We call this calculus with closure type Proto-Quipper-C. â€¢ We then show that Atkeyâ€™s indexed monad is an appropriate framework for giving denota- tional semantics to Proto-Quipper-C. By treating circuits as (pre)monoidal morphisms and considering the category-action indexed monadâ€”a many-sorted generalization of the writer monadâ€”we maintain a clear separation between the value a term evaluates to and the circuit produced alongside the evaluation. Proto-Quipper-C is interpreted in the parameterized Freyd category induced by this indexed monad, making explicit how â€œparametersâ€, compu- tations, and circuits interact as these three notions are interpreted in different categories. The semantics is proved both sound and computationally adequate. â€¢ We then move to richer type systems, where simple types are enriched by a form of effect typing. The model based on indexed monads remains adequate, and suggests an abstract notion of circuit algebra, through which it is possible to capture various circuit metrics (including all those considered by Dal Lago and Colledan), but also new forms of metrics induced by assertion-based circuit optimization schemes [HÃ¤ner et al. 2020]. â€¢ We briefly discuss how dependent types might be incorporated into both the syntax and semantics of the variant of Proto-Quipper-C (without effect typing) introduced earlier. On the semantic side, this is achieved by applying the families construction to the denotational model of Proto-Quipper-C in the spirit of fibered adjunction models [Ahman et al. 2016]. The rest of this paper is structured as follows. After the next section, which serves to frame the problem without going into the technical details, we move on to Section 3, in which Proto- Quipper-C, i.e. a slight variation of the Proto-Quipper-M calculus, is introduced and endowed with an operational semantics. In Section 4, then, a monadic denotational semantics for Proto-Quipper-C is introduced and proved adequate. In Section 5, an extension of these results to a calculus with effect typing, along the lines of Proto-Quipper-R, is presented. Section 6 discusses the possibility of extending our framework to incorporate dependent types. Section 7 discusses related work, and Section 8 concludes the paper. 2 A Monadic Semantics for CDLs: Why and How? In this section, we will describe in a little more detail the problem of giving a monadic denotational semantics to CDLs, focusing on how this can be done, but also on why such an effort might be worth it. Typically, a program written in a CDL is just a program in a mainstream programming language (e.g. Python, Haskell, or dialects thereof) whose purpose is that of facilitating the construction of (quantum) circuits which, once built, can then be sent to quantum hardware for their evaluation, or merely simulated through high-performance classical hardware. As already mentioned, the CDL we are mainly concerned with is Quipper, which is embedded in Haskell. A program written in any CDL, and particularly in Quipper, does not describe a single circuit but a family of circuits, depending on some parameters, e.g. a number ğ‘›representing the number of input qubits, or, in the case of Shorâ€™s algorithm, the size of the natural number to be factored. The ability to describe families of circuits enables Quipper to succinctly and elegantly describe quantum algorithms, thus having a pragmatic impact and attracting the attention of the programming language community [Fu et al. 2023, 2022a; Lindenhovius et al. 2018; Rios and Selinger 2017], which 4 Ken Sakayori, Andrea Colledan, and Ugo Dal Lago proposed idealized languages capturing the essence of Quipper. Such formal calculi come equipped with an operational semantics, type system, and often with a denotational semantics. Most forms of denotational semantics for the Proto-Quipper family are based on presheaves, and enjoy a constructive property, which states that the interpretation of a judgment in a certain form is indeed a parameterized family of circuits. For example, in the categorical semantics of Proto- Quipper-M [Rios and Selinger 2017], the judgment ğ‘›: nat,ğ‘¥: Qubit âŠ¢ğ‘€: Qubit is interpreted as a function Jğ‘€K: N â†’M(Qubit, Qubit), where M(Qubit, Qubit) is the set of circuits whose input and output interfaces both consist of a single qubit. In the above, the type nat can be replaced by any â€œclassical data typeâ€ and Qubit can be replaced by any â€œwire typeâ€. However, some judgments cannot be interpreted as a family of circuits in the same way, including terms with free variables with a function type. As an example, a term of type ğ‘›: nat,ğ‘¥: (Qubit âŠ¸Qubit) âŠ¢ğ‘: Qubit (1) which evaluates to a qubit type value while generating a circuit, would be interpreted as Jğ‘K: N â†’ Nat(JQubit â†’QubitK, JQubitK) where ğ›¼âˆˆNat(JQubit â†’QubitK, JQubitK) is a natural transfor- mation (i.e. a morphism in the presheaf category). Each component ğ›¼ğ‘‡has a type JQubit â†’ QubitK(ğ‘‡) â†’M(ğ‘‡, Qubit) because JQubitK is defined via the Yoneda embedding ã‚‡: M â†’ [Mop, Set] and JQubitK(ğ‘‡) =ã‚‡(Qubit)(ğ‘‡) = M(ğ‘‡, Qubit). In other words, and more informally, ğ‘is interpreted as a family of polymorphic functions {ğ‘“ğ‘–}ğ‘–âˆˆN, each of them having type âˆ€(ğ‘‡: WireType). Clos(Qubit, Qubit)[ğ‘‡] â†’M(ğ‘‡, Qubit) The type Clos(Qubit, Qubit)[ğ‘‡] represents a closure type disclosing the type ğ‘‡of the data that the closure captures. Given a â€œclosureâ€ as input, ğ‘“ğ‘–returns a circuit whose input and output interfaces are ğ‘‡and Qubit, respectively. In a sense, then, not even the input type of the generated circuit can be read from Jğ‘K(ğ‘›) because we need to know the actual data that will be passed to ğ‘¥to determine the interface of the circuit. This implies that modular reasoning about the produced circuits cannot be easily performed within the model, in which it would be hard to interpret type systems specifically built for intensional analysis [Colledan and Dal Lago 2024]. This paper introduces a denotational semantics for a CDL in which every judgment is interpreted as a family of circuits whose types are uniquely defined. More specifically, any judgment Î“ âŠ¢ğ‘€: ğ´ is interpreted as a function Jğ‘€K: Jâ™­Î“K â†’Jâ™­ğ´K Ã— M(Jâ™¯Î“K, Jâ™¯ğ´K), (2) where â™¯and â™­are operations extracting the â€œcircuit partâ€ and â€œparametric partâ€ of any type, respectively. The mathematical object Jğ‘€K, in other words, is a family of pairs {(ğ‘£ğ‘–,ğ¶ğ‘–)}ğ‘–âˆˆJâ™­Î“K indexed by Jâ™­Î“K where ğ‘£ğ‘–is a â€œvalueâ€ in Jâ™­ğ´K and ğ¶ğ‘–is a circuit in M(Jâ™¯Î“K, Jâ™¯ğ´K); a family of circuits is a special case where ğ‘£ğ‘–is a unit value. The fact that every judgment is interpreted as a family of circuits is important since it allows us to compositionally reason about the family of circuits generated by a program. For example, upper bounds to the width of the circuits generated by any program can be computed by looking at the interpretation of the subprograms. The just sketched construction evidently has the form of a monad [Moggi 1991], structurally very similar to a writer monad. There is, however, one important difference: the type of circuit produced during the execution of a term is not fixed a priori. As a consequence, the classical notion of monad, being somehow monomorphic, cannot be applied directly. Instead, indexed monads [Atkey 2009] can be fruitfully employed to model the circuit generated by the underlying program. In fact, the interpretation (2) can be rewritten as Jğ‘€K: Jâ™­Î“K â†’T (Jâ™¯Î“K, Jâ™¯ğ´K, Jâ™­ğ´K), (3) On Circuit Description Languages, Indexed Monads, and Resource Analysis 5 where T (ğ‘‡,ğ‘ˆ,ğ‘‹) is an indexed monad defined as ğ‘‹Ã— M(ğ‘‡,ğ‘ˆ). Using such a monadic approach allows us to structure the interpretation of languages in the Proto-Quipper family in a new way, fundamentally different from that considered in the literature on the subject: every term is inter- preted as a mathematical object in which the value produced and the underlying circuit are kept separate. Technically, we interpret terms in a parameterized Freyd category obtained by applying an indexed version of the well-known Kleisli construction to the indexed monad above. If we look at Equation (3) in more detail, we soon realize that a monadic interpretation like the one we are discussing requires knowing Jâ™¯Î“K whenever the effectful term ğ‘€is a value ğœ†ğ‘¥.ğ‘€ (where ğ‘¥is any of the variables in Î“). In other words, the â€œcircuit portionâ€ of Î“ must become part of the (functional) type of ğœ†ğ‘¥.ğ‘€. This last observation justifies the small discrepancies between Proto-Quipper-C (the language we present in Section 3 below) and Proto-Quipper-M and provides a denotational reading to some of the type-theoretical tricks in [Colledan and Dal Lago 2024]. As an example, the typing judgment (1) becomes ğ‘›: nat,ğ‘¥: (Qubit âŠ¸ğ‘‡Qubit) âŠ¢ğ‘: Qubit, where ğ‘‡ is the type of circuit variables the argument function captures. The advantage of moving to a monadic view like the one just described is that we have now exposed the space M of circuits in the interpretation. As we will see in Section 5, in fact, this naturally suggests a way to control the size of the generated circuits through a form of effect typing: any well-behaved functor from M to a category E which captures the relevant characteristics of the underlying circuit, e.g. its size, induces a form of effect typing which is sound by construction. This is what denotational semantics is good for: not only is the programming language in question interpreted compositionally, but the interpretation naturally suggests what in the language might be subject to modification or adaptation while, at the same time, indicating what the underlying axiomatics should be, and factoring out most proofs. 3 Simple Types In this section, we introduce the syntax and operational semantics of Proto-Quipper-C, our dialect of Proto-Quipper-M [Rios and Selinger 2017]. We will point out the differences with the language Proto-Quipper-M, still trying to keep the presentation as self-contained as possible. 3.1 Type and Syntax We first introduce the simple type system of Proto-Quipper-C. The grammar for types is as follows: Types ğ´, ğµF ğ‘ƒ| ğ‘‡| ğ´âŠ—ğµ| ğ´âŠ¸ğ‘‡ğµ Parameter Types ğ‘ƒ, ğ‘…F 1 | Nat | !ğ´| ğ‘ƒâŠ—ğ‘…| Circ(ğ‘‡,ğ‘ˆ) Bundle Types ğ‘‡,ğ‘ˆF ğ¼| ğ‘¤| ğ‘‡âŠ—ğ‘ˆ There are three kinds of types. In addition to generic types, which are intended for (not necessarily duplicable) terms, there are parameter types whose inhabitants are freely duplicable and which include circuits and values of type !ğ´. There are the unit and natural number type as base types, but the specific choice of base types is not that important. We also need bundle types, which are used to give a type to circuit wires. Observe that the tensor product operator âŠ—is available in the three kinds of types, while the construction of functions is not available in parameter and bundle types. Typing is almost the same as in Proto-Quipper-M as defined in [Rios and Selinger 2017]. There is a significant difference in the definition of the arrow type, however. We annotate the arrow type with a bundle type ğ‘‡, which describes the types of the free variables captured by the function, effectively turning it into a form of closure type. Note that we only care about the bundle type variables that are captured by the function and drop the information of variables with parameter types. A similar kind of annotation was used by Colledan and Dal Lago [2024], although in their 6 Ken Sakayori, Andrea Colledan, and Ugo Dal Lago work the label was rather a natural number abstracting the type ğ‘‡. We have already argued about the need for this change to the type system, and will come back to that in the next section. We might write ğ´âŠ¸ğµfor ğ´âŠ¸ğ¼ğµfor the sake of simplifying the notation. Another difference compared to Proto-Quipper-M (or Proto-Quipper-R, as defined in [Colledan and Dal Lago 2024]) is that we do not have a type for lists. We removed lists as they cannot be directly interpreted in our semantic model. However, as we shall see in Section 6, we can extend our language with a vector type (i.e. a list with specified length). The syntax of Proto-Quipper-C terms is defined as follows. We use a fine-grained call-by-value style syntax [Levy et al. 2003] as done by Colledan and Dal Lago [2024].2 Terms ğ‘€, ğ‘F ğ‘‰ğ‘Š| let âŸ¨ğ‘¥,ğ‘¦âŸ©= ğ‘‰in ğ‘€| ifz ğ‘‰then ğ‘€else ğ‘ | forceğ‘‰| boxğ‘‡ğ‘‰| apply(ğ‘‰,ğ‘Š) | return ğ‘‰| let ğ‘¥= ğ‘€in ğ‘ Values ğ‘‰,ğ‘ŠF âˆ—| ğ‘›| ğ‘¥| â„“| ğœ†ğ‘¥ğ´.ğ‘€| lift ğ‘€| ( Â¯â„“,ğ¶, Â¯ğ‘˜) | âŸ¨ğ‘‰,ğ‘ŠâŸ© Wire Bundles Â¯â„“, Â¯ğ‘˜F âˆ—| â„“| âŸ¨Â¯â„“, Â¯ğ‘˜âŸ©. The informal behavior for terms is in line with that of Proto-Quipper-M, which adds to the usual constructs of a call-by-value linear lambda-calculus (abstractions, applications, let bindings, pairs, etc.) specific operators for circuit manipulation: â€¢ â„“is a label, that is, a pointer to a wire in the underlying circuit. â€¢ ( Â¯â„“,ğ¶, Â¯ğ‘˜) is a boxed circuit and represents the circuit ğ¶as a value in the language. Wire bundles Â¯â„“and Â¯ğ‘˜represent the input and output interfaces of ğ¶, respectively. â€¢ apply(ğ‘‰,ğ‘Š) appends a boxed circuit ğ‘‰to the wires identified by ğ‘Šamong the outputs of the underlying circuit. â€¢ boxğ‘‡ğ‘‰evaluates a circuit building function ğ‘‰in isolation and returns the result as a boxed circuit. At this point, we should make it clear what we mean by a â€œcircuitâ€. We do not fix what a circuit is (except when considering concrete examples), as is often the case for Proto-Quipper calculi. Usually, when giving a semantics to Proto-Quipper, circuits are seen as morphisms in a monoidal category M and the semantics is parametric to the choice of M. In this work, we assume that the category M of circuits is a premonoidal category. Roughly, a premonoidal category is a monoidal category without the interchange law ğ¶ ğ· = ğ¶ ğ· which is too strong in a cost sensitive scenario. (For example, we may say that the two circuits above are different because the width of the circuit on the left-hand-side is 4 whereas the width of the circuit on the right-hand-side is 5.) Definition 1 (Premonoidal Category [Power and Robinson 1997]). A binoidal category is a category A equipped with, for each ğ‘âˆˆObj(A), endofunctors ğ‘â‹Šâˆ’and âˆ’â‹‰ğ‘from A to A such that 2It is easy to extend the language with effect-free constants such as arithmetic operations or or meta-operations on circuits as in [Rios and Selinger 2017], but we we omit these, since they are immaterial to our main semantic results. On Circuit Description Languages, Indexed Monads, and Resource Analysis 7 ğ‘â‹‰ğ‘= ğ‘â‹Šğ‘ def= ğ‘âŠ—ğ‘for every pair of objects (ğ‘,ğ‘) of A. A morphism ğ‘“: ğ‘â†’ğ‘in A is central if it interchanges with any morphism ğ‘”: ğ‘â€² â†’ğ‘â€²: (ğ‘“â‹‰ğ‘â€²); (ğ‘â‹Šğ‘”) = (ğ‘â‹Šğ‘”); (ğ‘“â‹‰ğ‘â€²) and (ğ‘â€² â‹Šğ‘“); (ğ‘”â‹‰ğ‘) = (ğ‘”â‹‰ğ‘); (ğ‘â€² â‹Šğ‘“).3 In case two composites agree, we write ğ‘“âŠ—ğ‘”and ğ‘”âŠ—ğ‘“, respectively. A premonoidal category is a binoidal category equipped with an object ğ¼, the â€œmonoidal unitâ€, central natural (separately at each given component) isomorphisms for associativity and right and left units satisfying the standard pentagon and triangle equations. A premonoidal category is strict if all the coherence morphisms are identities, and is symmetric if it has a central isomorphism ğ‘âŠ—ğ‘ ğ‘âŠ—ğ‘that is natural (at each component) and satisfies the usual axioms of a symmetry. â— Typically, the category of circuits M is defined by giving a syntactic description of circuits. In other words, it is the free category generated by some collection of base types and gates. While we do not fix the category M, we assume that M has some distinguished objects Q and B that are used to interpret qubits and classical bits, respectively. We also assume that M is small and a strict symmetric premonoidal category.4 A typing judgment for terms is of the form Î“ âŠ¢ğ‘ğ‘€: ğ´, and intuitively means that ğ‘€is well-typed under the typing context Î“; similarly, we have a typing judgment for values of the form Î“ âŠ¢ğ‘£ğ‘‰: ğ´. A typing context Î“ is a finite sequence of bindings each of which is either of the form ğ‘¥: ğ´or â„“: ğ‘¤. The reason for using finite sequences rather than finite sets is to simplify the definition of the semantics; if two contexts Î“1 and Î“2 are equal up to permutation, then we write Î“1 ğœÎ“2. We use metavariables ğ‘,ğ‘, . . . to denote variables or labels. A typing context is a label context if it is of the form â„“1 : ğ‘¤1, . . . , â„“ğ‘›: ğ‘¤ğ‘›. Label contexts are denoted by ğ‘„, ğ¿. A parameter context, written Î¦, is a typing context that only contains variables with parameter types. Typing rules are in Figure 1, and most of them are self-explanatory. In the typing rules, when we write Î¦, Î“, we stipulate that Î“ does not contain any variable with a parameter type. Rules circ, box and apply are specific to a CDL, and thus warrant discussion. A boxed circuit ( Â¯â„“,ğ¶, Â¯ğ‘˜) is well-typed if the labels Â¯â„“and Â¯ğ‘˜acting as language-level interfaces to ğ¶have types that match with the (co)domain of ğ¶. The notation ğ¶: ğ‘„â†’ğ¿means that ğ¶is a morphism from Jğ‘„K to Jğ¿K in M; Jğ‘„K is the obvious interpretation, which we formally define in Section 4. The box rule says that if ğ‘‰ is a circuit building function that, once applied to an input of type ğ‘‡, builds a circuit of output type ğ‘ˆ, then ğ‘‰can be turned into a circuit whose interface has types ğ‘‡and ğ‘ˆ. Note that the box rule requires the typing context to be Î¦ so as to ensure that the function is not capturing any variable with a bundle type. The rule apply, on the other hand, can be read as a special version of the typing rule for function application. Once again, the main novelty with respect to Proto-Quipper-M has to do with the arrow type. The operation â™¯used in the abs rule extracts a bundle type from any type ğ´.5 Formally, the operation â™¯is inductively defined as follows: â™¯(ğ‘ƒ) def= ğ¼ â™¯(ğ¼) def= ğ¼ â™¯(ğ‘¤) def= ğ‘¤ â™¯(ğ´âŠ¸ğ‘‡ğµ) def= ğ‘‡ â™¯(ğ‘ƒâŠ—ğ‘…) def= â™¯(ğ‘ƒ) âŠ—â™¯(ğ‘…) â™¯(ğ‘‡âŠ—ğ‘ˆ) def= â™¯(ğ‘‡) âŠ—â™¯(ğ‘ˆ). We let the operator â™¯act on typing contexts by â™¯(ğ‘1 : ğ´1, . . . ğ‘ğ‘›: ğ´ğ‘›) def= â™¯(ğ´1) âŠ—Â· Â· Â· âŠ—â™¯(ğ´ğ‘›). It should now be clear that the rule abs does nothing more than inserting the bundle type of the variables free in the abstraction we are typing into its arrow type. 3We use diagrammatic order for compositions in this paper. 4Every premonoidal category is equivalent to a strict one since the coherence theorem holds [Power and Robinson 1997]. 5A similarly looking operation was called wire count in [Colledan and Dal Lago 2024]. We do not use this name since we extract the whole type and not just a natural number counting â€œhow many wires are usedâ€. 8 Ken Sakayori, Andrea Colledan, and Ugo Dal Lago unit Î¦ âŠ¢ğ‘£âˆ—: 1 nat Î¦ âŠ¢ğ‘£ğ‘›: Nat lab Î¦, â„“: ğ‘¤âŠ¢ğ‘£â„“: ğ‘¤ var Î¦,ğ‘¥: ğ´âŠ¢ğ‘£ğ‘¥: ğ´ abs Î“,ğ‘¥: ğ´âŠ¢ğ‘ğ‘€: ğµ Î“ âŠ¢ğ‘£ğœ†ğ‘¥ğ´.ğ‘€: ğ´âŠ¸#(Î“) ğµ app Î¦, Î“1 âŠ¢ğ‘£ğ‘‰: ğ´âŠ¸ğ‘‡ğµ Î¦, Î“2 âŠ¢ğ‘£ğ‘Š: ğ´ Î¦, Î“1, Î“2 âŠ¢ğ‘ğ‘‰ğ‘Š: ğµ lift Î¦ âŠ¢ğ‘ğ‘€: ğ´ Î¦ âŠ¢ğ‘£lift ğ‘€: !ğ´ force Î¦ âŠ¢ğ‘£ğ‘‰: !ğ´ Î¦ âŠ¢ğ‘forceğ‘‰: ğ´ circ ğ¶: ğ‘„â†’ğ¿ ğ‘„ğœğ‘„â€² ğ¿ğœğ¿â€² ğ‘„â€² âŠ¢ğ‘£Â¯â„“: ğ‘‡ ğ¿â€² âŠ¢ğ‘£Â¯ğ‘˜: ğ‘ˆ Î¦ âŠ¢ğ‘£( Â¯â„“,ğ¶, Â¯ğ‘˜) : Circ(ğ‘‡,ğ‘ˆ) box Î¦ âŠ¢ğ‘£ğ‘‰: ğ‘‡âŠ¸ğ¼ğ‘ˆ Î¦ âŠ¢ğ‘boxğ‘‡ğ‘‰: Circ(ğ‘‡,ğ‘ˆ) apply Î¦, Î“1 âŠ¢ğ‘£ğ‘‰: Circ(ğ‘‡,ğ‘ˆ) Î¦, Î“2 âŠ¢ğ‘£ğ‘Š: ğ‘‡ Î¦, Î“1, Î“2 âŠ¢ğ‘apply(ğ‘‰,ğ‘Š) : ğ‘ˆ dest Î¦, Î“1 âŠ¢ğ‘£ğ‘‰: ğ´âŠ—ğµ Î¦, Î“2,ğ‘¥: ğ´,ğ‘¦: ğµâŠ¢ğ‘ğ‘€: ğ¶ Î¦, Î“2, Î“1 âŠ¢ğ‘let âŸ¨ğ‘¥,ğ‘¦âŸ©= ğ‘‰in ğ‘€: ğ¶ ifz Î¦ âŠ¢ğ‘£ğ‘‰: Nat Î¦, Î“ âŠ¢ğ‘ğ‘€: ğ´ Î¦, Î“ âŠ¢ğ‘ğ‘: ğ´ Î¦, Î“ âŠ¢ğ‘ifz ğ‘‰then ğ‘€else ğ‘: ğ´ pair Î¦, Î“1 âŠ¢ğ‘£ğ‘‰: ğ´ Î¦, Î“2 âŠ¢ğ‘£ğ‘Š: ğµ Î¦, Î“1, Î“2 âŠ¢ğ‘£âŸ¨ğ‘‰,ğ‘ŠâŸ©: ğ´âŠ—ğµ return Î“ âŠ¢ğ‘£ğ‘‰: ğ´ Î“ âŠ¢ğ‘return ğ‘‰: ğ´ let Î¦, Î“1 âŠ¢ğ‘ğ‘€: ğ´ Î¦, Î“2,ğ‘¥: ğ´âŠ¢ğ‘ğ‘: ğµ Î¦, Î“2, Î“1 âŠ¢ğ‘let ğ‘¥= ğ‘€in ğ‘: ğµ ex Î“1,ğ‘: ğ´,ğ‘: ğµ, Î“2 âŠ¢ğ‘ğ‘€: ğ¶ Î“1,ğ‘: ğµ,ğ‘: ğ´, Î“2 âŠ¢ğ‘ğ‘€: ğ¶ Fig. 1. Typing Rules for Proto-Quipper-C. The box rule is slightly different from the one commonly seen in the Proto-Quipper family, in which box is a coercion from !(ğ‘‡âŠ¸ğ‘ˆ) to Circ(ğ‘‡,ğ‘ˆ). In our rule, instead, we drop the ! operator. Intuitively, ! is needed to ensure that the function with type ğ‘‡âŠ¸ğ‘ˆdoes not capture any variable with bundle type. But this information is already explicit in our type system by the subscript ğ¼, and there is no reason to additionally require the of-course modality. We will later also give a semantic explanation against this design choice (see Proposition 1 and the remark after it). 3.2 Operational Semantics The operational semantics is defined as a big-step evaluation relation on configurations. A config- uration is a pair (ğ¶, ğ‘€), where ğ¶is a circuit being generated and ğ‘€is the term being evaluated. The definition of the big-step evaluation relation â‡“is in Figure 2. (The rule for evaluating the else branch of ifz is omitted.) The box rule relies on the freshlabels function, which is used to produce a fresh label context ğ‘„ and a wire bundle Â¯â„“such that ğ‘„âŠ¢ğ‘£Â¯â„“: ğ‘‡. On the other hand, the apply rule relies on the append function, which attaches the circuit ğ·to the wires identified by Â¯ğ‘¡among the outputs of ğ¶. This operation often requires a renaming of the labels in ğ·, so that its input interface Â¯â„“matches Â¯ğ‘¡. More formally, we say that two boxed circuits ( Â¯â„“, ğ·, Â¯ğ‘˜) and ( Â¯â„“â€², ğ·â€², Â¯ğ‘˜â€²) are equivalent, and we write ( Â¯â„“, ğ·, Â¯ğ‘˜)  ( Â¯â„“â€², ğ·â€², Â¯ğ‘˜â€²), if they only differ by a renaming of labels. What append does, then, is find On Circuit Description Languages, Indexed Monads, and Resource Analysis 9 app (ğ¶, ğ‘€[ğ‘‰/ğ‘¥]) â‡“(ğ·,ğ‘Š) (ğ¶, (ğœ†ğ‘¥ğ´.ğ‘€) ğ‘‰) â‡“(ğ·,ğ‘Š) dest (ğ¶, ğ‘€[ğ‘‰/ğ‘¥][ğ‘Š/ğ‘¦]) â‡“(ğ·,ğ‘‹) (ğ¶, let âŸ¨ğ‘¥,ğ‘¦âŸ©= âŸ¨ğ‘‰,ğ‘ŠâŸ©in ğ‘€) â‡“(ğ·,ğ‘‹) if-zero (ğ¶, ğ‘€) â‡“(ğ·,ğ‘‰) (ğ¶, ifz 0 then ğ‘€else ğ‘) â‡“(ğ·,ğ‘‰) force (ğ¶, ğ‘€) â‡“(ğ·,ğ‘‰) (ğ¶, force(lift ğ‘€)) â‡“(ğ·,ğ‘‰) apply (ğ¸, Â¯ğ‘) = append(ğ¶, Â¯ğ‘¡, ( Â¯â„“, ğ·, Â¯ğ‘˜)) (ğ¶, apply(( Â¯â„“, ğ·, Â¯ğ‘˜), Â¯ğ‘¡)) â‡“(ğ¸, Â¯ğ‘) box (ğ‘„, Â¯â„“) = freshlabels(ğ‘‡) (ğ‘–ğ‘‘ğ‘„,ğ‘‰Â¯â„“) â‡“(ğ·, Â¯ğ‘˜) (ğ¶, boxğ‘‡ğ‘‰) â‡“(ğ¶, ( Â¯â„“, ğ·, Â¯ğ‘˜)) return (ğ¶, return ğ‘‰) â‡“(ğ¶,ğ‘‰) let (ğ¶, ğ‘€) â‡“(ğ¸,ğ‘‰) (ğ¸, ğ‘[ğ‘‰/ğ‘¥]) â‡“(ğ·,ğ‘Š) (ğ¶, let ğ‘¥= ğ‘€in ğ‘) â‡“(ğ·,ğ‘Š) Fig. 2. Proto-Quipper-C big-step operational semantics. (Â¯ğ‘¡, ğ·â€², Â¯ğ‘)  ( Â¯â„“, ğ·, Â¯ğ‘˜) and return Â¯ğ‘, along with a circuit ğ¸defined as follows: ğ¶ Â¯ğ‘¡ ğ·â€² Â¯ğ‘ Overall, this semantics is the same as the one given in [Colledan and Dal Lago 2024], except for the box rule, which is modified to align with the modifications made in the typing rules. 3.3 Type Preservation We write ğ‘„âŠ¢(ğ¶, ğ‘€) : ğ´;ğ‘„â€² and say that the configuration (ğ¶, ğ‘€) is well-typed under ğ‘„and ğ‘„â€² if ğ¶: ğ‘„â†’ğ¿,ğ‘„â€² and ğ¿âŠ¢ğ‘ğ‘€: ğ´for some label context ğ¿disjoint from ğ‘„â€². Similarly, we write ğ‘„âŠ¢(ğ¶,ğ‘‰) : ğ´;ğ‘„â€² if ğ‘„âŠ¢(ğ¶, return ğ‘‰) : ğ´;ğ‘„â€². We have the following type preservation theorem. Theorem 2 (Type Preservation). If ğ‘„âŠ¢(ğ¶, ğ‘€) : ğ´;ğ‘„â€² and (ğ¶, ğ‘€) â‡“(ğ·,ğ‘‰), then ğ‘„âŠ¢(ğ·,ğ‘‰) : ğ´;ğ‘„â€². Proof. By induction of the derivation of (ğ¶, ğ‘€) â‡“(ğ·,ğ‘‰). â–¡ 4 A Monadic Semantics for Proto-Quipper-C Here we define a new monadic denotational semantics for Proto-Quipper-C, introduced in Section 3. We first explain the categorical structure we use such as the indexed monad for circuits. We then define the interpretation, and prove its soundness and adequacy. 4.1 The Circuit Monad We now review the notion of indexed monads [Atkey 2009] (aka parameterized monads), which plays a key role in our model. Intuitively, an indexed monad is a â€œmulti-sorted generalizationâ€ of a monad. Its formal definition is given as follows. Definition 3 (Indexed Monad [Atkey 2009]). Let C be any cartesian category and S be a category. A (strong) S-indexed monad on C is a quadruple (T,ğœ‚, ğœ‡,ğœ) where â€¢ T : Sop Ã— S Ã— C â†’C is a functor â€¢ the unit ğœ‚is a family of morphisms ğœ‚ğ‘†,ğ‘‹: ğ‘‹â†’T (ğ‘†,ğ‘†,ğ‘‹) natural in ğ‘‹and dinatural in ğ‘† 10 Ken Sakayori, Andrea Colledan, and Ugo Dal Lago â€¢ the multiplication ğœ‡is a family of morphisms ğœ‡ğ‘†1,ğ‘†2,ğ‘†3,ğ‘‹: T (ğ‘†1,ğ‘†2, T (ğ‘†2,ğ‘†3,ğ‘‹)) â†’T (ğ‘†1,ğ‘†3,ğ‘‹) natural in ğ‘†1, ğ‘†3 and ğ‘‹and dinatural in ğ‘†2. â€¢ the strength ğœis a family of morphisms ğœğ‘‹,ğ‘†1,ğ‘†2,ğ‘Œ: ğ‘‹Ã—T (ğ‘†1,ğ‘†2,ğ‘Œ) â†’T (ğ‘†1,ğ‘†2,ğ‘‹Ã—ğ‘Œ) natural in ğ‘‹, ğ‘†1, ğ‘†2 and ğ‘Œ. The unit and multiplication must obey the evident monad laws and the axiom for strength (cf. Definition 9). â— The indexed monad we are interested in is the circuit monad TM : Mop Ã— M Ã— Set â†’Set. The circuit monad is defined as follows6: TM(ğ‘‡,ğ‘ˆ,ğ‘‹) def= ğ‘‹Ã— M(ğ‘‡,ğ‘ˆ) ğœ‚ğ‘‡,ğ‘‹(ğ‘¥) def= (ğ‘¥, idğ‘‡) ğœ‡ğ‘‡1,ğ‘‡2,ğ‘‡3,ğ‘‹((ğ‘¥, ğ‘“),ğ‘”) def= (ğ‘¥, ğ‘“;ğ‘”) ğœğ‘‹,ğ‘‡,ğ‘ˆ,ğ‘Œ(ğ‘¥, (ğ‘¦, ğ‘“)) def= ((ğ‘¥,ğ‘¦), ğ‘“). So, the unit augments a value with the identity circuit and multiplication is just a sequential compo- sition of circuits. Since we assumed that the category of circuits is premonoidal, this premonoidal structure lifts to TM (in the sense of [Atkey 2009, Def. 5]). That is, there is a natural transformation (ğ‘‡â‹Šâˆ’)â€  ğ‘ˆ1,ğ‘ˆ2,ğ‘‹: TM(ğ‘ˆ1,ğ‘ˆ2,ğ‘‹) â†’TM(ğ‘‡âŠ—ğ‘ˆ1,ğ‘‡âŠ—ğ‘ˆ2,ğ‘‹) satisfying certain desired properties. In elementary terms, this is merely the map that associates (ğ‘¥,ğ¶) to (ğ‘¥,ğ‘‡â‹Šğ¶). As one might expect, we will interpret terms in the Kleisli category of TM, which we now briefly explain. Given an S-indexed monad T on C, its Kleisli category CT is a category whose objects are pairs of C and S objects and homsets CT((ğ‘‹,ğ‘‡), (ğ‘Œ,ğ‘ˆ)) def= C(ğ‘‹, T (ğ‘‡,ğ‘ˆ,ğ‘Œ)). The identity morphisms and composition of morphisms are defined using units and multiplication as the obvious generalization of those in the Kleisli category of an ordinary monad. It is known that the Kleisli category induces a parameterized Freyd category [Atkey 2009] ğ½: C Ã— S â†’CT as is the case for the ordinary monad and Freyd category; here ğ½is an identity on objects functor that strictly preserves the premonoidal structure of C. Since Freyd categories are known to have a better match with the fine-grained call-by-value syntax, our semantical model will be based on the parametrized Freyd category induced by TM. The circuit monad TM also has Kleisli exponentials: there is a functor ğ‘‹â‡’ğ‘‡âˆ’: SetTM â†’Set for every objects ğ‘‹,ğ‘‡, and there is a natural isomorphism Î›ğ‘Œ,(ğ‘‹,ğ‘‡),(ğ‘,ğ‘ˆ) : SetTM ((ğ‘ŒÃ— ğ‘‹,ğ‘‡), (ğ‘,ğ‘ˆ))  Set(ğ‘Œ,ğ‘‹â‡’ğ‘‡(ğ‘,ğ‘ˆ)). This means that the parameter- ized Freyd category induced by TM is a closed parameterized Freyd category. We note that the object ğ‘‹â‡’ğ‘‡(ğ‘,ğ‘ˆ) is just ğ‘‹â‡’Set ğ‘Ã— M(ğ‘ˆ,ğ‘‡), the set of functions from ğ‘‹to ğ‘Ã— M(ğ‘ˆ,ğ‘‡). The counit of this adjunction is written as ev: ((ğ‘‹â‡’ğ‘‡(ğ‘Œ,ğ‘ˆ)) Ã— ğ‘‹,ğ‘‡) â†’(ğ‘Œ,ğ‘ˆ). The Kleisli category SetTM is a premonoidal category, where (ğ‘‹,ğ‘‡) âŠ—(ğ‘Œ,ğ‘ˆ) = (ğ‘‹Ã—ğ‘Œ,ğ‘‡âŠ—ğ‘ˆ) and the binoidal functors are defined in a way analogous to how the premonoidal structure was lifted to TM. 7 4.2 Interpreting Types, Programs, and Configurations We now give the denotational semantics of Proto-Quipper-C using the Freyd category induced by TM. In Figure 3, we summarize the overall structure of the interpretation. Terms will be inter- preted in the Kleisli category SetTM, and values will be interpreted in Set Ã— disc(Obj(M)), where disc(Obj(M)) is the discrete category whose objects are those of M. 6This is just an indexed monad for category actions [Atkey 2009] and we do not claim any novelty in this definition. 7This should not be confused with the premonoidal structure of a parameterized Freyd category with respect to the cartesian category, which exist even if S is not premonoidal. See also Appendix C for a review on parameterized Freyd categories. On Circuit Description Languages, Indexed Monads, and Resource Analysis 11 ğœ„ğ‘‡ ğ½ ğ‘‹â‡’ğ‘‡âˆ’ Set Ã— disc(Obj(M)) = V Set Set Ã— M SetTM Fig. 3. Overview of the model for Proto-Quipper-M. Jğ´K âˆˆSet Ã— M Jğ‘ƒK def= (Jğ‘ƒKğ‘ƒ, ğ¼) Jğ‘‡K def= (1, Jğ‘‡KM) Jğ´âŠ¸ğ‘‡ğµK def= (â™­Jğ´K â‡’Jğ‘‡KM âŠ—Jâ™¯ğ´KM JğµK, Jğ‘‡KM) Jğ´âŠ—ğµK def= (ğ‘‹Ã— ğ‘Œ,ğ‘‡âŠ—ğ‘ˆ) where Jğ´K = (ğ‘‹,ğ‘‡) and JğµK = (ğ‘Œ,ğ‘ˆ) Jğ‘ƒKğ‘ƒâˆˆSet J1Kğ‘ƒ def= 1 JNatKğ‘ƒ def= N Jğ‘ƒâŠ—ğ‘…Kğ‘ƒ def= Jğ‘ƒKğ‘ƒÃ— Jğ‘…Kğ‘ƒ J!ğ´Kğ‘ƒ def= 1 â‡’ğ¼Jğ´K JCirc(ğ‘‡,ğ‘ˆ)Kğ‘ƒ def= M(Jğ‘‡KM, Jğ‘ˆKM) Jğ‘‡KM âˆˆM JQubitKM def= Q JBitKM def= B Jğ¼KM def= ğ¼ Jğ‘‡âŠ—ğ‘ˆKM def= Jğ‘‡KM âŠ—Jğ‘ˆKM Fig. 4. Interpretation of Simple Types. The interpretation of types is given in Figure 4. Types are interpreted as objects in Set Ã— M, i.e. as pairs of a set and an object of M. We write â™¯: Set Ã— M â†’M and â™­: Set Ã— M â†’Set for the obvious forgetful functors. The object ğ‘‹â‡’ğ‘‡ğ‘Œused in the interpretation of the arrow type is the parameterized Kleisli arrow of the closed parameterized Freyd category. It is used to model the type of a â€œcodeâ€ under the idea that a closure is a pair of a code and an environment. The subsctipt ğ‘‡represents the type of the additional bundled typed arguments corresponding to the free variables. Note that !ğ´is interpreted as (1 â‡’ğ¼Jğ´K, ğ¼) representing closures that do not capture any free variables having a bundle type. The objects Q and B are the interpretation of qubits and bits, respectively, that we assumed to exist in M. Lemma 1. Given a type ğ´, we have Jâ™¯ğ´KM = â™¯Jğ´K. In our interpretation, circuit types and function types for bundle types are isomorphic, and this supports our design choice for the typing rule box. Proposition 1. We have an isomorphism box : â™­Jğ‘‡âŠ¸ğ‘ˆK  JCirc(ğ‘‡,ğ‘ˆ)Kğ‘ƒin Set. Therefore, Jğ‘‡âŠ¸ğ‘ˆK  JCirc(ğ‘‡,ğ‘ˆ)K in SetTM. Proof. By unrolling the definition, we have the following obvious isomorphisms for sets â™­Jğ‘‡âŠ¸ğ‘ˆK = 1 â‡’Jğ‘‡KM (1, Jğ‘ˆKM)  1 â‡’Set 1 Ã— M(Jğ‘‡KM, Jğ‘ˆKM)  M(Jğ‘‡KM, Jğ‘ˆKM) = JCirc(ğ‘‡,ğ‘ˆ)Kğ‘ƒ. The isomorphism between Jğ‘‡âŠ¸ğ‘ˆK  JCirc(ğ‘‡,ğ‘ˆ)K is given by ğ½(box, idğ¼). â–¡ 12 Ken Sakayori, Andrea Colledan, and Ugo Dal Lago JÎ“ âŠ¢ğ‘£ğ‘‰: ğ´K JÎ¦ âŠ¢ğ‘£âˆ—: 1K def= (!JÎ¦K, idğ¼) JÎ¦, â„“: ğ‘¤âŠ¢ğ‘£â„“: ğ‘¤K def= (!JÎ¦Kğ‘ƒ, idJğ‘¤KM) JÎ¦,ğ‘¥: ğ´âŠ¢ğ‘£ğ‘¥: ğ´K def= (ğœ‹ğ‘¥, idğ¼) JÎ“ âŠ¢ğ‘£ğœ†ğ‘¥.ğ‘€: ğ´âŠ¸#(Î“) ğµK def= (Î›(Jğ‘€K), idJ#(Î“)KM) JÎ¦ âŠ¢ğ‘£lift ğ‘€: !ğ´K def= (Î›(JÎ¦ âŠ¢ğ‘ğ‘€: ğ´K), idğ¼) JÎ¦ âŠ¢ğ‘£( Â¯â„“,ğ¶, Â¯ğ‘˜) : Circ(ğ‘‡,ğ‘ˆ)K def= (!JÎ¦K; Âœ J( Â¯â„“,ğ¶, Â¯ğ‘˜)KM, idğ¼) where J( Â¯â„“,ğ¶, Â¯ğ‘˜)KM def= Jğ‘‡KM âˆ’â†’Jğ‘„KM ğ¶âˆ’â†’Jğ¿KM âˆ’â†’Jğ‘ˆKM Ë†ğ¶ def= 1 Î›(ğ½(id1,ğ¶)) âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’1 â‡’Jğ‘‡KM (1, Jğ‘ˆKM) box âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’  M(Jğ‘‡KM, Jğ‘ˆKM) JÎ¦, Î“1, Î“2 âŠ¢ğ‘£âŸ¨ğ‘‰,ğ‘ŠâŸ©: ğ´âŠ—ğµK def= JÎ¦K âŠ—JÎ“1K âŠ—JÎ“2K (Î”JÎ¦K,idğ¼)âŠ—id âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’JÎ¦K âŠ—JÎ¦K âŠ—JÎ“1K âŠ—JÎ“2K  âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’(JÎ¦K âŠ—JÎ“1K) âŠ—(JÎ¦K âŠ—JÎ“2K) Jğ‘‰KâŠ—Jğ‘ŠK âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’Jğ´âŠ—ğµK Fig. 5. Interpretation of Values. Remark 1. As briefly mentioned, in Proto-Quipper calculi, the box operator usually coerces a function of type !(ğ‘‡âŠ¸ğ‘ˆ) to a circuit type. This is because, in presheaf models of Proto-Quipper, there is an isomorphism J!(ğ‘‡âŠ¸ğ‘ˆ)K  JCirc(ğ‘‡,ğ‘ˆ)K. In our model, adding a bang to the type ğ‘‡âŠ¸ğ‘ˆmeans to additionally thunk a function that has no free variable having a bundle type. Invoking this thunk may cause some effects, i.e. produce a circuit while returning a function that corresponds to a boxed circuit. Hence, we do not have an isomorphism between J!(ğ‘‡âŠ¸ğ‘ˆ)K and JCirc(ğ‘‡,ğ‘ˆ)K. While our calculus draws inspiration from those by Colledan and Dal Lago [2024, 2025], they also coerce !(ğ‘‡âŠ¸ğ‘ˆ) to Circ(ğ‘‡,ğ‘ˆ). In their works, the issue of the effect is circumvented using the effect system; either by requiring that !(ğ‘‡âŠ¸ğ‘ˆ) has zero effect or by adding an effect annotation to the circuit type. â— Now we define the interpretation of typing judgments. The interpretation is defined in Fig- ure 5 and 6. A valid typing judgment for values Î“ âŠ¢ğ‘£ğ‘‰: ğ´is interpreted as a morphism JÎ“ âŠ¢ğ‘£ğ‘‰: ğ´K: JÎ“K â†’Jğ´K in V(= SetÃ—disc(M)) capturing the fact that values only produces trivial circuits. In contrast, a computational judgment Î“ âŠ¢ğ‘ğ‘€: ğ´is interpreted as JÎ“ âŠ¢ğ‘ğ‘€: ğ´K: JÎ“K â†’Jğ´K in SetTM. We sometimes denote these morphisms by Jğ‘‰K and Jğ‘€K. The morphisms, Î”, ğœ‹ğ‘¥and ! in Figure 5 are the diagonal map, projection, and the unique map to the terminal object 1, respectively, which exist in Set; the morphism dupğ‘‹in Figure 6 is defined as ğ½(Î”ğ‘‹, idğ¼) and it is used for du- plicating a values with a parameter type. Some obvious coherence isomorphisms of the cartesian product in Set are omitted for simplicity. The interpretation of values is standard, except for ğœ†-abstractions and boxed circuits. A ğœ†- abstraction is interpreted as a closure. The first element of Jğœ†ğ‘¥.ğ‘€K is the semantic counterpart of the function that takes variables of types â™¯(Î“) as additional parameters, and the second element idJâ™¯Î“K is the â€œenvironmentâ€. The interpretation of lift ğ‘€is just the interpretation of a thunk ğœ†().ğ‘€. On Circuit Description Languages, Indexed Monads, and Resource Analysis 13 JÎ“ âŠ¢ğ‘ğ‘€: ğ´K JÎ¦, Î“1, Î“2 âŠ¢ğ‘ğ‘‰ğ‘Š: ğµK def= JÎ¦K âŠ—JÎ“1K âŠ—JÎ“2K dupJÎ¦KâŠ—JÎ“2KâŠ—JÎ“1K âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’JÎ¦K âŠ—JÎ¦K âŠ—JÎ“1K âŠ—JÎ“2K  âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’(JÎ¦K âŠ—JÎ“1K) âŠ—(JÎ¦K âŠ—JÎ“2K) ğ½(Jğ‘‰K)âŠ—ğ½(Jğ‘ŠK) âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’Jğ´âŠ¸ğ‘‡ğµK âŠ—Jğ´K ev âˆ’â†’JğµK JÎ¦ âŠ¢ğ‘forceğ‘‰: ğ´K def= ğ½(JÎ¦ âŠ¢ğ‘£ğ‘‰: !ğ´K); ev JÎ¦, Î“1, Î“2 âŠ¢ğ‘apply(ğ‘‰,ğ‘Š) :ğ‘ˆK def= JÎ¦K âŠ—JÎ“1K âŠ—JÎ“2K dupJÎ¦KâŠ—JÎ“2KâŠ—JÎ“1K âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’JÎ¦K âŠ—JÎ¦K âŠ—JÎ“1K âŠ—JÎ“2K  âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’(JÎ¦K âŠ—JÎ“1K) âŠ—(JÎ¦K âŠ—JÎ“2K) ğ½(Jğ‘‰K)âŠ—ğ½(Jğ‘ŠK) âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’JCirc(ğ‘‡,ğ‘ˆ)K âŠ—Jğ‘ˆK apply âˆ’âˆ’âˆ’âˆ’â†’Jğ‘ˆK JÎ¦ âŠ¢ğ‘boxğ‘‡ğ‘‰: Circ(ğ‘‡,ğ‘ˆ)K def= JÎ¦K ğ½(Jğ‘‰K) âˆ’âˆ’âˆ’âˆ’âˆ’â†’Jğ‘‡âŠ¸ğ‘ˆK ğ½(box,idğ¼) âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’  JCirc(ğ‘‡,ğ‘ˆ)K JÎ“ âŠ¢ğ‘return ğ‘‰: ğ´K def= ğ½(JÎ“ âŠ¢ğ‘£ğ‘‰: ğ´K) JÎ¦, Î“2, Î“1 âŠ¢ğ‘letğ‘¥= ğ‘€in ğ‘:ğµK def= JÎ¦K âŠ—JÎ“2K âŠ—JÎ“1K (dupJÎ¦KâŠ—JÎ“1KâŠ—JÎ“2K); âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’(JÎ¦K âŠ—JÎ“2K) âŠ—(JÎ¦K âŠ—JÎ“1K) (JÎ¦KâŠ—JÎ“2K)â‹ŠJğ‘€K âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’JÎ¦K âŠ—JÎ“2K âŠ—Jğ´K Jğ‘K âˆ’âˆ’âˆ’â†’JğµK JÎ“1,ğ‘: ğ´,ğ‘: ğµ, Î“2 âŠ¢ğ‘ğ‘€: ğ¶K = JÎ“1K âŠ—Jğ´K âŠ—JğµK âŠ—JÎ“2K âˆ’â†’JÎ“1K âŠ—JğµK âŠ—Jğ´K âŠ—JÎ“2K Jğ‘€K âˆ’âˆ’âˆ’â†’Jğ¶K Fig. 6. Interpretation of computational judgments of the simple type system (excerpt). In the interpretation of boxed circuits, we use isomorphisms Jğ‘‡KM  Jğ‘„KM and Jğ¿KM  Jğ‘ˆKM that exist thanks to the premises of the typing rule circ such as ğ‘„ğœğ‘„â€² and ğ‘„â€² âŠ¢ğ‘£Â¯â„“: ğ‘‡. The important part of the interpretation of a boxed circuit ğ¶is the map Ë†ğ¶, which is just the global element Ë†ğ¶(âˆ—) def= ğ¶. The definition using Î› and box emphasizes the idea that boxed circuits can be seen as special functions. As for the interpretation of terms, the interpretation of apply(ğ‘‰,ğ‘Š) and boxğ‘‡ğ‘‰are the most interesting cases. The morphism applyğ‘‡,ğ‘ˆ: (M(ğ‘‡,ğ‘ˆ), ğ¼) âŠ—(1,ğ‘‡) â†’(1,ğ‘ˆ) is defined by (M(ğ‘‡,ğ‘ˆ), ğ¼) âŠ—(1,ğ‘‡) ğ½(boxâˆ’1,idğ¼)âŠ—id(1,ğ‘‡) âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’(1 â‡’ğ‘‡(1,ğ‘ˆ), ğ¼) âŠ—(1,ğ‘‡) ev âˆ’â†’(1,ğ‘ˆ). The box operator is interpreted by the post-composition of the isomorphism between function types and circuit types given in Proposition 1. The interpretation of the let operator is also worth explaining. The premonoidal product (JÎ¦K âŠ—JÎ“2K) â‹ŠJğ‘€K adds wires of type â™¯JÎ“2K (and â™¯JÎ¦K = ğ¼ which can be ignored) to the circuit produced by ğ‘€so that ğ‘can use these wires. Remark 2. The interpretation is somewhat unorthodox in that some syntactic constructs do not have a corresponding semantic operator. This is because we are doing two things at once. The interpretation can be factorized into (1) a syntactic translation from Proto-Quipper-C to the internal language of parametrized Freyd categories (called the command calculus) [Atkey 2009] and (2) 14 Ken Sakayori, Andrea Colledan, and Ugo Dal Lago interpreting the translated term. The syntactic translation resembles a variant of closure conversion, but we are not sure if a category theoretic explanation can be given to this translation. â— The categorical semantics is correct with respect to the big-step operational semantics. To further elaborate on this result we first extend the interpretation to configurations. Intuitively, J(ğ¶, ğ‘€)K is the morphism obtained by post-composing Jğ‘€K, together with some parallel wires, to ğ¶. Definition 4 (Interpretation of Configurations). Suppose that ğ‘„âŠ¢(ğ¶,ğ‘‰) : ğ´;ğ‘„â€² and suppose that ğ¿and ğ¿â€² are the label contexts that satisfy ğ¶: ğ‘„â†’ğ¿â€²,ğ‘„â€²; ğ¿ğœğ¿â€²; and ğ¿âŠ¢ğ‘£ğ‘‰: ğ´. Then we defineJ(ğ¶,ğ‘‰)K as (id1,ğ¶; perm); (Jğ¿âŠ¢ğ‘£ğ‘‰: ğ´K âŠ—idJğ‘„â€²K), which is a morphism in Set Ã— M. Here, perm is the isomorphism Jğ¿â€²KM âŠ—Jğ‘„â€²KM âˆ’â†’Jğ¿KM âŠ—Jğ‘„â€²KM. Similarly, for ğ‘„âŠ¢(ğ¶, ğ‘€) : ğ´;ğ‘„â€², we define J(ğ¶, ğ‘€)K as ğ½(id1,ğ¶); (Jğ¿âŠ¢ğ‘ğ‘€: ğ´K â‹‰Jğ‘„â€²K), which is a morphism in SetTM. Here, ğ¿is the label context that types ğ‘€as in the case of ğ‘‰. â— 4.3 Main Results We are now ready to state the soundness and computational adequacy properties. Theorem 5 (Soundness). Suppose that ğ‘„âŠ¢(ğ¶, ğ‘€) : ğ´;ğ‘„â€² and (ğ¶, ğ‘€) â‡“(ğ¶â€²,ğ‘‰). Then J(ğ¶, ğ‘€)K = ğ½(J(ğ¶â€²,ğ‘‰)K). Proof. By induction on the derivation of the big-step evaluation relation. See Appendix A for the details. â–¡ Theorem 6 (Computational Adequacy). Suppose that âˆ…âŠ¢(ğ¶, ğ‘€) : 1; âˆ…and J(ğ¶, ğ‘€)K = ğ½(J(ğ·,ğ‘‰)K). Then (ğ¶, ğ‘€) â‡“(ğ·,ğ‘‰) (possibly up to renamings of labels). Proof. By an argument utilizing logical relations similar to those defined in [Colledan and Dal Lago 2024], which are given in Appendix A. â–¡ 5 Effect System We extend the type system defined in Section 3 with effect annotations that estimate the properties (e.g. size) of the circuit generated by a program. To put it another way, we introduce the type system underlying (a non-dependent version of) Proto-Quipper-R. Then we give the interpretation of programs in Proto-Quipper-R by using the category graded monad [Orchard et al. 2020]. This exemplifies that the type-and-effect system of Proto-Quipper-R, although rooted in an operational perspective, also has a natural denotational reading. 5.1 Effects for Circuits When designing an effect system, the key question to ask is â€œWhat kind of structure should we assume on effects?â€. A common choice is to use a preordered monoid [Katsumata 2014], where the monoid multiplication is used to compute the effect of sequential execution and the preorder is used for subtyping. We make the same choice, but use categories instead of monoids because circuits are many-sorted in the sense that circuits have various input and output interfaces. Moreover, since we have postulated that circuits form a premonoidal category, it is natural to require that the algebraic structure representing the effectâ€”dubbed circuit algebraâ€”also be premonoidal. Definition 7 (Circuit Algebra). A circuit algebra E is a strict symmetric premonoidal category that is preorder enriched. The preorder enrichment means that: â€¢ each homset E(t, u) is a preordered set; â€¢ composition of morphisms preservers the order: if ğ‘’1 â‰²ğ‘‘1 and ğ‘’2 â‰²ğ‘‘2, then ğ‘’1;ğ‘’2 â‰²ğ‘‘1;ğ‘‘2; On Circuit Description Languages, Indexed Monads, and Resource Analysis 15 â€¢ t â‹‰âˆ’(resp. âˆ’â‹Št) preserves the order for any t: if ğ‘’â‰²ğ‘‘, then t â‹‰ğ‘’â‰²t â‹‰ğ‘‘. We call morphisms of E, ranged over by ğ‘’,ğ‘‘, . . ., effect annotations. The identity over the monoidal unit i of E is denoted by ğœ€, and we call it the null effect. Objects of E will often be written in lowercase script letters so that they are distinguishable from objects of M. â— Effect annotations are meant to abstract the actual effect. We propose to consider this abstraction as a functor. Definition 8 (Abstraction). An abstraction ğ›¼from the category of circuits M to a circuit algebra E is a strict symmetric premonoidal functor ğ›¼: M â†’E. That is, ğ›¼is a functor satisfying ğ›¼(ğ‘‡âŠ—ğ‘ˆ) = ğ›¼(ğ‘‡) âŠ—ğ›¼(ğ‘ˆ) (equality on the nose), ğ›¼(ğ‘‡â‹Šğ‘“) = ğ›¼(ğ‘‡) â‹Šğ›¼(ğ‘“), ğ›¼(ğ‘”â‹‰ğ‘ˆ) = ğ›¼(ğ‘”) â‹‰ğ›¼(ğ‘ˆ) and preserves the symmetry. â— In case M is the syntactic category of circuits, defining an abstraction is no different from giving a functorial semantics to circuits. We believe that allowing arbitrary interpretations of circuits as effect annotations is not only conceptually clean but also helps us conceive of a wide variety of examplesâ€”though in practice, we should seek efficiently implementable effects. Remark 3. We defined abstractions as strict premonoidal functors because it is known that a non-strict premonoidal functor is tricky to define [RomÃ¡n and SobociÅ„ski 2025; Staton and Levy 2013]. A way to circumvent this issue is to use effectful categories [RomÃ¡n and SobociÅ„ski 2025], which are premonoidal categories endowed with a chosen family of central morphisms, as the definition of circuits. However, using premonoidal categories and strict premonoidal functors are enough to deal with examples of circuit algebras we show below, which contains examples for resource estimations that have been considered in the literature. â— Examples of Circuit Algebras. Here we give some examples of circuit algebras that capture some notions of circuit metrics. Since the concept of circuit metrics is intrinsically intensional, namely the way gates are placed is important, we consider the syntactic category of circuits for the category M in the following examples. A signature is a tuple Î£ = (Î£0, Î£1) where Î£0 is the set of object variables, Î£1 is the set of generators, which are typed constants of the form ğ‘“: ğœâ†’ğœwith ğœ,ğœâˆˆÎ£âˆ— 0. We write MÎ£ for the free strict symmetric premonoidal category (with trivial center) generated by the signature Î£, which can be defined by designing an appropriate term calculus (as in [Joyal and Street 1991]) or by considering string diagrams. To facilitate understanding, we shall informally deal with string diagrams by depicting the graph and considering them as â€œmonoidal string diagrams without interchange lawâ€ (see e.g. [RomÃ¡n and SobociÅ„ski 2025] for a more mathematically formal definition). Note that a functor ğ›¼: MÎ£ â†’E is determined if we define how object variables and generators are mapped to objects and morphisms of E, respectively. As a prototypical example, we shall consider string diagrams over the signature Î£QC for quantum circuits. The set Î£QC 0 is defined as {Qubit, Bit} and the generators are finite sequences over the set of gates Î£ğº. We assume that the set Î£ğº, which is also a set of generators, contains usual quan- tum gates such as the Hadamard gate H : Qubit â†’Qubit, CNOT gate CNOT : (Qubit, Qubit) â†’ (Qubit, Qubit) and measurement meas: Qubit â†’Bit. A sequence Ëœğ‘”= ğ‘”1 Â· Â· Â· ,ğ‘”ğ‘›âˆˆÎ£QC 1 has the type ğœ1 Â· Â· Â· ğœğ‘›â†’ğœ1 Â· Â· Â·ğœğ‘›provided that ğ‘”ğ‘–: ğœğ‘–â†’ğœğ‘–, and intuitively corresponds to applying the gates ğ‘”ğ‘–in parallel. In a sense, this means that it is users responsibility to explicitly state which gates to be placed in parallel, and users cannot expect the gates to automatically slide and be parallelized. Example 1 (Gate count and naive depth). The simplest notion of circuit metric we consider is gate count. The number of gates can be captured by the monoid (N, +), which can be seen as a single object circuit algebra (where we denote the only object as â˜…) whose morphisms are natural 16 Ken Sakayori, Andrea Colledan, and Ugo Dal Lago numbers ğ‘›: â˜…â†’â˜…. Sequential composition is defined as addition and the identity morphism is given by 0. The functor â˜…â‹‰âˆ’is simply given as the identity functor: â˜…â‹‰â˜… def= â˜…and â˜…â‹‰ğ‘› def= ğ‘›. Obviously, this category is order enriched by considering the standard ordering for the natural numbers. The abstraction functor ğ›¼ğº: MÎ£QC â†’N is defined by mapping Ëœğ‘”âˆˆÎ£QC 1 to the number of gates in Ëœğ‘”. A very rough estimation of the circuit depth can be given by the same circuit algebra. We define ğ›¼ğ·: MÎ£QC â†’N by ğ›¼ğ·( Ëœğ‘”) = 1 for every ğ‘”âˆˆÎ£QC 1 . For example, let us consider the following circuits. ğ‘1 ğ» ğ‘‹ ğ‘2 ğ» (4) ğ‘1 ğ» ğ‘‹ ğ‘2 ğ» (5) Here, in (5), the X and Hadamard gate are placed parallelly. The number of gates is estimated as 3 both in (4) and (5). On the other hand, the depth is estimated as 3 in (4) since the three gates are sequentially composed, but 2 in (5). While this way of counting depth has its own benefit of being easy to compute, it is not satisfactory because typically the depth of (4) is also defined as 2; below we shall see a better way to count depth. â— Example 2 (Width [Colledan and Dal Lago 2025]). We explain a circuit algebra W that is used to estimate (upper bounds on) the width of a circuit and an abstraction ğ›¼W : MÎ£QC â†’W. Recall that the width of a circuit is just a natural number that is defined as the maximum number of wires active at any point in the circuit. Therefore, morphisms in W should be natural numbers. For example, a quantum circuit ğ¶depicted as |0âŸ© ğ‘1 ğ» ğ‘2 (6) has with width 3, i.e. ğ›¼W(ğ¶) = 3. Note that a wire of type Qubit is counted as a circuit of width 1. This leads us to define ğ›¼(idQubit) : ğ›¼(Qubit) â†’ğ›¼(Qubit) as the natural number 1. Now how should we define ğ›¼(Qubit)? Since this object should contain enough information to define the width of wires of type Qubit, a natural choice is to define this as the natural number 1. Hence, we also define objects of W as natural numbers. The sequential composition of morphisms ğ‘˜1 ğ‘š âˆ’â†’ğ‘˜2 and ğ‘˜2 ğ‘›âˆ’â†’ğ‘˜3 in W is defined as ğ‘˜1 max(ğ‘š,ğ‘›) âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ğ‘˜3 reflecting the definition of the width of a circuit. The functor ğ‘˜â‹Šâˆ’(resp. ğ‘˜â‹Šâˆ’) represents parallelly adding ğ‘˜wires. Hence, we define ğ‘˜â‹Šğ‘š def= ğ‘˜+ ğ‘š. To summarize, W is given by the following data: â€¢ Obj(W) def= N, â€¢ W(ğ‘˜1,ğ‘˜2) def= (N, â‰¤N), and the composition is defined by max, with the identity morphism over an object ğ‘˜being the morphism ğ‘˜itself. â€¢ functors ğ‘˜â‹Šâˆ’(resp. âˆ’â‹‰ğ‘˜) such that the action on objects and morphisms are both defined as ğ‘˜+ (âˆ’). â— Example 3 (Depth). We give a better circuit algebra for depth, which may be seen as a way to count the naive depth of a circuit after optimizing it by sliding gates. The idea is to track the depth using matrices over max-plus tropical semiring (N âˆª{âˆ’âˆ}, max, +), where the (ğ‘–, ğ‘—) component On Circuit Description Languages, Indexed Monads, and Resource Analysis 17 of the matrix describes the cost for traversing from the ğ‘–-th input to the ğ‘—-th output. We define a circuit algebra D as follows: â€¢ Obj(D) def= N, â€¢ D(ğ‘˜1,ğ‘˜2) def= ğ‘€ğ‘˜1,ğ‘˜2 (N) Ã— ğ‘€1,ğ‘˜1(N) Ã— ğ‘€ğ‘˜2,1(N), where ğ‘€ğ‘˜1,ğ‘˜2 (N) is the set of ğ‘˜1 Ã— ğ‘˜2 ma- trices over the tropical semiring. The composition (A1, v1, w1) â—¦(A2, v2, w2) is given as (A1A2, max(v1A2, v2), max(w1, A1v2); here max acts on vectors component-wise. The iden- tity morphism over ğ‘˜is given as (Iğ‘˜, 01Ã—ğ‘˜, 0ğ‘˜Ã—1), where Iğ‘˜is the ğ‘˜Ã— ğ‘˜identity matrices and 0ğ‘›Ã—ğ‘šis the ğ‘›Ã—ğ‘šzero matrix over the tropical semiring. These should not be confused with the standard identity and zero matrices, say over Q. For example, 01Ã—ğ‘˜is (âˆ’âˆ, . . . , âˆ’âˆ). The ordering on morphisms is given by ordering over matrices where A â‰¤B if ğ‘ğ‘–,ğ‘—â‰¤ğ‘ğ‘–,ğ‘— for every (ğ‘–, ğ‘—). â€¢ functors ğ‘˜â‹Šâˆ’(resp. âˆ’â‹‰ğ‘˜) are defined by the â€œdirect sumâ€ of matrices. Concretely, for (A, v, w) âˆˆD(ğ‘˜1,ğ‘˜2), we define (A, v, w)â‹Šğ‘˜as (  A 0ğ‘˜1Ã—ğ‘˜ 0ğ‘˜Ã—ğ‘˜2 Iğ‘˜  , (v, 01Ã—ğ‘˜),  w 0ğ‘˜Ã—1 ). Here again, the zero and identity matrices are those over the tropical semiring. As mentioned, components of (A, v, w) represents the cost of the paths in a circuit as illustrated in Figure 7. The role of the vectors v and w is to track the depth of wires that have â€œdead endsâ€, for instance, created by qubit creation or annihilation. The ğ‘–-th component of v describes the maximum cost for traversing the circuit from the ğ‘–-th input until it reaches an end. Conversely, the ğ‘–-th component of the vector w tracks the maximum depth of a path starting from an â€œendâ€ and ending at the ğ‘–-th output. 1 ğ‘˜1 ... 1 ğ‘˜2 ... ğ‘¤1 ğ‘11 ğ‘1ğ‘˜2 ğ‘ğ‘˜11 ğ‘ğ‘˜1ğ‘˜2 ğ‘£ğ‘˜1 Fig. 7. Components of (A, v, w). The depth of the circuit (4) of Example 1, is given as ( 1 âˆ’âˆ âˆ’âˆ 2  , (âˆ’âˆ, âˆ’âˆ), ( âˆ’âˆ âˆ’âˆ)). Now we can correctly conclude that the depth is 2, not 3, as the maximum number in the tuple is 2. As an example containing a â€œdead endâ€, we show the depth of the circuit (6) of Example 2. It is given as ( 2 2 âˆ’âˆ âˆ’âˆâˆ’âˆ 0  , (âˆ’âˆ, âˆ’âˆ),  1 1 âˆ’âˆ  ). â— It is natural to ask whether any matrix circuit algebra can capture optimized circuit width taking into account the so-called qubit recycling. Given well-known results on the NP-hardness of qubit recycling [Jiang 2024], this seems difficult. On the other hand, it is possible to capture the so-called qubit dependency graph, which serves as input to a (heuristic) solver that outputs a qubit recycling strategy [Jiang 2024]. The graph can be calculated as an adjacent matrix (over the boolean semiring) by employing an approach similar to that used for capturing circuit depth. Example 4 (Assertion-Based Optimization). We consider the size of quantum circuits modulo an optimization that removes operations that act trivially on states that are known to satisfy certain conditions. For example, if we know that the input of a CNOT gate is in a state |ğœ“âŸ©= 18 Ken Sakayori, Andrea Colledan, and Ugo Dal Lago ğ›¼00 |00âŸ©+ ğ›¼01 |01âŸ©, then we know that this CNOT operation is trivial in the sense that it behaves as the identity operation because |0ğ‘âŸ© CNOT â†¦âˆ’âˆ’âˆ’âˆ’â†’|0ğ‘âŸ©for ğ‘âˆˆ{0, 1}. This is actually the case for the circuit (6) of Example 2, meaning that we may remove the CNOT gate since it is redundant. In (6), the fact that the first qubit is zero is evident because it was created right before the CNOT gate, but we may also assert such properties against inputs of the circuit and remove gates based on these assertions. This is the core idea of an automated optimization methodology proposed by HÃ¤ner et al. [2020].8 Our aim here is not to give an effect annotation that works as an optimizer that transforms a given circuit but to capture the size of the circuit after the optimization as an effect annotation. For the size, we consider gate counts for simplicity, but the other circuit metrics can be used as well. Since the size of the circuit depends on the precondition, we consider a function of the type Pğ‘‹â†’Pğ‘ŒÃ— N, essentially a forward predicate transformer combined with a â€œcost monad â€ (i.e. a writer monad) (âˆ’) Ã— N. The reason for returning not just the size but also the postcondition in Pğ‘Œ, is simply to make the effect annotations compose. The choice of the set ğ‘‹and ğ‘Œis the key to obtaining a tractable notion of effect annotation. Here, we follow HÃ¤ner et al. [2020] and take ğ‘‹ def= {0, 1}ğ‘šand ğ‘Œ def= {1, 0}ğ‘›, where ğ‘šand ğ‘›are the number of input and output qubits, respectively. A bitstring ğ‘âˆˆ{0, 1}ğ‘›represents the ğ‘-th (written in the binary format) computational base state, and ğ¿âŠ†{0, 1}ğ‘›can be considered as the set of possible outcomes of the quantum state. Formally, we say that a (pure) state |ğœ“âŸ©âˆˆC2ğ‘›satisfies the predicate ğ¿if |ğœ“âŸ©= Ã ğ‘âˆˆ{0,1}ğ‘›ğ›¼ğ‘|ğ‘âŸ© and |ğ›¼ğ‘| > 0 implies ğ‘âˆˆğ¿.9 For CNOT, we define a function ğ‘’: {0, 1}2 â†’{0, 1}2 Ã— N, which, for instance, associates {00, 01} to ({00, 01}, 0) and {00, 10} to ({00, 11}, 1). The reason why we assign the cost 0 to {00, 01} is because CNOT acts as an identity for |ğœ“âŸ©satisfying {00, 01}, meaning that this CNOT gate can be removed by optimization. To capture the linearity of the operation, we require that the effect P({0, 1}ğ‘š) â†’P({0, 1}ğ‘›) Ã— N to be join preserving.10 The circuit algebra we consider, denoted as Asrt is defined as follows: â€¢ Objects are natural numbers â€¢ A morphism ğ‘’âˆˆAsrt(ğ‘š,ğ‘›) is a function from P({0, 1}ğ‘š) to P({0, 1}ğ‘›) Ã— N that is join preserving. That is, ğ‘’(ğ¿1 âˆªğ¿2) = (ğ¿â€² 1 âˆªğ¿â€² 2, max(ğ‘1,ğ‘2)) where ğ‘’(ğ¿ğ‘–) = (ğ¿â€² ğ‘–,ğ‘ğ‘–). Sequential composition is defined as that of the writer monad, and the identity morphism is simply ğ¿â†¦â†’ (ğ¿, 0). The ordering between morphisms is defined as ğ‘’â‰²ğ‘‘if, for every ğ¿, ğ‘’(ğ¿) â‰²P({0,1}ğ‘˜)Ã—N ğ‘‘(ğ¿), where â‰²P({0,1}ğ‘˜)Ã—N is the product order of (P({0, 1}ğ‘˜), âŠ†) and (N, â‰¤N). â€¢ the functor ğ‘˜â‹Šâˆ’that acts on ğ‘’: ğ‘šâ†’ğ‘›as (ğ‘˜â‹Šğ‘’)(ğ¿) def= Ã (ğ‘1,ğ‘2)âˆˆğ¿ğ‘’({ğ‘1}) Ã— {ğ‘2}. On objects, it just acts as ğ‘˜+ (âˆ’) as the previous examples. If we consider a subsignature of Î£QC that only has Qubit as object variable and unitary gates as generators and the free premonoidal category generated by it, then we can define the abstraction function to Asrt by giving the interpretation to these unitary operators as we did for CNOT. We can also handle Bit and non unitary operation such as meas : Qubit â†’Bit by considering the set of predicates P({0, 1}ğ‘šÃ— {0, 1}ğ‘›) for a state with ğ‘šqubits and ğ‘›classical bits. â— The circuit algebra examples we have discussed encompass all those previously considered by Colledan and Dal Lago [2025]. In contrast, Example 4 represents a novel contribution: to the best of the authorsâ€™ knowledge, no existing resource analysis techniques for quantum programs in the literature account for optimizations, i.e., no such techniques is capable of deriving bounds that reflect the improvement in size induced by optimizations. It is also worth noting that the notions of 8This optimization method is implemented as a transpiler pass in Qiskit [Qiskit API reference 2025]. 9It is easy to extend this satisfaction relation to mixed states. 10It is well-known that there is a bijection between join preserving functions from Pğ‘‹to Pğ‘Œand Kleisli morphisms ğ‘“: ğ‘‹â†’Pğ‘Œ. Similarly, we may think that we are working with morphisms ğ‘‹â†’Pğ‘ŒÃ— N. On Circuit Description Languages, Indexed Monads, and Resource Analysis 19 width and depth used by Colledan and Dal Lago differ in nature: the former is global, assigning a single numerical value to each circuit, while the latter is local, assigning a value to each individual qubit. These two types of metrics are captured in different ways in op. cit. Circuit algebras provide a unified formalism that can accommodate both global and local metrics within the same framework. As we will see, the proof of soundness of the resulting type system will be done just once. 5.2 Type-and-Effect System Now we add effect annotations to the types. The type system is parameterized by an abstraction to a circuit algebra ğ›¼: M â†’E. As usual, arrow types have annotations that estimate the scope of effect caused by invoking the function. We also annotate ! and Circ(ğ‘‡,ğ‘ˆ) because thunks and boxed circuits can be thought of as special functions. The grammar of types and parameter types now become as follows: Types ğ´, ğµF ğ‘ƒ| ğ‘‡| ğ´âŠ—ğµ| ğ´ ğ‘’: tâ†’u âŠ¸ğ‘‡ ğµ Parameter types ğ‘ƒ, ğ‘…F 1 | Nat | ğ‘ƒâŠ—ğ‘…| !ğ‘’: tâ†’u ğ´| Circğ‘’: uâ†’s(ğ‘‡,ğ‘ˆ) The definition of bundle types remains the same. The typing judgment for computations now takes the form Î“ âŠ¢ğ‘ğ‘€: ğ´;ğ‘’: t â†’u. The annotation ğ‘’: t â†’u gives the information about the circuit generated by ğ‘€; the type of the effect annotation t â†’u are sometimes omitted for readability. The shape of typing judgment for values is the same as before. Typing rules are given in Figure 8. Rules for lambda abstraction, application, thunking and forcing are the standard rules. The rule for boxed circuit adds the effect ğ‘’calculated by abstracting the circuit ğ¶as the annotation. In practice, the boxed circuits are the primitive constant circuits for which the abstraction is predefined. The rules of greatest interest may be the rules for return and let. Usually, the rule for return in a type-and-effect system adds the null effect since values are effectless. In our calculus, we cannot give such a uniform treatment to values. Instead, we add the annotation idt, which represents the effect of the identity circuit of type â™¯Jğ´K. This is different from the null effect; for example, if we are interested in width, the width of identity circuits cannot be treated as zero. For the same reason that we cannot ignore identity circuits, the rule for let is annotated by (id â‹Šğ‘’1);ğ‘’2 rather than ğ‘’1;ğ‘’2. We also have a new subsumption rule, which allows us to relax the effect annotation.11 We note that the domain (resp. codomain) of the effect is an abstraction of the bundle type of the type environment (resp. return type). Lemma 2. Suppose that Î“ âŠ¢ğ‘ğ‘€: ğ´;ğ‘’: t â†’u. Then we have ğ›¼(â™¯JÎ“K) = t and ğ›¼(â™¯Jğ´K) = u. â–¡ We also adjust the typing for configurations. We write ğ‘„âŠ¢(ğ¶, ğ‘€) : ğ´;ğ‘„â€²;ğ‘’: t â†’u if ğ¶: ğ‘„â†’ğ¿,ğ‘„â€² and ğ¿âŠ¢ğ‘ğ‘€: ğ´;ğ‘’: t â†’u for some label context ğ¿disjoint from ğ‘„. Type preservation (Theorem 2) holds even after this modification. Example 5 (A program with information about assertion-based optimization). We provide a simple example of how Proto-Quipper-R can be used to verify the resource usage of a circuit at the language level. We use a program that generates an inefficient circuit for a linear nearest-neighbor (LNN) architecture, taken from Figure 3 of [HÃ¤ner et al. 2020]. In a LNN architecture gates can be applied only to adjacent quibits, and because of this restriction, a programmer (or a compiler) might write an inefficient code following a certain idiom. The program12in Figure 9 is an example of such a program, which generates the left circuit given below. This circuit can be optimized into the one in the right by optimizing the trivial CNOT gates, which are gray in the left circuit. 11It is also possible to define a subtyping relation based on the ğ‘’â‰²ğ‘’â€² in a standard way. 12For readability, we did not write the program using the syntax of Section 3, but a variant that uses a ML-like syntax. 20 Ken Sakayori, Andrea Colledan, and Ugo Dal Lago abs Î“,ğ‘¥: ğ´âŠ¢ğ‘ğ‘€: ğµ;ğ‘’: t â†’u Î“ âŠ¢ğ‘£ğœ†ğ‘¥ğ´.ğ‘€: ğ´ ğ‘’: tâ†’u âŠ¸#(Î“) ğµ app Î¦, Î“1 âŠ¢ğ‘£ğ‘‰: ğ´ ğ‘’: sâ†’u âŠ¸ğ‘‡ ğµ Î¦, Î“2 âŠ¢ğ‘£ğ‘Š: ğ´ Î¦, Î“1, Î“2 âŠ¢ğ‘ğ‘‰ğ‘Š: ğµ;ğ‘’: s â†’u lift Î¦ âŠ¢ğ‘ğ‘€: ğ´;ğ‘’: t â†’u Î¦ âŠ¢ğ‘£lift ğ‘€: !ğ‘’ğ´ force Î¦ âŠ¢ğ‘£ğ‘‰: !ğ‘’ğ´ Î¦ âŠ¢ğ‘forceğ‘‰: ğ´;ğ‘’: t â†’u circ ğ¶: ğ‘„â†’ğ¿ ğ‘„ğœğ‘„â€² ğ¿ğœğ¿â€² ğ‘„â€² âŠ¢ğ‘£Â¯â„“: ğ‘‡ğ¿â€² âŠ¢ğ‘£Â¯ğ‘˜: ğ‘ˆğ›¼(J( Â¯â„“,ğ¶, Â¯ğ‘˜)KM) = ğ‘’ Î¦ âŠ¢ğ‘£( Â¯â„“,ğ¶, Â¯ğ‘˜) : Circğ‘’(ğ‘‡,ğ‘ˆ) box Î¦ âŠ¢ğ‘£ğ‘‰: ğ‘‡ ğ‘’: tâ†’u âŠ¸ğ¼ ğ‘ˆ Î¦ âŠ¢ğ‘boxğ‘‡ğ‘‰: Circğ‘’: tâ†’u(ğ‘‡,ğ‘ˆ);ğœ€ apply Î¦, Î“1 âŠ¢ğ‘£ğ‘‰: Circğ‘’: tâ†’u(ğ‘‡,ğ‘ˆ) Î¦, Î“2 âŠ¢ğ‘£ğ‘Š: ğ‘‡ Î¦, Î“1, Î“2 âŠ¢ğ‘apply(ğ‘‰,ğ‘Š) : ğ‘ˆ;ğ‘’: t â†’u dest Î¦, Î“1 âŠ¢ğ‘£ğ‘‰: ğ´âŠ—ğµ Î¦, Î“2,ğ‘¥: ğ´,ğ‘¦: ğµâŠ¢ğ‘ğ‘€: ğ¶;ğ‘’ Î¦, Î“2, Î“1 âŠ¢ğ‘let âŸ¨ğ‘¥,ğ‘¦âŸ©= ğ‘‰in ğ‘€: ğ¶;ğ‘’ ifz Î¦ âŠ¢ğ‘£ğ‘‰: Nat Î¦, Î“ âŠ¢ğ‘ğ‘€: ğ´;ğ‘’ Î¦, Î“ âŠ¢ğ‘ğ‘: ğ´;ğ‘’ Î¦, Î“ âŠ¢ğ‘ifz ğ‘‰then ğ‘€else ğ‘: ğ´;ğ‘’ return Î“ âŠ¢ğ‘£ğ‘‰: ğ´ ğ›¼(â™¯Jğ´K) = t Î“ âŠ¢ğ‘return ğ‘‰: ğ´; idt : t â†’t let Î¦, Î“1 âŠ¢ğ‘ğ‘€: ğ´;ğ‘’1 : t1 â†’tâ€² 1 Î¦, Î“2,ğ‘¥: ğ´âŠ¢ğ‘ğ‘: ğµ;ğ‘’2 : t2 â†’tâ€² 2 ğ›¼(Jâ™¯Î“ğ‘–K) = uğ‘– ğ‘’= (idu2 â‹Šğ‘’1);ğ‘’2 Î¦, Î“2, Î“1 âŠ¢ğ‘let ğ‘¥= ğ‘€in ğ‘: ğµ;ğ‘’ sub Î“ âŠ¢ğ‘ğ‘€: ğ´;ğ‘’1 : t â†’u ğ‘’1 â‰²ğ‘’2 Î“ âŠ¢ğ‘ğ‘€: ğ´;ğ‘’2 : t â†’u Fig. 8. Typing Rules for the Effect System of Proto-Quipper-R (excerpt). |0âŸ© |0âŸ© |0âŸ© |0âŸ© ğ» |0âŸ© |0âŸ© |0âŸ© |0âŸ© ğ» These circuits are circuits that entangle four qubits as is clear from the right circuit; the left circuit is also a somewhat natural implementation of such a circuit that a compiler may emit. The three consecutive CNOT gates acting on the top two qubits of the left circuit, as well as those acting on the second and third qubits, are implementations of swap gates using CNOT gates. These swaps are often inserted to naively implement an operation that acts at a distance. The left circuit above is just an implementation of the following circuit (followed by a simple optimization that removes two consecutive applications of the same CNOT gate) that entangles the qubits by repeatedly applying CNOT to the first qubit and the other qubits. |0âŸ© |0âŸ© |0âŸ© |0âŸ© ğ» = |0âŸ© |0âŸ© |0âŸ© |0âŸ© ğ» On Circuit Description Languages, Indexed Monads, and Resource Analysis 21 1 âˆ’âˆ’init4 : Circ( I , qubit âŠ—qubit âŠ—qubit âŠ—qubit) [e1] 2 let (q1, q2, q3, q4) = apply(init4 , âˆ—) in 3 âˆ’âˆ’hadamard : Circ(qubit , qubit) [e2] 4 let q1 = apply(hadamard,q1) in 5 âˆ’âˆ’cnot12 : Circ(qubit âŠ—qubit , qubit âŠ—qubit) [e3] 6 let (q1, q2) = apply(cnot12, (q1, q2)) in 7 âˆ’âˆ’cnot21cnot12 : Circ(qubit âŠ—qubit , qubit âŠ—qubit) [e4] 8 âˆ’âˆ’The sequential composition of cnot21 and cnot12 9 let (q1, q2) = apply(cnot21cnot12, (q1, q2)) in 10 let (q2, q3) = apply(cnot12, (q2, q3)) in 11 let (q2, q3) = apply(cnot21cnot21) in 12 ... 13 return (q1, q2, q3, q4) Fig. 9. A program that generates a chain of redundant CNOTs for a LNN architecture. We show how, by using the circuit algebra given in Exampe 4, the effect system can capture that the number of gates of the produced circuit after being optimized. In Figure 9, the types of circuits that are being applied are given as comments, where Circ(ğ‘‡,ğ‘†)ğ‘’is written as Circ(T, S) [e]. Here we explain how each ğ‘’ğ‘–is defined. The effect annotation ğ‘’1 for the four qubit initialization is defined by ğ‘’1(ğ‘†) = ({0000}, 0). (We are not counting the initializations as gates.) For the Hadamard gate, the effect annotation ğ‘’2 is defined by ğ‘’2(ğ‘†) = ({1, 0}, 1); the first element is {1, 0} because the result after applying the Hadamard gate is a superposition of base states, and the second element 1 is the count. The effect annotation ğ‘’3 for the CNOT gate is the one that we explained in Example 4, which, in particular, satisfies ğ‘’3({00, 10}) = ({00, 11}, 1). Note that this means we have ğ‘1 = ğ‘2 after line 6. We can define the effect annotation ğ‘’4 for cnot21cnot12 to satisfy ğ‘’4({00, 11}) = ({00, 11}, 0) because (CNOT 12 â—¦CNOT 21)(|00âŸ©) = |00âŸ©and (CNOT 12 â—¦CNOT 21)(|11âŸ©) = |11âŸ©. That is, cnot21cnot12 acts as identity and can be removed if ğ‘1 = ğ‘2. Hence, the effect annotation ğ‘’(restricted to the first two qubits) for the program from line 1 to line 9, satisfies ğ‘’({ğœ€}) = ({00, 11}, 3) meaning that ğ‘1 = ğ‘2 and we only need three gates, as opposed to five, after the optimization. â— 5.3 Categorical Semantics 5.3.1 Circuit Monad with Effect Annotation. We refine the circuit monad from Section 3 by annotating it with effects. An established approach to giving a semantics of a type-and-effect system is to use graded monads [Katsumata 2014; Mellies 2012]. We follow this approach and refine the circuit monad as a category-graded monad [Orchard et al. 2020], which can be thought of as a many-sorted generalization of graded monads. Definition 9 (Cat-graded Monads [Orchard et al. 2020]). A (preorder enriched) category-graded monad (or an A-graded monad) on Set consists of a family of endofunctors T ğ‘“: Set â†’Set indexed by morphisms ğ‘“in A and families of natural transformations â€¢ ğœ‚ğ‘: IdSet â†’T idğ‘for ğ‘âˆˆObj(A), â€¢ ğœ‡ğ‘“,ğ‘”: T ğ‘“T ğ‘”â†’T ğ‘“;ğ‘”for ğ‘“: ğ‘â†’ğ‘and ğ‘”: ğ‘â†’ğ‘, â€¢ T ğ‘“â‰²ğ‘“â€² : T ğ‘“â†’T ğ‘“â€² for ğ‘“, ğ‘“â€² : ğ‘â†’ğ‘such that ğ‘“â‰²ğ‘“â€², 22 Ken Sakayori, Andrea Colledan, and Ugo Dal Lago satisfying the following unital and associativity laws. Tğ‘“ğœ‚ğ‘ ğœ‚ğ‘Tğ‘“ ğœ‡idğ‘,ğ‘“ ğœ‡ğ‘“,idğ‘ T ğ‘“ T idğ‘T ğ‘“ T ğ‘“T idğ‘ T ğ‘“ ğœ‡ğ‘“,ğ‘”Tâ„ Tğ‘“ğœ‡ğ‘”,â„ ğœ‡ğ‘“,ğ‘”;â„ ğœ‡ğ‘“;ğ‘”,â„ T ğ‘“T ğ‘”T â„ T ğ‘“Tğ‘”;â„ T ğ‘“;ğ‘”T â„ T ğ‘“;ğ‘”;â„ Moreover, we have the following commutativity concerning the preordering Tğ‘“â‰²ğ‘“ idTğ‘“ T ğ‘“ T ğ‘“ T ğ‘“ Tğ‘“â‰²ğ‘” Tğ‘“â‰²â„ Tğ‘”â‰²â„ T ğ‘“ T ğ‘” T â„ Tğ‘“â‰²ğ‘“â€² Tğ‘”â‰²ğ‘”â€² ğœ‡ğ‘“,ğ‘” ğœ‡ğ‘“â€²,ğ‘”â€² Tğ‘“;ğ‘”â‰²ğ‘“â€²;ğ‘”â€² T ğ‘“Tğ‘” T ğ‘“â€²Tğ‘”â€² T ğ‘“;ğ‘” T ğ‘“â€²;ğ‘”â€² â— We are interested in category-graded monads of a specific kind, namely those constructed from abstractions to circuit algebras. Given ğ›¼: M â†’E, we define an endofunctor on Set, parameterized by ğ‘’, by T ğ‘’ M(ğ‘‹) def= ğ‘‹Ã— Mâ‰²ğ‘’(ğ‘‡,ğ‘ˆ) where the set Mâ‰²ğ‘’(ğ‘‡,ğ‘ˆ) âŠ†M(ğ‘‡,ğ‘ˆ) is defined as {ğ¶âˆˆ M(ğ‘‡,ğ‘ˆ) | ğ›¼(ğ¶) â‰²ğ‘’}. This construction is reminiscent of graded monads arising from effect observations [Katsumata 2014].13 There is a caveat to this definition: this is not exactly an E-graded monad, as the grading is defined with respect to a slight modification of E. The annotation ğ‘’: t â†’u does not tell us the type of circuits, but only the type of circuits after the abstraction. To remedy the problem, for the category of grades, we use ËœE whose objects are those of M and whose homset ËœE(ğ‘‡,ğ‘ˆ) is defined as E(ğ›¼(ğ‘‡), ğ›¼(ğ‘ˆ)). We spell out the definition of the ËœE-graded monad constructed from abstraction to circuit algebra. As mentioned, the endofunctor T ğ‘’: ğ‘‡â†’ğ‘ˆ M acts on an object ğ‘‹as ğ‘‹Ã— Mâ‰²ğ‘’(ğ‘‡,ğ‘ˆ). The unit and multiplication are defined exactly the same way as in the (ordinary) circuit monad. That is, we have ğœ‚ğ‘‡,ğ‘‹(ğ‘¥) def= (ğ‘¥, idğ‘‡), ğœ‡ğ‘’1,ğ‘’2,ğ‘‹((ğ‘¥,ğ¶), ğ·) def= (ğ‘¥,ğ¶; ğ·). Note that the multiplication is well-defined because if ğ›¼(ğ¶) â‰²ğ‘’1 and ğ›¼(ğ·) â‰²ğ‘’2, we have ğ›¼(ğ¶; ğ·) = ğ›¼(ğ¶);ğ›¼(ğ·) â‰²ğ‘’1;ğ‘’2. Each component of the natural transformation TM ğ‘’1â‰²ğ‘’2 ğ‘‹ is the inclusion from ğ‘‹Ã— Mâ‰²ğ‘’1(ğ‘‡,ğ‘ˆ) to ğ‘‹Ã— Mâ‰²ğ‘’2(ğ‘‡,ğ‘ˆ). Moreover, the category-graded monad constructed this way, has premonoidal lifting as in the case for the ordinary circuit monad. For example, there is a natural transformation (ğ‘‡â‹Šâˆ’)â€  ğ‘’: ğ‘‡â†’ğ‘ˆ,ğ‘‹: T ğ‘’ Mğ‘‹â†’Tğ‘‡â‹Šğ‘’ M ğ‘‹that respects unit and the multiplication of the monad, which is defined as (ğ‘¥,ğ¶) â†¦â†’(ğ‘¥,ğ‘‡â‹Šğ¶) 5.3.2 Interpretation. The interpretation of types can be obtained by replacing M(ğ‘‡,ğ‘ˆ) with Mâ‰²ğ‘’(ğ‘‡,ğ‘ˆ). For example, we define JCircğ‘’: tâ†’u(ğ‘‡,ğ‘ˆ)Kğ‘ƒ def= Mâ‰²ğ‘’(Jğ‘‡KM, Jğ‘ˆKM) Jğ´ ğ‘’: uâ†’s âŠ¸ğ‘‡ ğµK def= (â™­Jğ´K â‡’Set â™­JğµK Ã— Mâ‰²ğ‘’(â™¯Jğ´K âŠ—Jğ‘‡KM, â™¯JğµK), Jğ‘‡KM). The first element of Jğ´ ğ‘’: uâ†’s âŠ¸ğ‘‡ ğµK can also be written as â™­Jğ´K â‡’Set T ğ‘’: â™¯Jğ´KâŠ—Jğ‘‡KMâ†’â™¯JğµK M (â™­JğµK). The interpretation of type !ğ‘’ğ´is similar to that of the function type. Note that we have an isomorphism 13Our recipe is different from Katsumataâ€™s in that (1) we deal with indexed monads rather than ordinary monads, and (2) it is tailored for a specific monad, i.e. category-action monads. On Circuit Description Languages, Indexed Monads, and Resource Analysis 23 â™­Jğ‘‡ ğ‘’âŠ¸ğ‘ˆK  JCircğ‘’(ğ‘‡,ğ‘ˆ)Kğ‘ƒas before.14 The rest of the types are interpreted as in the case of the simple type system. We now discuss how the judgments are interpreted. Computational judgments of the shape Î“ âŠ¢ğ‘ğ‘€: ğ´;ğ‘’are interpreted as morphisms Jğ‘€K: â™­JÎ“K â†’T ğ‘’: â™¯JÎ“Kâ†’â™¯Jğ´K M â™­Jğ´K in Set. Note that this is almost identical to the interpretation in the simple type system when the interpreted term is regarded as a morphism in Set. Although the interpretation of the simply typed terms were given as morphisms in the Kleisli category, we define the interpretation of terms typed in the type-and-effect system in Set. This is because the notion of Kleisli category for category-graded monads is tricky to define (see Remark 4 for a further discussion). The value judgments remain to be interpreted as morphisms in Set Ã— disc(Obj(M)). Let us look at the interpretation of return and let since they highlight the use of the monad. As usual, return is interpreted as the interpretation of a value post-composed with the unit. t Î“ âŠ¢ğ‘£ğ‘‰: ğ´ ğ›¼(â™¯Jğ´K) = t Î“ âŠ¢ğ‘return ğ‘‰: ğ´; idt : t â†’t | def= â™­JÎ“ âŠ¢ğ‘£ğ‘‰: ğ´K;ğœ‚â™¯Jğ´K The interpretation of let is essentially the same as how composition is defined in the Kleisli category of a (standard) monad: u v Î¦, Î“1 âŠ¢ğ‘ğ‘€: ğ´;ğ‘’1 : t1 â†’tâ€² 1 Î¦, Î“2,ğ‘¥: ğ´âŠ¢ğ‘ğ‘: ğµ;ğ‘’2 : t2 â†’tâ€² 2 Jâ™¯Î“ğ‘–K â–·uğ‘– ğ‘’= (idu2 â‹Šğ‘’1);ğ‘’2 Î¦, Î“2, Î“1 âŠ¢ğ‘let ğ‘¥= ğ‘€in ğ‘: ğµ;ğ‘’ } ~ is given as JÎ¦K Ã— â™­JÎ“2K Ã— â™­JÎ“1K Î”Ã—id; âˆ’âˆ’âˆ’âˆ’âˆ’â†’JÎ¦K Ã— â™­JÎ“2K Ã— JÎ¦K Ã— â™­JÎ“1K idÃ—ğœ‚u2 Ã—Jğ‘€K âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’JÎ¦K Ã— T idu2 M â™­JÎ“2K Ã— T ğ‘’1 M â™­Jğ´K idÃ—<âƒ;ğœ âˆ’âˆ’âˆ’âˆ’âˆ’â†’T idâ‹Šğ‘’1 M (JÎ¦K Ã— â™­JÎ“2K Ã— â™­Jğ´K) Tidâ‹Šğ‘’1 M Jğ‘K âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’T idâ‹Šğ‘’1 M (T ğ‘’2 M (â™­JğµK)) ğœ‡idâ‹Šğ‘’1,ğ‘’2 âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’T (idâ‹Šğ‘’1);ğ‘’2 M (â™­JğµK). The morphism ğœis the strength (which can be defined in a straightforward way), and <âƒğ‘‡1,ğ‘ˆ1,ğ‘‡2,ğ‘ˆ2 is the morphism15 <âƒ: T ğ‘’1 : ğ‘‡1â†’ğ‘ˆ1 M ğ‘‹Ã— T ğ‘’2 : ğ‘‡2â†’ğ‘ˆ2 M ğ‘Œâ†’T (idâ‹Šğ‘’1);(ğ‘’2â‹‰id) M (ğ‘‹Ã— ğ‘Œ) ((ğ‘¥,ğ¶), (ğ‘¦, ğ·)) â†¦â†’((ğ‘¥,ğ‘¦), (ğ‘‡2 â‹Šğ¶); (ğ·â‹‰ğ‘ˆ1)). Intuitively, <âƒpairs ğ‘¥,ğ‘¦and, at the same time, â€œparallelly composesâ€ ğ¶and ğ·in the order ğ¶first followed by ğ·. In the interpretation of let, it is simply used to parallelly augment wires of the type â™¯JÎ“2K to the circuit generated by ğ‘€. The interpretation for the other constructs is also essentially unchanged from the interpretation in Figure 6. A minor difference is that instead of using the functor ğ½to map value morphisms into 14By abuse of notation, we also denote this isomorphism as box. 15Aside from this elementary definition, <âƒcan be defined using liftings of id â‹Šâˆ’and âˆ’â‹‰id, and the strength and multiplication of the cat-graded monad. 24 Ken Sakayori, Andrea Colledan, and Ugo Dal Lago the category of computations, we use ğœ‚as we did for the interpretation of return ğ‘‰. For example, we have JÎ¦ âŠ¢ğ‘boxğ‘‡ğ‘‰: Circğ‘’: tâ†’u(ğ‘‡,ğ‘ˆ);ğœ€K def= â™­JÎ¦ âŠ¢ğ‘£ğ‘‰: ğ‘‡ ğ‘’: tâ†’u âŠ¸ğ¼ ğ‘ˆK; box;ğœ‚ğ¼,Circğ‘’(ğ‘‡,ğ‘ˆ). The subsumption rule is interpreted by postcomposing the component of the natural transformation T ğ‘’1â‰²ğ‘’2 M at Jğ´K. (See Appendix B for the interpretaion of the other constructs.) Remark 4. While we used (parameterized) Freyd category in Section 3, in this section, we had to define the interpretation explicitly using the structures of monads. Freyd categories have a better match with the fine-grained call-by-value calculus that Proto-Quipper-R is based on. The difficulty lies in defining a suitable notion of â€œlocally graded categoryâ€ [Levy 2019; Wood 1978] for category graded monads. A locally graded category is a category-like structure whose homsets are indexed by grades (i.e. elements of a preordered monoid), and this is central to the definition of graded Freyd categories [Gaboardi et al. 2021]. Naively, we may define a category like structure in which homsets are indexed by morphisms, but determining the laws such a structure should satisfy seems non trivial and is left for future work. â— 5.4 Correctness Analogous to the case of simple types, the semantics is sound and adequate. Interpretation of configurations are defined as in Section 3 by considering ğ½as a map that associates (ğ‘“,ğ¶) âˆˆ (Set Ã— M)((ğ‘‹,ğ‘‡), (ğ‘Œ,ğ‘ˆ)) to a morphism from ğ‘‹to ğ‘ŒÃ— Mâ‰²ğ›¼(ğ¶) (ğ‘‡,ğ‘ˆ) in Set. Theorem 10 (Soundness). Suppose that ğ‘„âŠ¢(ğ¶, ğ‘€) : ğ´;ğ‘„â€²;ğ‘’: t â†’u and (ğ¶, ğ‘€) â‡“(ğ¶â€²,ğ‘‰). Then J(ğ¶, ğ‘€)K = ğ½(J(ğ¶â€²,ğ‘‰)K). â–¡ Theorem 11 (Computational adequacy). Suppose that âˆ…âŠ¢(ğ¶, ğ‘€) : 1; âˆ…;ğ‘’: t â†’i and J(ğ¶, ğ‘€)K = ğ½(J(ğ·,ğ‘‰)K). Then (ğ¶, ğ‘€) â‡“(ğ·,ğ‘‰) (possibly up to renaming of labels). Moreover, there must exist a circuit ğ¸such that ğ›¼(ğ¸) â‰²ğ‘’and ğ¶; ğ¸= ğ·. â–¡ 6 Discussion: Dependent Types One feature that some of the languages of the Proto-Quipper family have is a form of dependent types [Colledan and Dal Lago 2024, 2025; Fu et al. 2020, 2022a]. Dependent types are useful in the context of quantum circuit programming because one can express, at the level of types, the number of qubits a function takes as input. For example, a function implementing the so-called Quantum Fourier Transform has the type qft : Ã(ğ‘›: Nat), Vec Qubit ğ‘›âŠ¸Vec Qubit ğ‘›. We briefly discuss the possibility of adding dependent types to the languages and models from the previous sections. The denotational model given in Section 3 can be straightforwardly extended to support some dependent types. We can apply the families construction as shown in Figure 10. Since ordinary adjunctions lift to fibered adjunctions over Set by a pointwise definition, this construction gives an instance of a parameterized version of the fibered adjunction models [Ahman et al. 2016]. Fibered adjunction models are models for a language with dependent types and computational effects. On the syntax side, this means allowing dependent types with â€œvalue restrictionâ€: types can only depend on values with parameter type, which correspond to morphisms in Set. Although such a type system is less expressive compared to the type system of Proto-Quipper-D [Fu et al. 2022a] that allows types to depend on (the shape of) terms with quantum data types, it is expressive enough to express the type for qft we described above. What is more challenging is to model effect annotations that are dependent on terms. Colledan and Dal Lago [2024, 2025] considered a type system in which the function qft has the type qft : Ã(ğ‘›: Nat), Vec Qubit ğ‘› ğ‘›: ğ‘›â†’ğ‘› âŠ¸ Vec Qubit ğ‘›, where the ğ‘›over the arrow is the effect annotation On Circuit Description Languages, Indexed Monads, and Resource Analysis 25 ğ½ ğ‘ {âˆ’} 1 âŠ£ âŠ£ Fam(Set Ã— M) Fam(SetT) Fam(Set) Set Fig. 10. Model for the dependently typed Proto-Quipper-R. The functors 1 and {âˆ’} are the terminal object functor and the comprehension functor, respectively. expressing the estimated width of the circuit qft generates.16 Their syntax forces annotations to be arithmetic terms depending on arithmetic variables so that type inference based on SMT-solving can semi-automatically infer the effect information. If we are only interested in annotations that are arithmetic expressions, then it seems possible to write out the interpretation just by indexing the interpretation we described in Section 5 with (tuples of) natural numbers. However, it is not clear (a) to what extent the effect annotations can be generalized and (b) whether there is a categorical explanation (e.g. an explanation in the form of some generalization of fibered monads) that captures the nature of the interpretation. Further investigation is left for future work. 7 Related Work Giving a denotational semantics to quantum programming languages has generally been more challenging than the corresponding problem for classical languages. Even in the case of imperative QRAM languages, this task is not so simple, given that quantum data can be interpreted by semantic domains which are different from the usual ones, see [Ying 2016] for an overview. When, in addition to a quantum store, the underlying language is also endowed with higher- order functions, the task becomes even more complicated. A few years after the quantum ğœ†- calculus [Selinger and Valiron 2005] was introduced, a fully abstract model for the linear fragment of the quantum ğœ†-calculus was given by using the category CPM of completely positive maps [Selinger and Valiron 2008]. However, designing a model of (variants of) the full quantum ğœ†-calculus remained a challenge. One difficulty is the tension between the finite and the infinite. The category CPM or its subcategory Q of trace-preserving completely positive maps are inherently finite since their definition relies on finite Hilbert spaces, whereas quantum ğœ†-calculus comes with infinite features such as the ! modality or term level recursion. To overcome this difficulty, various approaches have been studied. These include (but are not limited to) studies based on presheaves [Malherbe et al. 2013], (Î£-monoid) enriched presheaves [Tsukada and Asada 2024], quantitative semantics of linear logic [Pagani et al. 2014], operator algbra [Cho and Westerbaan 2016], geometry of interaction [Hasuo and Hoshino 2017; Yoshimizu et al. 2014] and game semantics [Clairambault and de Visme 2020; Clairambault et al. 2019]. The first four approaches can be considered as taking a certain â€œcompletionâ€ of CPM or Q to support higher-order and infinite types. The latter two approaches are more operational, since they are based on interactive semantics. We note that some of these [Clairambault and de Visme 2020; Pagani et al. 2014; Tsukada and Asada 2024] are fully abstract models of the full quantum ğœ†-calculus. In CDLs, the types of problems encountered in giving a denotational semantics are different. On the one hand, a semantics of CDL needs to cope with the distinction between circuit generation time and circuit execution time that does not exist in languages such as the quantum ğœ†-calculus. Moreover, 16The syntax we are using here is not exactly the syntax used in [Colledan and Dal Lago 2024, 2025] 26 Ken Sakayori, Andrea Colledan, and Ugo Dal Lago circuits can, like in Quipper, support specific operators which do not exist for other data structures and which allow programs to be interpreted as circuits e.g., Quipperâ€™s box operator. On the other hand, giving denotational semantics to CDLs is somehow easier because the characteristics of quantum circuits, say, compared to Boolean circuits, are abstracted away. This simplicity, however, no longer holds if the CDL allows an interplay between the host and the circuit level language, known as dynamic lifting. As already mentioned, since the introduction of the Proto-Quipper family with Proto-Quipper-S and Proto-Quipper-M, a presheaf-based denotational semantics has been known to be adequate [Lin- denhovius et al. 2018; Rios and Selinger 2017]. Later, extensions of the language with dependent types [Fu et al. 2022a] and dynamic lifting [Fu et al. 2022b, 2023] have been considered. The model for dependent types uses the families construction as discussed in Section 6. At a superficial level, the model for dynamic lifting also shares an idea with the semantics we introduced in Section 5. Both models hold a morphism representing a quantum circuit and a morphism representing its interpretation, either as a quantum operation or effect annotation. However, the foundations of these models remain fundamentally unaltered in that they use presheaves, and further comparison with our models is left for future work. It should be noted that the members of the Proto-Quipper family intended for the analysis of circuit size, like Proto-Quipper-R [Colledan and Dal Lago 2024], lack a denotational account, although being solidly grounded from an operational point of view. We believe this to be a result of the intrinsic difficulty of reflecting intensional properties of the underlying circuit in the aforementioned presheaf-based semantics. Another commonly used type of CDLs, aside from the Proto-Quipper family, consists of those with a clear stratification between classical and quantum layers. QWire [Paykin et al. 2017] and EWire [Rennela and Staton 2020] are languages that have a dedicated language for circuits with a linear type system that can be embedded into a non-linear host language. On the semantic side, this embedding has been nicely captured using enriched category theory [Rennela and Staton 2020]. VQPL [Jia et al. 2022] is another quantum programming language with two subcalculi, one for classical programs and the other for quantum programs, where the quantum programs are more high-level than mere circuits. They support rich features such as classical recursive types, inductive quantum types and dynamic lifting. Furthermore, VQPL has an adequate denotational model that unites domain-theoretic models of classical programming and von Neumann algebras for quantum interpretation. Overall, these languages cannot have data structures with both quantum data and classical data, unlike languages in the Proto-Quipper family. While our semantics also has a clear separation between Set and the category of circuits, our languages allow mixing classical types and quantum types. Our key observation here is that the introduction of the closure types allows us to decompose these mixed types into classical and quantum parts. Since the pioneering works of Moggi [1989, 1991] it can certainly be said that the concept of a monad is one of the most powerful mathematical constructions in giving meaning to compu- tational effects. Various generalizations on plain monads, such as indexed (aka parameterized) monads [Atkey 2009], graded monads [Katsumata 2014; Mellies 2012] or category-graded mon- ads [Orchard et al. 2020] have been proposed in the literature. The circuit monads in Section 4 and Section 5 can be seen as an instance of an indexed monad and category-graded monads, re- spectively. Defining effect annotations as abstractions of computational effects is a general idea that could be applied to other things besides circuits. Identifying the essences of the construction in Section 5 and deriving a recipe to construct category-graded monad might be of independent interest. Additionally, as discussed in Remark 4, a â€œFreyd categoryâ€ for category-graded monads appears to be absent from the literature and is worth investigating further. The literature, by the way, offers some examples of circuit monads [Elliott 2013; Valiron 2016], none of which has been applied to languages in the Proto-Quipper family. On Circuit Description Languages, Indexed Monads, and Resource Analysis 27 8 Conclusion In this work, we introduce a monadic denotational semantic model for circuit description languages in which the role of the monad is played by a circuit construction. This way, the structure of the produced circuit can be observed as an effect, making the model potentially capable of reflecting intensional features of circuits produced by terms of any type. This allows us to give semantics to members of the Proto-Quipper family for which a denotational account is not, to the authorsâ€™ knowledge, known. Remarkably, by considering an abstract notion of circuit algebra, different notions of circuit metrics are treated uniformly, including simple forms of circuit optimization; we believe that this abstraction may help reveal further concrete circuit metrics. Among the future developments of this work, we must certainly mention the study of denotational semantic models for Proto-Quipper-RA, a recently introduced member of the Proto-Quipper family able to support the analysis of a wide range of circuit metrics via types. Some of its features, such as effect and dependent typing, have already been treated separately (see Sections 5 and 6), but the study of their combination in the same semantic framework is left to future work. Although our work primarily focuses on denotational semantics, it is natural to consider implementing the type system described in Section 5, e.g., by adapting or extending the QuRA tool [Colledan and Dal Lago 2025]. While supporting the circuit algebra examples discussed in this paper should not pose major technical challenges, aspects such as efficient automatic type inference merit further investigation. We plan to explore these directions in future work. We would also like to extend the language and the model with features of Quipper that we did not cover in this paper such as term and type level recursion and dynamic lifting. Acknowledgments The research leading to these results has received funding from the MUR grant PRIN 2022 PNRR No. P2022HXNSC - â€œResource Awareness in Programmingâ€ and European Union - NextGenera- tionEU through the Italian Ministry of University and Research under PNRR - M4C2 - I1.4 Project CN00000013 â€œNational Centre for HPC, Big Data and Quantum Computingâ€. References Danel Ahman, Neil Ghani, and Gordon D. Plotkin. 2016. Dependent Types and Fibred Computational Effects. In Foundations of Software Science and Computation Structures - 19th International Conference, FOSSACS 2016, Held as Part of the European Joint Conferences on Theory and Practice of Software, ETAPS 2016, Eindhoven, The Netherlands, April 2-8, 2016, Proceedings (Lecture Notes in Computer Science, Vol. 9634), Bart Jacobs and Christof LÃ¶ding (Eds.). Springer, 36â€“54. doi:10.1007/978-3-662-49630-5_3 Matthew Amy. 2019. Sized Types for Low-Level Quantum Metaprogramming. In Reversible Computation - 11th International Conference, RC 2019, Lausanne, Switzerland, June 24-25, 2019, Proceedings (Lecture Notes in Computer Science, Vol. 11497), Michael Kirkedal Thomsen and Mathias Soeken (Eds.). Springer, 87â€“107. doi:10.1007/978-3-030-21500-2_6 Robert Atkey. 2009. Parameterised notions of computation. J. Funct. Program. 19, 3-4 (2009), 335â€“376. doi:10.1017/ S095679680900728X P. N. Benton. 1994. A Mixed Linear and Non-Linear Logic: Proofs, Terms and Models (Extended Abstract). In Computer Science Logic, 8th International Workshop, CSL â€™94, Kazimierz, Poland, September 25-30, 1994, Selected Papers (Lecture Notes in Computer Science, Vol. 933), Leszek Pacholski and Jerzy Tiuryn (Eds.). Springer, 121â€“135. doi:10.1007/BFB0022251 S. Bettelli, T. Calarco, and L. Serafini. 2003. Toward an architecture for quantum programming. The European Physical Journal D - Atomic, Molecular and Optical Physics 25, 2 (Aug. 2003), 181â€“200. doi:10.1140/epjd/e2003-00242-2 Kenta Cho and Abraham Westerbaan. 2016. Von Neumann Algebras form a Model for the Quantum Lambda Calculus. CoRR abs/1603.02133 (2016). arXiv:1603.02133 http://arxiv.org/abs/1603.02133 Pierre Clairambault and Marc de Visme. 2020. Full abstraction for the quantum lambda-calculus. Proc. ACM Program. Lang. 4, POPL (2020), 63:1â€“63:28. doi:10.1145/3371131 Pierre Clairambault, Marc de Visme, and Glynn Winskel. 2019. Game semantics for quantum programming. Proc. ACM Program. Lang. 3, POPL (2019), 32:1â€“32:29. doi:10.1145/3290345 28 Ken Sakayori, Andrea Colledan, and Ugo Dal Lago Andrea Colledan and Ugo Dal Lago. 2023. On Dynamic Lifting and Effect Typing in Circuit Description Languages. In 28th International Conference on Types for Proofs and Programs (TYPES 2022) (Leibniz International Proceedings in Informatics (LIPIcs), Vol. 269), Delia Kesner and Pierre-Marie PÃ©drot (Eds.). Schloss Dagstuhl â€“ Leibniz-Zentrum fÃ¼r Informatik, Dagstuhl, Germany, 3:1â€“3:21. doi:10.4230/LIPIcs.TYPES.2022.3 Andrea Colledan and Ugo Dal Lago. 2024. Circuit Width Estimation via Effect Typing and Linear Dependency. In Programming Languages and Systems - 33rd European Symposium on Programming, ESOP 2024, Held as Part of the European Joint Conferences on Theory and Practice of Software, ETAPS 2024, Luxembourg City, Luxembourg, April 6-11, 2024, Proceedings, Part II (Lecture Notes in Computer Science, Vol. 14577), Stephanie Weirich (Ed.). Springer, 3â€“30. doi:10.1007/978-3-031- 57267-8_1 Andrea Colledan and Ugo Dal Lago. 2025. Flexible Type-Based Resource Estimation in Quantum Circuit Description Languages. Proc. ACM Program. Lang. 9, POPL, Article 47 (Jan. 2025), 31 pages. doi:10.1145/3704883 Cirq Developers. 2025. Cirq. doi:10.5281/zenodo.15191735 Conal Elliott. 2013. Circuits as a bicartesian closed category. http://conal.net/blog/posts/circuits-as-a-bicartesian-closed- category. Blog post, Accessed: 2025-01-23. Peng Fu, Kohei Kishida, Neil J. Ross, and Peter Selinger. 2020. A Tutorial Introduction to Quantum Circuit Programming in Dependently Typed Proto-Quipper. In Reversible Computation - 12th International Conference, RC 2020, Oslo, Norway, July 9-10, 2020, Proceedings (Lecture Notes in Computer Science, Vol. 12227), Ivan Lanese and Mariusz Rawski (Eds.). Springer, 153â€“168. doi:10.1007/978-3-030-52482-1_9 Peng Fu, Kohei Kishida, Neil J. Ross, and Peter Selinger. 2022b. A biset-enriched categorical model for Proto-Quipper with dynamic lifting. In Proceedings 19th International Conference on Quantum Physics and Logic, QPL 2022, Wolfson College, Oxford, UK, 27 June - 1 July 2022 (EPTCS, Vol. 394), Stefano Gogioso and Matty Hoban (Eds.). 302â€“342. doi:10.4204/EPTCS. 394.16 Peng Fu, Kohei Kishida, Neil J. Ross, and Peter Selinger. 2023. Proto-Quipper with Dynamic Lifting. Proc. ACM Program. Lang. 7, POPL (2023), 309â€“334. doi:10.1145/3571204 Peng Fu, Kohei Kishida, and Peter Selinger. 2022a. Linear Dependent Type Theory for Quantum Programming Languages. Log. Methods Comput. Sci. 18, 3 (2022). doi:10.46298/LMCS-18(3:28)2022 Marco Gaboardi, Shin-ya Katsumata, Dominic Orchard, and Tetsuya Sato. 2021. Graded Hoare Logic and its Categorical Semantics. In Programming Languages and Systems - 30th European Symposium on Programming, ESOP 2021, Held as Part of the European Joint Conferences on Theory and Practice of Software, ETAPS 2021, Luxembourg City, Luxembourg, March 27 - April 1, 2021, Proceedings (Lecture Notes in Computer Science, Vol. 12648), Nobuko Yoshida (Ed.). Springer, 234â€“263. doi:10.1007/978-3-030-72019-3_9 Alexander S. Green, Peter LeFanu Lumsdaine, Neil J. Ross, Peter Selinger, and BenoÃ®t Valiron. 2013. Quipper: a scalable quantum programming language. In ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI â€™13, Seattle, WA, USA, June 16-19, 2013, Hans-Juergen Boehm and Cormac Flanagan (Eds.). ACM, 333â€“342. doi:10. 1145/2491956.2462177 Thomas HÃ¤ner, Torsten Hoefler, and Matthias Troyer. 2020. Assertion-based optimization of Quantum programs. Proc. ACM Program. Lang. 4, OOPSLA (2020), 133:1â€“133:20. doi:10.1145/3428201 Ichiro Hasuo and Naohiko Hoshino. 2017. Semantics of higher-order quantum computation via geometry of interaction. Ann. Pure Appl. Log. 168, 2 (2017), 404â€“469. doi:10.1016/J.APAL.2016.10.010 Ali Javadi-Abhari, Matthew Treinish, Kevin Krsulich, Christopher J. Wood, Jake Lishman, Julien Gacon, Simon Martiel, Paul D. Nation, Lev S. Bishop, Andrew W. Cross, Blake R. Johnson, and Jay M. Gambetta. 2024. Quantum computing with Qiskit. arXiv:2405.08810 [quant-ph] https://arxiv.org/abs/2405.08810 Xiaodong Jia, Andre Kornell, Bert Lindenhovius, Michael W. Mislove, and Vladimir Zamdzhiev. 2022. Semantics for variational Quantum programming. Proc. ACM Program. Lang. 6, POPL (2022), 1â€“31. doi:10.1145/3498687 Hanru Jiang. 2024. Qubit Recycling Revisited. Proc. ACM Program. Lang. 8, PLDI (2024), 1264â€“1287. doi:10.1145/3656428 AndrÃ© Joyal and Ross Street. 1991. The geometry of tensor calculus, I. Advances in Mathematics 88, 1 (1991), 55â€“112. doi:10.1016/0001-8708(91)90003-P Shin-ya Katsumata. 2014. Parametric effect monads and semantics of effect systems. In The 41st Annual ACM SIGPLAN- SIGACT Symposium on Principles of Programming Languages, POPL â€™14, San Diego, CA, USA, January 20-21, 2014, Suresh Jagannathan and Peter Sewell (Eds.). ACM, 633â€“646. doi:10.1145/2535838.2535846 E. Knill. 2022. Conventions for Quantum Pseudocode. arXiv:2211.02559 [quant-ph] https://arxiv.org/abs/2211.02559 [A version of LANL report LAUR-96-2724 (1996) with a modern formatting]. Paul Blain Levy. 2019. Locally graded categories. https://pblevy.github.io/papers/locgrade.pdf. Talk slides. Paul Blain Levy, John Power, and Hayo Thielecke. 2003. Modelling environments in call-by-value programming languages. Inf. Comput. 185, 2 (2003), 182â€“210. doi:10.1016/S0890-5401(03)00088-9 Bert Lindenhovius, Michael W. Mislove, and Vladimir Zamdzhiev. 2018. Enriching a Linear/Non-linear Lambda Calculus: A Programming Language for String Diagrams. In Proceedings of the 33rd Annual ACM/IEEE Symposium on Logic On Circuit Description Languages, Indexed Monads, and Resource Analysis 29 in Computer Science, LICS 2018, Oxford, UK, July 09-12, 2018, Anuj Dawar and Erich GrÃ¤del (Eds.). ACM, 659â€“668. doi:10.1145/3209108.3209196 Junyi Liu, Bohua Zhan, Shuling Wang, Shenggang Ying, Tao Liu, Yangjia Li, Mingsheng Ying, and Naijun Zhan. 2019. Quantum Hoare Logic. Arch. Formal Proofs 2019 (2019). https://www.isa-afp.org/entries/QHLProver.html Octavio Malherbe, Philip J. Scott, and Peter Selinger. 2013. Presheaf Models of Quantum Computation: An Outline. In Computation, Logic, Games, and Quantum Foundations. The Many Facets of Samson Abramsky - Essays Dedicated to Samson Abramsky on the Occasion of His 60th Birthday (Lecture Notes in Computer Science, Vol. 7860), Bob Coecke, Luke Ong, and Prakash Panangaden (Eds.). Springer, 178â€“194. doi:10.1007/978-3-642-38164-5_13 Paul-AndrÃ© Mellies. 2012. Parametric monads and enriched adjunctions. https://www.irif.fr/~mellies/tensorial-logic/8- parametric-monads-and-enriched-adjunctions.pdf. Preprint. Eugenio Moggi. 1989. Computational Lambda-Calculus and Monads. In Proceedings of the Fourth Annual Symposium on Logic in Computer Science (LICS â€™89), Pacific Grove, California, USA, June 5-8, 1989. IEEE Computer Society, 14â€“23. doi:10.1109/LICS.1989.39155 Eugenio Moggi. 1991. Notions of Computation and Monads. Inf. Comput. 93, 1 (1991), 55â€“92. doi:10.1016/0890-5401(91)90052- 4 Dominic Orchard, Philip Wadler, and Harley Eades III. 2020. Unifying graded and parameterised monads. In Proceedings Eighth Workshop on Mathematically Structured Functional Programming, MSFP@ETAPS 2020, Dublin, Ireland, 25th April 2020 (EPTCS, Vol. 317), Max S. New and Sam Lindley (Eds.). 18â€“38. doi:10.4204/EPTCS.317.2 Michele Pagani, Peter Selinger, and BenoÃ®t Valiron. 2014. Applying quantitative semantics to higher-order quantum computing. In The 41st Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL â€™14, San Diego, CA, USA, January 20-21, 2014, Suresh Jagannathan and Peter Sewell (Eds.). ACM, 647â€“658. doi:10.1145/2535838. 2535879 Jennifer Paykin, Robert Rand, and Steve Zdancewic. 2017. QWIRE: a core language for quantum circuits. In Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages, POPL 2017, Paris, France, January 18-20, 2017, Giuseppe Castagna and Andrew D. Gordon (Eds.). ACM, 846â€“858. doi:10.1145/3009837.3009894 Simon Perdrix. 2008. Quantum Entanglement Analysis Based on Abstract Interpretation. In Static Analysis, 15th International Symposium, SAS 2008, Valencia, Spain, July 16-18, 2008. Proceedings (Lecture Notes in Computer Science, Vol. 5079), MarÃ­a Alpuente and GermÃ¡n Vidal (Eds.). Springer, 270â€“282. doi:10.1007/978-3-540-69166-2_18 John Power and Edmund Robinson. 1997. Premonoidal Categories and Notions of Computation. Math. Struct. Comput. Sci. 7, 5 (1997), 453â€“468. doi:10.1017/S0960129597002375 Qiskit API reference. 2025. HoareOptimizer. https://quantum.cloud.ibm.com/docs/en/api/qiskit/qiskit.transpiler.passes. HoareOptimizer. Accessed: 2025-07-10. Mathys Rennela and Sam Staton. 2020. Classical Control, Quantum Circuits and Linear Logic in Enriched Category Theory. Log. Methods Comput. Sci. 16, 1 (2020). doi:10.23638/LMCS-16(1:30)2020 Francisco Rios and Peter Selinger. 2017. A categorical model for a quantum circuit description language. In Proceedings 14th International Conference on Quantum Physics and Logic, QPL 2017, Nijmegen, The Netherlands, 3-7 July 2017 (EPTCS, Vol. 266), Bob Coecke and Aleks Kissinger (Eds.). 164â€“178. doi:10.4204/EPTCS.266.11 Mario RomÃ¡n and PaweÅ‚ SobociÅ„ski. 2025. String Diagrams for Premonoidal Categories. Logical Methods in Computer Science Volume 21, Issue 2, Article 9 (Apr 2025). doi:10.46298/lmcs-21(2:9)2025 J. W. Sanders and P. Zuliani. 2000. Quantum Programming. In Mathematics of Program Construction, Roland Backhouse and JosÃ© Nuno Oliveira (Eds.). Springer Berlin Heidelberg, Berlin, Heidelberg, 80â€“99. Peter Selinger. 2004. Towards a quantum programming language. Mathematical. Structures in Comp. Sci. 14, 4 (Aug. 2004), 527â€“586. doi:10.1017/S0960129504004256 Peter Selinger and BenoÃ®t Valiron. 2005. A Lambda Calculus for Quantum Computation with Classical Control. In Typed Lambda Calculi and Applications, PaweÅ‚ Urzyczyn (Ed.). Springer Berlin Heidelberg, Berlin, Heidelberg, 354â€“368. Peter Selinger and BenoÃ®t Valiron. 2008. On a Fully Abstract Model for a Quantum Linear Functional Language: (Extended Abstract). In Proceedings of the 4th International Workshop on Quantum Programming Languages, QPL 2006, Oxford, UK, July 17-19, 2006 (Electronic Notes in Theoretical Computer Science, Vol. 210), Peter Selinger (Ed.). Elsevier, 123â€“137. doi:10.1016/J.ENTCS.2008.04.022 Peter W. Shor. 1994. Algorithms for Quantum Computation: Discrete Logarithms and Factoring. In 35th Annual Symposium on Foundations of Computer Science, Santa Fe, New Mexico, USA, 20-22 November 1994. IEEE Computer Society, 124â€“134. doi:10.1109/SFCS.1994.365700 Sam Staton and Paul Blain Levy. 2013. Universal properties of impure programming languages. In The 40th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL â€™13, Rome, Italy - January 23 - 25, 2013, Roberto Giacobazzi and Radhia Cousot (Eds.). ACM, 179â€“192. doi:10.1145/2429069.2429091 Krysta Svore, Alan Geller, Matthias Troyer, John Azariah, Christopher Granade, Bettina Heim, Vadym Kliuchnikov, Mariia Mykhailova, Andres Paz, and Martin Roetteler. 2018. Q#: Enabling Scalable Quantum Computing and Development 30 Ken Sakayori, Andrea Colledan, and Ugo Dal Lago with a High-level DSL. In Proceedings of the Real World Domain Specific Languages Workshop 2018 (RWDSL2018). ACM. doi:10.1145/3183895.3183901 Takeshi Tsukada and Kazuyuki Asada. 2024. Enriched Presheaf Model of Quantum FPC. Proc. ACM Program. Lang. 8, POPL (2024), 362â€“392. doi:10.1145/3632855 BenoÃ®t Valiron. 2016. Generating Reversible Circuits from Higher-Order Functional Programs. In Reversible Computation - 8th International Conference, RC 2016, Bologna, Italy, July 7-8, 2016, Proceedings (Lecture Notes in Computer Science, Vol. 9720), Simon J. Devitt and Ivan Lanese (Eds.). Springer, 289â€“306. doi:10.1007/978-3-319-40578-0_21 R. J. Wood. 1978. V-indexed categories. In Indexed Categories and Their Applications. Springer Berlin Heidelberg, Berlin, Heidelberg, 126â€“140. Mingsheng Ying. 2016. Foundations of Quantum Programming (1st ed.). Morgan Kaufmann Publishers Inc., San Francisco, CA, USA. Mingsheng Ying, Shenggang Ying, and Xiaodi Wu. 2017. Invariants of quantum programs: characterisations and generation. In Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages, POPL 2017, Paris, France, January 18-20, 2017, Giuseppe Castagna and Andrew D. Gordon (Eds.). ACM, 818â€“832. doi:10.1145/3009837.3009840 Akira Yoshimizu, Ichiro Hasuo, Claudia Faggian, and Ugo Dal Lago. 2014. Measurements in Proof Nets as Higher-Order Quantum Circuits. In Programming Languages and Systems - 23rd European Symposium on Programming, ESOP 2014, Held as Part of the European Joint Conferences on Theory and Practice of Software, ETAPS 2014, Grenoble, France, April 5-13, 2014, Proceedings (Lecture Notes in Computer Science, Vol. 8410), Zhong Shao (Ed.). Springer, 371â€“391. doi:10.1007/978-3-642- 54833-8_20 Nengkun Yu and Jens Palsberg. 2021. Quantum abstract interpretation. In PLDI â€™21: 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation, Virtual Event, Canada, June 20-25, 2021, Stephen N. Freund and Eran Yahav (Eds.). ACM, 542â€“558. doi:10.1145/3453483.3454061 Li Zhou, Nengkun Yu, and Mingsheng Ying. 2019. An applied quantum Hoare logic. In Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI 2019, Phoenix, AZ, USA, June 22-26, 2019, Kathryn S. McKinley and Kathleen Fisher (Eds.). ACM, 1149â€“1162. doi:10.1145/3314221.3314584 On Circuit Description Languages, Indexed Monads, and Resource Analysis 31 A Soundness & Adequacy We prove the soundness and the computational adequacy of the interpretation given in Section 3. The soundness and the adequacy for the interpretation given in Section 5 can be shown by almost the same argument (and thus we do not repeat the argument). A.1 Soundness As usual, the soundness is proved by induction on the derivation of the evaluation relation. The proof also uses the following standard substitution lemma. Lemma 3 (Substitution). Suppose that Î¦, Î“1 âŠ¢ğ‘£ğ‘‰: ğ´. (1) If Î¦, Î“2,ğ‘¥: ğ´, Î“â€² 2 âŠ¢ğ‘£ğ‘Š: ğµ, then JÎ¦, Î“2, Î“1, Î“â€² 2 âŠ¢ğ‘£ğ‘Š[ğ‘‰/ğ‘¥] : ğµK = JÎ¦K âŠ—JÎ“2K âŠ—JÎ“1K âŠ—JÎ“â€² 2K (Î”,id)âŠ—id âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ JÎ¦K âŠ—JÎ¦K âŠ—JÎ“2K âŠ—JÎ“1K âŠ—JÎ“â€² 2K âˆ’â†’ JÎ¦K âŠ—JÎ“2K âŠ—JÎ¦K âŠ—JÎ“1K âŠ—JÎ“â€² 2K idâŠ—Jğ‘‰KâŠ—id âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ JÎ¦K âŠ—JÎ“2K âŠ—Jğ´K âŠ—JÎ“â€² 2K Jğ‘ŠK âˆ’âˆ’âˆ’â†’JğµK. (2) If Î¦, Î“,ğ‘¥: ğ´âŠ¢ğ‘ğ‘€: ğµ, then JÎ¦, Î“, Î“1 âŠ¢ğ‘£ğ‘€[ğ‘‰/ğ‘¥] : ğµK = JÎ¦K âŠ—JÎ“K âŠ—JÎ“1K dupâŠ—id âˆ’âˆ’âˆ’âˆ’âˆ’â†’ JÎ¦K âŠ—JÎ¦K âŠ—JÎ“K âŠ—JÎ“1K âˆ’â†’ JÎ¦K âŠ—JÎ“K âŠ—JÎ¦K âŠ—JÎ“1K idâŠ—ğ½(Jğ‘‰K) âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ JÎ¦K âŠ—JÎ“K âŠ—Jğ´K Jğ‘€K âˆ’âˆ’âˆ’â†’JğµK. Proof. By a simultaneous induction on the structure of the type derivation. â–¡ Theorem 5 (Soundness). Suppose that ğ‘„âŠ¢(ğ¶, ğ‘€) : ğ´;ğ‘„â€² and (ğ¶, ğ‘€) â‡“(ğ¶â€²,ğ‘‰). Then J(ğ¶, ğ‘€)K = ğ½(J(ğ¶â€²,ğ‘‰)K). Proof. By induction on the derivation of (ğ¶, ğ‘€) â‡“(ğ¶â€²,ğ‘‰). Throughout the proof we write ğ‘„ğ‘€ (resp. ğ‘„ğ‘‰) for the label context that types the term ğ‘€(resp. ğ‘‰); this means that we have ğ‘„= ğ‘„ğ‘€,ğ‘„â€² and similarly for ğ‘‰. Case app: We have ğ‘€= (ğœ†ğ‘¥.ğ‘) ğ‘Šwith (ğ¶, ğ‘[ğ‘Š/ğ‘¥]) â‡“(ğ·,ğ‘‰). It suffices to prove that J(ğœ†ğ‘¥.ğ‘)ğ‘ŠK = Jğ‘[ğ‘Š/ğ‘¥]K because then we can close this case by the induction hypothesis. By inversion on the typing rule, we must have ğ‘„ğ‘,ğ‘¥: ğµâŠ¢ğ‘ğ‘: ğ´ and ğ‘„ğ‘ŠâŠ¢ğ‘£ğ‘Š: ğµ with ğ‘„= ğ‘„ğ‘,ğ‘„ğ‘Šand â™¯Jğ‘„ğ‘ŠK = â™¯JğµK. J(ğœ†ğ‘¥.ğ‘)ğ‘ŠK = (ğ½((Î›(Jğ‘„ğ‘,ğ‘¥: ğµâŠ¢ğ‘ğ‘: ğ´K), idJâ™¯(ğ‘„ğ‘,ğ‘¥:ğµ)KM)) âŠ—ğ½(Jğ‘„ğ‘ŠâŠ¢ğ‘£ğ‘Š: ğµK)); ev (by def.) = (ğ½(Î›(Jğ‘„ğ‘,ğ‘¥: ğµâŠ¢ğ‘ğ‘: ğ´K), Jâ™¯(ğ‘„ğ‘,ğ‘¥: ğµ)KM) âŠ—ğ½(Jğ‘„ğ‘ŠâŠ¢ğ‘£ğ‘Š: ğµK)); ev (by def. of the functor ğ½(âˆ’,ğ‘‡)) = (ğ½(idğ‘„ğ‘âŠ—Jğ‘„ğ‘ŠâŠ¢ğ‘£ğ‘Š: ğµK)); Jğ‘„ğ‘,ğ‘¥: ğµâŠ¢ğ‘ğ‘: ğ´K (by the universaity of ev) = Jğ‘[ğ‘Š/ğ‘¥]K (by substituion lemma (Lemma 3)) 32 Ken Sakayori, Andrea Colledan, and Ugo Dal Lago Case dest: Similar to let. Case force: Similar to the case app, it suffices to show that Jforce(lift ğ‘)K = Jğ‘K, for some ğ‘such that ğ‘€= force(lift ğ‘). Since lift is a special case of abstraction (i.e. thunking) and force is a special case for application, this can be proved as in the case of app. Case apply: In this case, we have ğ‘€= apply(( Â¯â„“, ğ¸, Â¯ğ‘˜), Â¯ğ‘¡) for some circuit ğ¸and wire bundles Â¯â„“, Â¯ğ‘˜and Â¯ğ‘¡. Moreover, we have ğ¶; (ğ¸â‹‰Jğ‘„â€²KM) = ğ¶â€². By inversion on the typing rules, we must have âˆ…âŠ¢ğ‘£( Â¯â„“, ğ¸, Â¯ğ‘˜) : Circ(ğ‘‡,ğ‘ˆ) and Â¯ğ‘¡: ğ‘‡âŠ¢ğ‘£Â¯ğ‘¡: ğ‘‡ with ğ‘„ğ‘€âŠ¢ğ‘£Â¯ğ‘¡: ğ‘‡and ğ´= ğ‘ˆfor some ğ‘‡and ğ‘ˆ. We first show that Japply(( Â¯â„“, ğ¸, Â¯ğ‘˜), Â¯ğ‘¡)K = ğ½(id1, ğ¸). By definition, we have Japply(( Â¯â„“, ğ¸, Â¯ğ‘˜), Â¯ğ‘¡)K = (J( Â¯â„“, ğ¸, Â¯ğ‘˜)K âŠ—idğ‘„ğ‘€); apply = ((ğ½(Î›(id1, J( Â¯â„“, ğ¸, Â¯ğ‘˜)KM)); ğ½(box, idğ¼)) âŠ—idğ‘„ğ‘€); (ğ½(boxâˆ’1, idğ¼) âŠ—idğ‘„ğ‘€); ev = ((ğ½(Î›(id1, J( Â¯â„“, ğ¸, Â¯ğ‘˜)KM)) âŠ—idğ‘„ğ‘€); ev = ğ½(id1, J( Â¯â„“, ğ¸, Â¯ğ‘˜)KM). Therefore, J(ğ¶, ğ‘€)K = ğ½(id1,ğ¶); (Japply(( Â¯â„“, ğ¸, Â¯ğ‘˜), Â¯ğ‘¡)K âŠ—idğ‘„â€²) = ğ½(id1,ğ¶); (ğ½(id1, J( Â¯â„“, ğ¸, Â¯ğ‘˜)KM) âŠ—ğ½(id1, idğ‘„â€²)) = ğ½(id1,ğ¶); ğ½(id1, J( Â¯â„“, ğ¸, Â¯ğ‘˜)KM â‹‰Jğ‘„â€²K) = ğ½(id1,ğ¶â€²; perm) = J(ğ¶â€², Â¯ğ‘˜)K as desired. Here, perm is the isomorphism induced by the codomain of ğ¶â€² and type of Â¯ğ‘˜. Case box: It must be the case that ğ‘€= boxğ‘‡ğ‘Šand ğ‘‰= ( Â¯â„“, ğ·, Â¯ğ‘˜) for some valueğ‘Š, circuit ğ·, and wire bundles Â¯â„“and Â¯ğ‘˜, and moreover, (idğ‘„,ğ‘ŠÂ¯â„“) â‡“(ğ·, Â¯ğ‘˜). By inversion on the typing rules, we have âˆ…âŠ¢ğ‘£ğ‘Š: ğ‘‡âŠ¸ğ‘ˆ and âˆ…âŠ¢ğ‘£( Â¯â„“, ğ·, Â¯ğ‘˜) : Circ(ğ‘‡,ğ‘ˆ) where ğ´= Circ(ğ‘‡,ğ‘ˆ). Since the underlying circuit does not change during the reduc- tion, it suffices to show that Jboxğ‘‡ğ‘ŠK = ğ½(J( Â¯â„“, ğ·, Â¯ğ‘˜)K). Moreover, since Jboxğ‘‡ğ‘ŠK = ğ½(Jğ‘ŠK); ğ½(box, idğ¼) and ğ½(J( Â¯â„“, ğ·, Â¯ğ‘˜)K) = ğ½( Âœ J( Â¯â„“, ğ·, Â¯ğ‘˜)KM, idğ¼); ğ½(box, idğ¼) by the definitions, we only need to show that Jğ‘ŠK = ( Âœ J( Â¯â„“, ğ·, Â¯ğ‘˜)KM, idğ¼). By the induction hypothesis, we have J(idğ‘„,ğ‘ŠÂ¯â„“)K = Jğ‘ŠÂ¯â„“K = ğ½(id1, J( Â¯â„“, ğ·, Â¯ğ‘˜)KM) = J(ğ·, Â¯ğ‘˜)K. Thus, we have Jğ‘ŠK = (Î›(Jğ‘ŠÂ¯â„“K), idğ¼) = (Î›(ğ½(id1, J( Â¯â„“, ğ·, Â¯ğ‘˜)KM)), idğ¼) = ( Âœ J( Â¯â„“, ğ·, Â¯ğ‘˜)KM, idğ¼) as desired. Case return: In this case, we have ğ‘€= return ğ‘‰and ğ·= ğ¶. Since ğ·= ğ¶, it suffices to show that Jğ‘€K = ğ½((id1, perm); Jğ‘‰K) for some suitable permutation isomorphism perm, and this is obvious by the definition of Jreturn ğ‘‰K. Case let: In this case, we must have (ğ¶, ğ‘1) â‡“(ğ·,ğ‘Š) (ğ¸, ğ‘2[ğ‘Š/ğ‘¥]) â‡“(ğ·,ğ‘‰) (ğ¶, let ğ‘¥= ğ‘1 in ğ‘2) â‡“(ğ¶â€²,ğ‘‰) On Circuit Description Languages, Indexed Monads, and Resource Analysis 33 with ğ‘€= let ğ‘¥= ğ‘1 in ğ‘2 for some terms ğ‘1, ğ‘2, value ğ‘Šand circuit ğ¸. By the inversion on the typing rule, we must also have ğ‘„ğ‘1 âŠ¢ğ‘ğ‘1 : ğµ and ğ‘„ğ‘2,ğ‘¥: ğµâŠ¢ğ‘ğ‘2 : ğ´ for some ğ‘„ğ‘1 and ğ‘„ğ‘2 such that ğ‘„ğ‘€= ğ‘„ğ‘2,ğ‘„ğ‘1. J(ğ¶, ğ‘€)K = ğ½(id1,ğ¶); (Jlet ğ‘¥= ğ‘1 in ğ‘2K â‹‰Jğ‘„â€²K) = ğ½(id1,ğ¶);  (Jğ‘„ğ‘2K â‹ŠJğ‘1K); Jğ‘2K â‹‰Jğ‘„â€²K) = ğ½(id1,ğ¶); (Jğ‘„ğ‘2K â‹ŠJğ‘1K â‹‰Jğ‘„â€²K); (Jğ‘2K â‹‰Jğ‘„â€²K) = ğ½(id1, ğ·); (idJğ‘„ğ‘2K âŠ—ğ½(Jğ‘ŠK) â‹‰Jğ‘„â€²K); (Jğ‘2K â‹‰Jğ‘„â€²K) (by I.H.) = ğ½(id1, ğ·);  (idJğ‘„ğ‘2K âŠ—ğ½(Jğ‘ŠK)); Jğ‘„ğ‘2,ğ‘¥: ğµâŠ¢ğ‘ğ‘2 : ğ´K  â‹‰Jğ‘„â€²K  = ğ½(id1, ğ·);  Jğ‘2[ğ‘Š/ğ‘¥]K â‹‰Jğ‘„â€²K (by substitution lemma (Lemma 3)) = ğ½(id1,ğ¶â€²); (ğ½(Jğ‘‰K) â‹‰Jğ‘„â€²K) (by I.H.) = J(ğ¶â€²,ğ‘‰)K â–¡ A.2 Computational Adequacy The proof of computational adequacy also follows a standard strategy: we define a logical relation between semantics and syntax of Proto-Quipper-M. Similar logical relations have been considered by Colledan and Dal Lago [Colledan and Dal Lago 2024, 2025] to prove the correctness of the type system of Proto-Quipper-R. (These are defined by purely operational means.) We say that a value (resp. term) is closed if the value (resp. term) does not have any free variables (but it may have some labels). The set of closed values of type (resp. term) ğ´that is well- typed under the labeled context ğ‘„is denoted by CValğ‘„âŠ¢ğ´(resp. CTermğ‘„âŠ¢ğ´). We define relations (indexed by judgment of the form ğ‘„âŠ¢ğ´) Rğ‘„âŠ¢ğ´âŠ†(â™­Jğ´K Ã— M(Jğ‘„KM, â™¯Jğ´K)) Ã— CTermğ‘„âŠ¢ğ´and Vğ‘„âŠ¢ğ´âŠ†â™­Jğ´K Ã— CValğ‘„âŠ¢ğ´as the smallest relations satisfying the following conditions. â€¢ (ğ‘£,ğ¶; perm) Rğ‘„âŠ¢ğ´ğ‘€if and only if (idJğ‘„KM, ğ‘€) â‡“(ğ¶,ğ‘‰), ğ¶: ğ‘„â†’ğ¿â€² and ğ‘£Vğ¿âŠ¢ğ´ğ‘‰for some label contexts ğ¿â€² and ğ¿such that Jğ¿â€²KM perm âˆ’âˆ’âˆ’âˆ’â†’  Jğ¿KM where perm is a permutation isomorphism. â€¢ âˆ—Vâˆ…âŠ¢1 âˆ— â€¢ ğ‘›Vâˆ…âŠ¢Nat ğ‘› â€¢ âˆ—Vâ„“:ğ‘¤âŠ¢ğ‘¤â„“ â€¢ ğ‘“Vğ‘„âŠ¢ğ´âŠ¸ğ‘‡ğµğ‘‰if and only if for all ğ‘Šsuch that ğ‘¤Vğ¿âŠ¢ğ´ğ‘Š, we have ğ‘“ğ‘¤Rğ‘„,ğ¿âŠ¢ğµğ‘‰ğ‘Š. â€¢ ğ‘“Vâˆ…âŠ¢!ğ´ğ‘‰if and only if ğ‘“âˆ—Râˆ…âŠ¢ğµforceğ‘‰ â€¢ J( Â¯â„“,ğ¶, Â¯ğ‘˜)K Vâˆ…âŠ¢Circ(ğ‘‡,ğ‘ˆ) ( Â¯â„“,ğ¶, Â¯ğ‘˜) â€¢ (ğ‘£,ğ‘¤) Vğ‘„1,ğ‘„2âŠ¢ğ´âŠ—ğµâŸ¨ğ‘‰,ğ‘ŠâŸ©if and only if ğ‘£Vğ‘„1âŠ¢ğ‘‰and ğ‘¤Vğ‘„2âŠ¢ğ‘Š. We extend the relation to a relation between pairs of a value and a substitution and typing contexts by (ğ‘£,ğ›¾) Vğ‘„(ğ‘1 : ğ´1, . . . ,ğ‘ğ‘›: ğ´ğ‘›) â‡â‡’ğ‘£Vğ‘„âŠ¢ğ´1âŠ—Â·Â·Â·âŠ—ğ´ğ‘›âŸ¨ğ›¾(ğ‘1), . . . ,ğ›¾(ğ‘ğ‘›)âŸ© where â€¢ ğ‘£is an element of â™­Jğ´1K Ã— Â· Â· Â· Ã— â™­Jğ´ğ‘›K and â€¢ ğ›¾is a map from dom(Î“) to closed values such that, for each ğ‘ğ‘–, the only labels appearing in ğ›¾(ğ‘ğ‘–) are those in ğ‘„. 34 Ken Sakayori, Andrea Colledan, and Ugo Dal Lago The definition of Rğ‘„âŠ¢ğ´evaluates ğ‘€with the identity circuit, but this does not loose generality because if the initial configuration has a circuit that is not the identity we can just concatenate the initial circuit to the circuit obtained by evaluating ğ‘€with the identity circuit. Lemma 4. Suppose that ğ¶: ğ‘„0 â†’ğ‘„1, ğ¿,ğ‘„2 and ğ¿âŠ¢ğ‘€: ğ´. If (idJğ¿KM, ğ‘€) â‡“(ğ·,ğ‘‰) and (ğ¶, ğ‘€) â‡“ (ğ¸,ğ‘Š), then ğ‘‰=ğ‘Š(up to renaming of labels) and ğ¸= ğ¶; (Jğ‘„1KM â‹Š(ğ·â‹‰Jğ‘„2KM)). Proof. By induction on the derivation of (ğ¶, ğ‘€) â‡“(ğ¸,ğ‘Š). â–¡ The fundamental property of the logical relations hold. And, as usual, the theorem is a direct consequence of the fundamental property. Lemma 5 (Fundamental Property). Let Î“ be a type environment, ğ‘„be a label context such that Jğ‘„KM = â™¯JÎ“K. Suppose that (ğ‘£,ğ›¾) Vğ‘„Î“. Then the following holds. (1) Î“ âŠ¢ğ‘£ğ‘‰: ğ´implies â™­Jğ‘‰K(ğ‘£) Vğ‘„âŠ¢ğ´ğ›¾(ğ‘‰). (2) Î“ âŠ¢ğ‘ğ‘€: ğ´implies, Jğ‘€K(ğ‘£) Rğ‘„âŠ¢ğ´ğ›¾(ğ‘€) Proof. By simultaneous induction on the type derivation. We show two of the most interesting cases: the case for box and let. The other cases can be proved in a similar manner. Case box: In this case, we must have ğ‘€= box ğ‘‰, Î“ = Î¦ and ğ´= Circ(ğ‘‡,ğ‘ˆ) for some value ğ‘‰, parameter context Î¦ and bundle types ğ‘‡and ğ‘ˆ. Moreover, we have Î¦ âŠ¢ğ‘£ğ‘‰: ğ‘‡âŠ¸ğ‘ˆ. Suppose that (ğ‘£,ğ›¾) Vâˆ…Î¦. Our goal is to show Jğ‘€K(ğ‘£) Râˆ…âŠ¢Circ(ğ‘‡,ğ‘ˆ) ğ›¾(ğ‘€). By induction hypothesis, we have â™­Jğ‘‰K(ğ‘£) Vâˆ…âŠ¢ğ‘‡âŠ¸ğ‘ˆğ›¾(ğ‘‰). Hence, we have â™­Jğ‘‰K(ğ‘£)(âˆ—) R Â¯â„“:ğ‘‡âŠ¢ğ‘ˆğ›¾(ğ‘‰) Â¯â„“. By the definition of R Â¯â„“:ğ‘‡âŠ¢ğ‘ˆ, we have (idJğ‘‡KM,ğ›¾(ğ‘‰) Â¯â„“) â‡“(ğ¶, Â¯ğ‘˜) (7) â™­Jğ‘‰K(ğ‘£)(âˆ—) = (âˆ—,ğ¶; perm) (8) âˆ—Vğ¿âŠ¢ğ‘ˆÂ¯ğ‘˜ (9) perm: Jğ¿â€²KM âˆ’â†’Jğ¿KM (10) where ğ¶: Jğ‘‡KM â†’Jğ¿â€²KM By applying the box rule to (7), we have (idğ¼,ğ›¾(box ğ‘‰)) â‡“ (idğ¼, ( Â¯â„“,ğ¶, Â¯ğ‘˜)). It remains to show that Jğ‘€K(ğ‘£) = (J( Â¯â„“,ğ¶, Â¯ğ‘˜)KM, idğ¼), and this is an immediate consequence of (8) and the interpretation of box . Case let: It must be the case that ğ‘€= (let ğ‘¥= ğ‘in ğ‘ƒ) Î“ = Î¦, Î“2, Î“1 Î¦, Î“1 âŠ¢ğ‘ğ‘: ğµ Î¦, Î“2,ğ‘¥: ğµâŠ¢ğ‘ğ‘ƒ: ğ´ for some terms ğ‘and ğ‘€, some type ğµand contexts Î¦, Î“1 and Î“2. Let ğ‘„1 and ğ‘„2 be label contexts such that Jğ‘„1KM = â™¯JÎ“1K and Jğ‘„2KM = â™¯JÎ“2K. Suppose that (ğ‘£,ğ›¾) Vğ‘„2,ğ‘„1 Î“. We need to show that Jğ‘€K(ğ‘£) RâŠ¢ğ‘„2,ğ‘„1 ğ›¾(ğ‘€). Let us write ğ‘£0 , ğ‘£1 and ğ‘£2 for the Î¦, Î“1 and Î“2 part of ğ‘£, respectively, and let ğ›¾1 def= ğ›¾â†¾dom(Î¦,Î“1) and ğ›¾2 def= ğ›¾â†¾dom(Î¦,Î“2). By the induction hypothesis, we have Jğ‘K(ğ‘£0, ğ‘£1) Rğ‘„1âŠ¢ğµğ›¾1(ğ‘) (11) Jğ‘ƒK(ğ‘£0, ğ‘£2,ğ‘¤) Rğ‘„2,ğ‘„1âŠ¢ğ´[ğ‘Š/ğ‘¥]ğ›¾2(ğ‘ƒ) (12) where Jğ‘K(ğ‘£0, ğ‘£1) = (ğ‘¤,ğ¶) (13) (idJğ‘„1KM,ğ›¾1(ğ‘)) â‡“(ğ¶â€²,ğ‘Š) (14) On Circuit Description Languages, Indexed Monads, and Resource Analysis 35 By (11), we must have ğ‘¤Vğ‘„1âŠ¢ğµğ‘Šand ğ¶= ğ¶â€² (up to permutation which we shall ignore for simplicity). By applying Lemma 4 to (14), we also have (idJğ‘„2,ğ‘„1KM,ğ›¾1(ğ‘)) â‡“(Jğ‘„2KM â‹Šğ¶â€²,ğ‘Š). (15) Now suppose that Jğ‘ƒK(ğ‘£0, ğ‘£2,ğ‘¤) = (ğ‘£ret, ğ·) (16) (idJğ‘„1KM,ğ›¾1(ğ‘)) â‡“(ğ·â€²,ğ‘‰) (17) By the definition of (12), it must be the case that ğ‘£ret Vğ‘„2,ğ‘„1âŠ¢ğµğ‘‰and ğ·= ğ·â€² (again, up to permutation which we ignore). Then, once again, by Lemma 4, we have (Jğ‘„2KM â‹Šğ¶â€², [ğ‘Š/ğ‘¥]ğ›¾2(ğ‘ƒ)) â‡“((Jğ‘„2KM â‹Šğ¶â€²); ğ·â€²,ğ‘‰) (18) It follows that (idJğ‘„2,ğ‘„1KM,ğ›¾(ğ‘€)) â‡“((Jğ‘„2KM â‹Šğ¶â€²); ğ·,ğ‘‰) by applying the rule let to (15) and (18). From the definition of Jğ‘€K, (13), and (16) together with ğ‘£ret Vğ‘„2,ğ‘„1âŠ¢ğµğ‘‰we have â™­(Jğ‘€K(ğ‘£0, ğ‘£2, ğ‘£1)) Vğ‘„2,ğ‘„1âŠ¢ğ´ğ‘‰. The equality (up to permutation) on the circuit part also holds. We, therefore, have Jğ‘€K(ğ‘£) Rğ‘„2,ğ‘„1âŠ¢ğ´ğ›¾(ğ‘€). â–¡ Theorem 6 (Computational Adequacy). Suppose that âˆ…âŠ¢(ğ¶, ğ‘€) : 1; âˆ…and J(ğ¶, ğ‘€)K = ğ½(J(ğ·,ğ‘‰)K). Then (ğ¶, ğ‘€) â‡“(ğ·,ğ‘‰) (possibly up to renamings of labels). Proof. The assumption âˆ…âŠ¢(ğ¶, ğ‘€) : 1; âˆ…means that there is a label context ğ‘„such that ğ‘„âŠ¢ğ‘ğ‘€: 1. Since ğ‘€is closed, using the previous lemma, we obtain Jğ‘€K(âˆ—) Rğ‘„âŠ¢1 ğ‘€. By the definition of Rğ‘„âŠ¢1, we have (idJğ‘„KM, ğ‘€) â‡“(ğ¸, âˆ—) where Jğ‘€K(âˆ—) = (âˆ—, ğ¸). By J(ğ¶, ğ‘€)K = ğ½(J(ğ·,ğ‘‰)K), it follows that ğ·= ğ¶; ğ¸. From this and Lemma 4, we have (ğ¶, ğ‘€) â‡“(ğ·,ğ‘‰) as desired. â–¡ Remark 5. To prove the adequacy for terms typed in the type-and-effect system, we just need to add effect annotations to the logical relations. That is, the logical relation for computations, now becomes Rğ‘’ ğ‘„âŠ¢ğ´âŠ†(â™­Jğ´K Ã— Mâ‰²ğ‘’(Jğ‘„KM, â™¯Jğ´K)) Ã— CTermğ‘„âŠ¢ğ´;ğ‘’where CTermğ‘„âŠ¢ğ´;ğ‘’is the set of terms ğ‘€such that ğ‘„âŠ¢ğ‘ğ‘€: ğ´;ğ‘’. Note that the set of circuits are now restricted to Mâ‰²ğ‘’(Jğ‘„KM, â™¯Jğ´K)). Relations Vğ‘„âŠ¢ğ´for arrow type, thunk type, and circuit type are changed accordingly. â— 36 Ken Sakayori, Andrea Colledan, and Ugo Dal Lago B Omitted Definitions from Section 5 This section shows the typing rules and the interpretation that was omitted from Section 5. B.1 Full Definition of the Typing Rules Here we list the full list of typing rules for reference. The rules that were omitted from Section 5 are mostly identical to the corresponding rules of Proto-Quipper-C. unit Î¦ âŠ¢ğ‘£âˆ—: 1 nat Î¦ âŠ¢ğ‘£ğ‘›: Nat lab Î¦, â„“: ğ‘¤âŠ¢ğ‘£â„“: ğ‘¤ var Î¦,ğ‘¥: ğ´âŠ¢ğ‘£ğ‘¥: ğ´ abs Î“,ğ‘¥: ğ´âŠ¢ğ‘ğ‘€: ğµ;ğ‘’: t â†’u Î“ âŠ¢ğ‘£ğœ†ğ‘¥ğ´.ğ‘€: ğ´ ğ‘’: tâ†’u âŠ¸#(Î“) ğµ app Î¦, Î“1 âŠ¢ğ‘£ğ‘‰: ğ´ ğ‘’: sâ†’u âŠ¸ğ‘‡ ğµ Î¦, Î“2 âŠ¢ğ‘£ğ‘Š: ğ´ Î¦, Î“1, Î“2 âŠ¢ğ‘ğ‘‰ğ‘Š: ğµ;ğ‘’: s â†’u lift Î¦ âŠ¢ğ‘ğ‘€: ğ´;ğ‘’: t â†’u Î¦ âŠ¢ğ‘£lift ğ‘€: !ğ‘’ğ´ force Î¦ âŠ¢ğ‘£ğ‘‰: !ğ‘’ğ´ Î¦ âŠ¢ğ‘forceğ‘‰: ğ´;ğ‘’: t â†’u circ ğ¶: ğ‘„â†’ğ¿ ğ‘„ğœğ‘„â€² ğ¿ğœğ¿â€² ğ‘„â€² âŠ¢ğ‘£Â¯â„“: ğ‘‡ğ¿â€² âŠ¢ğ‘£Â¯ğ‘˜: ğ‘ˆğ›¼(J( Â¯â„“,ğ¶, Â¯ğ‘˜)K) = ğ‘’ Î¦ âŠ¢ğ‘£( Â¯â„“,ğ¶, Â¯ğ‘˜) : Circğ‘’(ğ‘‡,ğ‘ˆ) box Î¦ âŠ¢ğ‘£ğ‘‰: ğ‘‡ ğ‘’: tâ†’u âŠ¸ğ¼ ğ‘ˆ Î¦ âŠ¢ğ‘boxğ‘‡ğ‘‰: Circğ‘’: tâ†’u(ğ‘‡,ğ‘ˆ);ğœ€ apply Î¦, Î“1 âŠ¢ğ‘£ğ‘‰: Circğ‘’: tâ†’u(ğ‘‡,ğ‘ˆ) Î¦, Î“2 âŠ¢ğ‘£ğ‘Š: ğ‘‡ Î¦, Î“1, Î“2 âŠ¢ğ‘apply(ğ‘‰,ğ‘Š) : ğ‘ˆ;ğ‘’: t â†’u dest Î¦, Î“1 âŠ¢ğ‘£ğ‘‰: ğ´âŠ—ğµ Î¦, Î“2,ğ‘¥: ğ´,ğ‘¦: ğµâŠ¢ğ‘ğ‘€: ğ¶;ğ‘’ Î¦, Î“2, Î“1 âŠ¢ğ‘let âŸ¨ğ‘¥,ğ‘¦âŸ©= ğ‘‰in ğ‘€: ğ¶;ğ‘’ ifz Î¦ âŠ¢ğ‘£ğ‘‰: Nat Î¦, Î“ âŠ¢ğ‘ğ‘€: ğ´;ğ‘’ Î¦, Î“ âŠ¢ğ‘ğ‘: ğ´;ğ‘’ Î¦, Î“ âŠ¢ğ‘ifz ğ‘‰then ğ‘€else ğ‘: ğ´;ğ‘’ pair Î¦, Î“1 âŠ¢ğ‘£ğ‘‰: ğ´Î¦, Î“2 âŠ¢ğ‘£ğ‘Š: ğµ Î¦, Î“1, Î“2 âŠ¢ğ‘£âŸ¨ğ‘‰,ğ‘ŠâŸ©: ğ´âŠ—ğµ return Î“ âŠ¢ğ‘£ğ‘‰: ğ´ ğ›¼(â™¯Jğ´K) = t Î“ âŠ¢ğ‘return ğ‘‰: ğ´; idt : t â†’t let Î¦, Î“1 âŠ¢ğ‘ğ‘€: ğ´;ğ‘’1 : t1 â†’tâ€² 1 Î¦, Î“2,ğ‘¥: ğ´âŠ¢ğ‘ğ‘: ğµ;ğ‘’2 : t2 â†’tâ€² 2 ğ›¼(Jâ™¯Î“ğ‘–K) = uğ‘– ğ‘’= (idu2 â‹Šğ‘’1);ğ‘’2 Î¦, Î“2, Î“1 âŠ¢ğ‘let ğ‘¥= ğ‘€in ğ‘: ğµ;ğ‘’ sub Î“ âŠ¢ğ‘ğ‘€: ğ´;ğ‘’1 : t â†’u ğ‘’1 â‰²ğ‘’2 Î“ âŠ¢ğ‘ğ‘€: ğ´;ğ‘’2 : t â†’u ex perm : JÎ“1K âŠ—Jğ´K âŠ—JğµK âŠ—JÎ“2K âˆ’â†’JÎ“1K âŠ—JğµK âŠ—Jğ´K âŠ—JÎ“2K Î“1,ğ‘: ğ´,ğ‘: ğµ, Î“2 âŠ¢ğ‘ğ‘€: ğ¶;ğ‘’: t â†’u Î“1,ğ‘: ğµ,ğ‘: ğ´, Î“2 âŠ¢ğ‘ğ‘€: ğ¶; (ğ›¼(perm);ğ‘’) Fig. 11. Typing rules for the effect system of Proto-Quipper-R (full definition). B.2 Interpretation of Value Judgments We first show how value judgments are interpreted. As explained, value judgments are interpreted in V(= Set Ã— disc(M)) and the interpretation is essentially the same as that of the simply-typed On Circuit Description Languages, Indexed Monads, and Resource Analysis 37 system. Here we only show the interpretation of values with types that have effect annotations. JÎ“ âŠ¢ğ‘£ğœ†ğ‘¥ğ´.ğ‘€: ğ´ ğ‘’: tâ†’u âŠ¸#(Î“) ğµK def= (Î›ğ‘’(JÎ“,ğ‘¥: ğ´âŠ¢ğ‘ğ‘€: ğµ;ğ‘’K), idJ#(Î“)KM)) JÎ¦ âŠ¢ğ‘£lift ğ‘€: !ğ‘’ğ´K def= (Î›ğ‘’(JÎ¦ âŠ¢ğ‘ğ‘€: ğ´K), idğ¼) JÎ¦ âŠ¢ğ‘£( Â¯â„“,ğ¶, Â¯ğ‘˜) : Circğ‘’(ğ‘‡,ğ‘ˆ)K def= (!JÎ¦K; Âœ J( Â¯â„“,ğ¶, Â¯ğ‘˜)K, idğ¼) The above interpretations are almost identical to those of Figure 5. The only difference is the natural bijection Î›ğ‘’, which is now indexed with ğ‘’: Set(ğ‘‹Ã— ğ‘Œ,ğ‘Ã— Mâ‰²ğ‘’(ğ‘‡,ğ‘ˆ)) Î›ğ‘’,ğ‘‹,ğ‘Œ,ğ‘ âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’  Set(ğ‘‹,ğ‘Œâ‡’Set ğ‘Ã— Mâ‰²ğ‘’(ğ‘‡,ğ‘ˆ)). The morphism Ë†ğ¶: 1 â†’Mâ‰²ğ‘’(Jğ‘‡KM, Jğ‘ˆKM) is the global element Ë†ğ¶(âˆ—) = ğ¶(which in turn can be defined using Î›ğ‘’). B.3 Interpretation of Computational Judgments Recall that Î“ âŠ¢ğ‘ğ‘€: ğ´;ğ‘’is interpreted as a morphism in Set from â™­JÎ“K to T ğ‘’: â™¯JÎ“Kâ†’â™¯Jğ´K(â™­Jğ´K). Application and forcing. t Î¦, Î“1 âŠ¢ğ‘£ğ‘‰: ğ´ ğ‘’: sâ†’u âŠ¸ğ‘‡ ğµ Î¦, Î“2 âŠ¢ğ‘£ğ‘Š: ğ´ Î¦, Î“1, Î“2 âŠ¢ğ‘ğ‘‰ğ‘Š: ğµ;ğ‘’: s â†’u | def= JÎ¦Kğ‘ƒÃ— â™­JÎ“1K Ã— â™­JÎ“2K Î”JÎ¦Kğ‘ƒÃ—id âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’JÎ¦Kğ‘ƒÃ— JÎ¦K Ã— â™­JÎ“1Kğ‘ƒÃ— â™­JÎ“2K  âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’(JÎ¦Kğ‘ƒÃ— â™­JÎ“1K) Ã— (JÎ¦Kğ‘ƒÃ— â™­JÎ“2K) â™­Jğ‘‰KÃ—â™­Jğ‘ŠK âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’â™­Jğ´âŠ¸ğ‘‡ğµK Ã— â™­Jğ´K ev âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’T ğ‘’(â™­JğµK) t Î¦ âŠ¢ğ‘£ğ‘‰: !ğ‘’ğ´ Î¦ âŠ¢ğ‘forceğ‘‰: ğ´;ğ‘’: t â†’u | def= JÎ¦Kğ‘ƒ â™­Jğ‘‰K âˆ’âˆ’âˆ’â†’â™­J!ğ‘’ğ´K Ã— 1 ev âˆ’âˆ’âˆ’âˆ’âˆ’â†’T ğ‘’(â™­Jğ´K) Here, unlike in Section 4, ev is the evaluation morphism for the exponential objects in Set. 38 Ken Sakayori, Andrea Colledan, and Ugo Dal Lago Circuit operations. t Î¦ âŠ¢ğ‘£ğ‘‰: ğ‘‡ ğ‘’: tâ†’u âŠ¸ğ¼ ğ‘ˆ Î¦ âŠ¢ğ‘boxğ‘‡ğ‘‰: Circğ‘’: tâ†’u(ğ‘‡,ğ‘ˆ);ğœ€ | def= JÎ¦Kğ‘ƒ Jğ‘‰K âˆ’âˆ’âˆ’âˆ’âˆ’â†’â™­Jğ‘‡ ğ‘’âŠ¸ğ‘ˆK box âˆ’âˆ’âˆ’âˆ’âˆ’â†’Mâ‰²ğ‘’(Jğ‘‡KM, Jğ‘ˆKM) ğœ‚ğ¼ âˆ’âˆ’âˆ’âˆ’âˆ’â†’T ğœ€(Mâ‰²ğ‘’(Jğ‘‡KM, Jğ‘ˆKM)) t Î¦, Î“1 âŠ¢ğ‘£ğ‘‰: Circğ‘’: tâ†’u(ğ‘‡,ğ‘ˆ) Î¦, Î“2 âŠ¢ğ‘£ğ‘Š: ğ‘‡ Î¦, Î“1, Î“2 âŠ¢ğ‘apply(ğ‘‰,ğ‘Š) : ğ‘ˆ;ğ‘’: t â†’u | def= JÎ¦Kğ‘ƒÃ— â™­JÎ“1K Ã— â™­JÎ“2K Î”JÎ¦Kğ‘ƒÃ—id âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’JÎ¦Kğ‘ƒÃ— JÎ¦Kğ‘ƒÃ— â™­JÎ“1K Ã— â™­JÎ“2K  âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’(JÎ¦Kğ‘ƒÃ— â™­JÎ“1K) Ã— (JÎ¦Kğ‘ƒÃ— â™­JÎ“2K) â™­Jğ‘‰KÃ—â™­Jğ‘ŠK âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’Mâ‰²ğ‘’(Jğ‘‡KM, Jğ‘ˆKM) ğœ‚Jğ‘‡KM âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’T idJğ‘‡K(Mâ‰²ğ‘’(Jğ‘‡KM, Jğ‘ˆKM))) comp âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’T ğ‘’(1). Here compğ‘‡1,ğ‘‡2,ğ‘‡3 : M(ğ‘‡1,ğ‘‡2) Ã— M(ğ‘‡2,ğ‘‡3) â†’M(ğ‘‡1,ğ‘‡3) is the composition morphism. Return and let. t Î“ âŠ¢ğ‘£ğ‘‰: ğ´ ğ›¼(â™¯Jğ´K) = t Î“ âŠ¢ğ‘return ğ‘‰: ğ´; idt : t â†’t | def= â™­JÎ“K â™­Jğ‘‰K âˆ’âˆ’âˆ’â†’â™­Jğ´K ğœ‚â™¯Jğ´K âˆ’âˆ’âˆ’âˆ’âˆ’â†’T idâ™¯Jğ´K(â™­Jğ´K) u v Î¦, Î“1 âŠ¢ğ‘ğ‘€: ğ´;ğ‘’1 : t1 â†’tâ€² 1 Î¦, Î“2,ğ‘¥: ğ´âŠ¢ğ‘ğ‘: ğµ;ğ‘’2 : t2 â†’tâ€² 2 Jâ™¯Î“ğ‘–K â–·uğ‘– ğ‘’= (idu2 â‹Šğ‘’1);ğ‘’2 Î¦, Î“2, Î“1 âŠ¢ğ‘let ğ‘¥= ğ‘€in ğ‘: ğµ;ğ‘’ } ~ def= JÎ¦K Ã— â™­JÎ“2K Ã— â™­JÎ“1K (Î”Ã—id); âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’JÎ¦K Ã— â™­JÎ“2K Ã— JÎ¦K Ã— â™­JÎ“1K idÃ—ğœ‚u2 Ã—Jğ‘€K âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’JÎ¦K Ã— T idu2 M â™­JÎ“2K Ã— T ğ‘’1 M â™­Jğ´K idÃ—<âƒ;ğœ âˆ’âˆ’âˆ’âˆ’âˆ’â†’T idâ‹Šğ‘’1 M (JÎ¦K Ã— â™­JÎ“2K Ã— â™­Jğ´K) Tidâ‹Šğ‘’1 M Jğ‘K âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’T idâ‹Šğ‘’1 M (T ğ‘’2 M (â™­JğµK)) ğœ‡idâ‹Šğ‘’1,ğ‘’2 âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’T (idâ‹Šğ‘’1);ğ‘’2 M (â™­JğµK). Subsumption. t Î“ âŠ¢ğ‘ğ‘€: ğ´;ğ‘’1 : t â†’u ğ‘’1 â‰²ğ‘’2 Î“ âŠ¢ğ‘ğ‘€: ğ´;ğ‘’2 : t â†’u | def= â™­JÎ“K Jğ‘€K âˆ’âˆ’âˆ’â†’T ğ‘’1 : â™¯JÎ“Kâ†’â™¯Jğ´K(â™­Jğ´K) Tğ‘’1â‰²ğ‘’2 â™­Jğ´K âˆ’âˆ’âˆ’âˆ’âˆ’â†’T ğ‘’2(â™­Jğ´K) On Circuit Description Languages, Indexed Monads, and Resource Analysis 39 C Supplementary Materials on Indexed Monads and Parameterized Freyd Categories As supplementary material, we include a brief review of indexed monads and the parameterized Freyd category to make the paper self-contained. Most of the definitions are drawn from [Atkey 2009]. We present only the minimal definitions required to understand this paper, with explanations tailored to our purposes. C.1 Parameterized Freyd category We give the precise definition of parameterized Freyd category that was omitted from the body of the paper. Definition 12 ([Atkey 2009]). A parameterized Freyd category consists of three functors ğ½: CÃ—S â†’ K, â‹Šâƒ: C Ã— K â†’K and â‹‰âƒ: K Ã— C â†’K such that â€¢ ğ½is identity on objects, â€¢ the cartesian product of C is respected: ğ‘‹â‹Šâƒğ½(ğ‘Œ,ğ‘†) = ğ½(ğ‘‹,ğ‘†) â‹‰âƒğ‘Œ= ğ½(ğ‘‹Ã— ğ‘Œ,ğ‘†), â€¢ for each ğ‘†âˆˆS, the transformations given by the associativity ğ½(ğ›¼,ğ‘†), the left unitor ğ½(ğœ†,ğ‘†), the right unitor ğ½(ğœŒ,ğ‘†) and the symmetry ğ½(ğ‘ ,ğ‘†) of the symmetric monoidal structure arising from the finite products of C must be natural in the variables in all combinations of Ã—, â‹Šâƒand â‹‰âƒthat make up their domain and codomain. As is clear from the above conditions, we are assuming that C has finite products. The pair of functors â‹Šâƒand â‹‰âƒis often called the premonoidal structure of the parameterized Freyd category (with respect to C). â— The most important example (and the only example appearing in the paper) of a parameterized Freyd category is the one given by the Kleisli construction of an indexed monad. As already explained, the Kleisli category of T : Sop Ã— S Ã— C â†’C has pairs of objects of C and S as its objects and the homset CT((ğ‘‹,ğ‘†), (ğ‘Œ,ğ‘‡) is defined as C(ğ‘‹, T (ğ‘†,ğ‘‡,ğ‘Œ)). Compositions of morphisms ğ‘“: (ğ‘‹,ğ‘†) â†’(ğ‘Œ,ğ‘‡) and ğ‘”: (ğ‘Œ,ğ‘‡) â†’(ğ‘,ğ‘ˆ) are defined by the Kleisli composition: ğ‘‹ ğ‘“âˆ’â†’T (ğ‘†,ğ‘‡,ğ‘Œ) T(ğ‘†,ğ‘‡,ğ‘”) âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’T (ğ‘†,ğ‘‡, T (ğ‘‡,ğ‘ˆ,ğ‘)) ğœ‡ğ‘†,ğ‘‡,ğ‘ˆ,ğ‘ âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’T (ğ‘†,ğ‘ˆ,ğ‘). The (morphism part of the) functor â‹Šâƒis defined by ğ‘“â‹Šâƒğ‘ def= ğ‘‹Ã—ğ‘Š ğ‘“Ã—ğ‘ âˆ’âˆ’âˆ’â†’ğ‘ŒÃ— T (ğ‘†,ğ‘‡,ğ‘) ğœğ‘Œ,ğ‘†,ğ‘‡,ğ‘ âˆ’âˆ’âˆ’âˆ’âˆ’â†’T (ğ‘†,ğ‘‡,ğ‘ŒÃ— ğ‘). (19) for ğ‘“: ğ‘‹â†’ğ‘Œ, a morphism in C, and ğ‘: (ğ‘Š,ğ‘†) â†’(ğ‘,ğ‘‡). C.2 Lifting of the Premonoidal Structure In the main part of the paper, we claimed that the premonoidal structure is lifted to the indexed monad, parameterized Freyd category, and the category-graded monad. Here we make precise what we mean by that. This is just a review of an existing, but perhaps not so known, notion [Atkey 2009], and we believe that having this supplementary section would help readers understand the technical details. However, readers not interested in the technical definitions may safely ignore this section. To understand the interpretation, it suffices to understand that there is an operation, called the lifting of âˆ’â‹‰ğ‘‡, that acts on computations by modifying the underlying circuit ğ¶to ğ¶â‹‰ğ‘‡. It may be worth mentioning that our interpretation, as well as the soundness result, does not use any specific property of the circuit monad except for circuit related operations such as box and lift. The interpretation of the other constructs only relies on the parameterized Freyd structure and the existence of the premonoidal lifting. We start by reviewing the notion of lifting for indexed monads. 40 Ken Sakayori, Andrea Colledan, and Ugo Dal Lago Definition 13 (Lifting for indexed monads [Atkey 2009]). Let T be a S-indexed monad over a cartesian category C and ğ¹: S â†’S be an endofunctor. A lifting of ğ¹to T is a natural transformation ğ¹â€  ğ‘†,ğ‘‡,ğ‘‹: T (ğ‘†,ğ‘‡,ğ‘‹) â†’T (ğ¹ğ‘†, ğ¹ğ‘‡,ğ‘‹) that commutes with the unit, multiplication (and strength of the monad): ğœ‚ğ¹ğ‘†,ğ‘‹ ğœ‚ğ‘†,ğ‘‹ ğ¹â€  ğ‘†,ğ‘†,ğ‘‹ ğ‘‹ T (ğ‘†,ğ‘†,ğ‘‹) T (ğ¹ğ‘†, ğ¹ğ‘†,ğ‘‹) ğœ‡ğ‘†,ğ‘‡,ğ‘ˆ,ğ‘‹ ğ¹â€  ğ‘†,ğ‘‡,T(ğ‘‡,ğ‘ˆ,ğ‘‹) T(ğ¹ğ‘†,ğ¹ğ‘‡,ğ¹â€ ) ğ¹â€  ğ‘†,ğ‘ˆ,ğ‘‹ ğœ‡ğ¹ğ‘†,ğ¹ğ‘‡,ğ¹ğ‘ˆ,ğ‘‹ T (ğ‘†,ğ‘‡, T (ğ‘‡,ğ‘ˆ,ğ‘‹)) T (ğ¹ğ‘†, ğ¹ğ‘‡, T (ğ‘‡,ğ‘ˆ,ğ‘‹)) T (ğ‘†,ğ‘ˆ,ğ‘‹) T (ğ¹ğ‘†,ğ‘†ğ‘ˆ,ğ‘‹) T (ğ¹ğ‘†, ğ¹ğ‘‡, T (ğ¹ğ‘‡, ğ¹ğ‘ˆ,ğ‘‹)) A natural transformation ğœƒ: ğ¹â†’ğºis natural for liftings ğ¹â€  and ğºâ€  if the following diagram commutes. ğºâ€  ğ‘†,ğ‘‡,ğ‘‹ ğ¹â€  ğ‘†,ğ‘‡,ğ‘‹ T(ğ¹ğ‘†,ğœƒğ‘‡,ğ‘‹) T(ğœƒğ‘†,ğºğ‘‡,ğ‘‹) T (ğ‘†,ğ‘‡,ğ‘‹) T (ğ¹ğ‘†, ğ¹ğ‘‡,ğ‘‹) T (ğºğ‘†,ğºğ‘‡,ğ‘‹) T (ğ¹ğ‘†,ğºğ‘‡,ğ‘‹) â— Definition 14. We say that an S-indexed monad T has premonoidal lifting if there are liftings for the functors âˆ’â‹‰ğ‘†and ğ‘†â‹Šâˆ’, written (âˆ’â‹‰ğ‘†)â€  and (ğ‘†â‹Šâˆ’)â€ , for every ğ‘†âˆˆS, such that all the associativity and left and right unitors are natural for them. Furthermore, the indexed monad is said to have a symmetric premonoidal lifting if the symmetry natural transformations are also natural. â— As we briefly explained, the circuit monad TM has premonoidal lifting. Next we review the notion of liftings for the parameterized Freyd category. The liftings for an indexed monad and the liftings for the parameterized Freyd category obtained as the Kleisli category of that indexed monad are mutually related. Definition 15 (Lifting for parameterized Freyd categories [Atkey 2009]). Let ğ¹: S â†’S be an endofunctor and (ğ½, â‹Šâƒ, â‹‰âƒ) be a parametric Freyd category where ğ½: CÃ—S â†’K. The parameterized Freyd category has a lifting of ğ¹if it has a functor ğ¹â˜…: K â†’K such that â€¢ ğ¹â˜…(ğ½(ğ‘‹,ğ‘†)) = ğ½(ğ‘‹, ğ¹ğ‘†) and ğ¹â˜…(ğ½(ğ‘“,ğ‘ )) = ğ½(ğ‘“, ğ¹ğ‘ ) for ğ‘“âˆˆC(ğ‘‹,ğ‘Œ) and ğ‘ âˆˆS(ğ‘†,ğ‘‡) â€¢ ğ¹â˜…respects the premonoidal structure: ğ¹â˜…(ğ‘‹â‹Šâƒ(ğ‘Œ,ğ‘†)) = ğ¹â˜…((ğ‘‹,ğ‘†) â‹‰âƒğ‘Œ) = (ğ‘‹Ã— ğ‘Œ, ğ¹ğ‘†) and ğ¹â˜…(ğ‘“â‹Šâƒğ‘) = ğ‘“â‹Šğ¹â˜…ğ‘(and similarly for â‹‰âƒ). A natural transformation ğœƒ: ğ¹â†’ğºis natural for liftings ğ¹â˜…and ğºâ˜…if the following diagram commutes for all ğ‘: (ğ‘‹,ğ‘†) â†’(ğ‘Œ,ğ‘‡). ğ¹â€ ğ‘“ ğ½(ğ‘‹,ğœƒğ‘†) ğºâ€ ğ‘“ ğ½(ğ‘Œ,ğœƒğ‘‡) ğ½(ğ‘‹, ğ¹ğ‘†) ğ½(ğ‘‹,ğºğ‘†) ğ½(ğ‘Œ, ğ¹ğ‘‡) ğ½(ğ‘,ğºğ‘‡) â— On Circuit Description Languages, Indexed Monads, and Resource Analysis 41 Proposition 2 ([Atkey 2009, Theorem 3]). Let T be an indexed monad over a cartesian category C. If ğ¹â€  is a lifting of an endofunctor ğ¹: S â†’S, then we can construct a lifting ğ¹â˜…on the parameterized Freyd category CT and vice versa. These operations are inverse. If a natural transformation from ğ¹to ğºis natural for liftings ğ¹â€  and ğºâ€ , then it is also natural for liftings ğ¹â˜…and ğºâ˜…, and vice versa. The premonoidal lifting for parameterized Freyd category is defined as in Definition 14, and it is easy to check that if T has a premonoidal lifting so does its Kleisli category. We note that a parametrized Freyd category with a premonoidal lifting, in a sense, has two premonoidal structures one respect to C and the other respect to S. This allows us to define a binoidal functor (ğ‘‹,ğ‘†) â‹Š âˆ’: K â†’K, for each (ğ‘‹,ğ‘†) âˆˆK, defined as (ğ‘‹â‹Šâƒâˆ’); (ğ‘†â‹Šâˆ’)â˜…. The functor âˆ’â‹‰(ğ‘‹,ğ‘†) : K â†’K is defined analogously. It is not hard to see that this is makes K a premonoidal category. In particular, for SetTM, we have ((ğ‘‹,ğ‘†) â‹Šğ‘“)(ğ‘¥,ğ‘¦) = ((ğ‘¥,ğ‘§),ğ‘†â‹Šğ¶) provided that ğ‘“: ğ‘Œâ†’TM(ğ‘‡,ğ‘ˆ,ğ‘) maps ğ‘¦to (ğ‘§,ğ¶). In other words, (ğ‘‹,ğ‘†) â‹Šğ‘“just performs the computation against the second element and, at the same time, augments wires to the underlying circuit of the computation. It is this premonoidal structure that is used in the interpretation of the computational judgments given in Section 4. We note that ğ½(ğ‘“,ğ‘ ) is a central morphism if ğ‘ is with respect to the premonoidal structure of S. Therefore, the values are interpreted as central morphisms in the interpretation. The notion of lifting of functors can be naturally extended to category-graded monads. Definition 16 (Lifting for category-graded monad). Let T be a A-graded monad over a carte- sian category C and ğ¹: A â†’A be an endofunctor. A lifting of ğ¹to T is a family of natural transformation ğ¹â€  ğ‘“,ğ‘‹: T ğ‘“ğ‘‹â†’T ğ¹ğ‘“ğ‘‹indexed by morphisms ğ‘“in A that commutes with the unit, multiplication (and strength of the monad): ğœ‚ğ¹ğ‘,ğ‘‹ ğœ‚ğ‘,ğ‘‹ ğ¹â€  idğ‘,ğ‘‹ ğ‘‹ T idğ‘ T idğ¹ğ‘ ğœ‡ğ‘“,ğ‘”ğ‘‹ ğ¹â€  ğ‘“,Tğ‘”ğ‘‹ Tğ¹ğ‘“(ğ¹â€ ) ğ¹â€  ğ‘“;ğ‘”,ğ‘‹ ğœ‡ğ¹ğ‘“,ğ¹ğ‘”,ğ‘‹ T ğ‘“(T ğ‘”ğ‘‹) T ğ¹ğ‘“(T ğ‘”ğ‘‹) T ğ‘“;ğ‘”ğ‘‹ T ğ¹ğ‘“;ğ¹ğ‘”ğ‘‹ T ğ¹ğ‘“(T ğ¹ğ‘”ğ‘‹) A natural transformation ğœƒ: ğ¹â†’ğºis natural for liftings ğ¹â€  and ğºâ€  if there is a generalized unit [Orchard et al. 2020] ğœ‚ğœƒğ‘,ğ‘‹: ğ‘‹â†’T ğœƒğ‘ğ‘‹for each component ğœƒğ‘such that ğºâ€  ğ‘“,ğ‘‹ ğ¹â€  ğ‘“,ğ‘‹ Tğ¹ğ‘“ğœ‚ğœƒğ‘,ğ‘‹ ğœ‡ ğœ‚ğ‘,Tğºğ‘“ğ‘‹ ğœ‡ğœƒğ‘;ğºğ‘“ T ğ‘“ğ‘‹ T ğ¹ğ‘“ T ğ¹ğ‘“T ğœƒğ‘ğ‘‹ T ğ¹ğ‘“;ğœƒğ‘ Tğºğ‘“ğ‘‹ T ğœƒğ‘T ğºğ‘“ğ‘‹ T ğœƒğ‘;ğºğ‘“ğ‘‹ commutes for each ğ‘“: ğ‘â†’ğ‘. â— For the T ğ‘’ M the lift of the premonoidal product ğ‘‡â‹Šâˆ’is once again just the operation that maps the circuit part of a computation ğ¶to ğ‘‡â‹Šğ¶. The only natural transformation we are interested in is the symmetry (as we are working in a strict premonoidal category), and the generalized unit for the symmetry ğ‘ is just the map ğ‘¥â†¦â†’(ğ‘¥,ğ‘ ).