All for One and One for All: Program Logics for Exploiting Internal Determinism in Parallel Programs Extended Version ALEXANDRE MOINE, New York University, USA SAM WESTRICK, New York University, USA JOSEPH TASSAROTTI, New York University, USA Nondeterminism makes parallel programs challenging to write and reason about. To avoid these challenges, researchers have developed techniques for internally deterministic parallel programming, in which the steps of a parallel computation proceed in a deterministic way. Internal determinism is useful because it lets a programmer reason about a program as if it executed in a sequential order. However, no verification framework exists to exploit this property and simplify formal reasoning about internally deterministic programs. To capture the essence of why internally deterministic programs should be easier to reason about, this paper defines a property called schedule-independent safety. A program satisfies schedule-independent safety, if, to show that the program is safe across all orderings, it suffices to show that one terminating execution of the program is safe. We then present a separation logic called Musketeer for proving that a program satisfies schedule-independent safety. Once a parallel program has been shown to satisfy schedule-independent safety, we can verify it with a new logic called Angelic, which allows one to dynamically select and verify just one sequential ordering of the program. Using Musketeer, we prove the soundness of MiniDet, an affine type system for enforcing internal deter- minism. MiniDet supports several core algorithmic primitives for internally deterministic programming that have been identified in the research literature, including a deterministic version of a concurrent hash set. Because any syntactically well-typed MiniDet program satisfies schedule-independent safety, we can apply Angelic to verify such programs. All results in this paper have been verified in Rocq using the Iris separation logic framework. CCS Concepts: â€¢ Theory of computation â†’Program verification; Separation logic; â€¢ Software and its engineering â†’Parallel programming languages. Additional Key Words and Phrases: program verification, separation logic, parallelism, determinism ACM Reference Format: Alexandre Moine, Sam Westrick, and Joseph Tassarotti. 2026. All for One and One for All: Program Logics for Exploiting Internal Determinism in Parallel Programs: Extended Version. Proc. ACM Program. Lang. 10, POPL, Article 26 (January 2026), 32 pages. https://doi.org/10.1145/3776668 1 Introduction One of the most challenging aspects of concurrent and parallel programming is dealing with nondeterminism. Nondeterminism complicates almost every aspect of trying to make programs correct. Bugs often arise because programmers struggle to reason about the set of all possible non- deterministic outcomes and interleavings. Finding those bugs becomes more difficult, as testing can only cover a subset of possible outcomes. Even when bugs are found, nondeterminism makes them Authorsâ€™ Contact Information: Alexandre Moine, alexandre.moine@nyu.edu, New York University, New York, USA; Sam Westrick, shw8119@nyu.edu, New York University, New York, USA; Joseph Tassarotti, jt4767@nyu.edu, New York University, New York, USA. This work is licensed under a Creative Commons Attribution 4.0 International License. Â© 2026 Copyright held by the owner/author(s). ACM 2475-1421/2026/1-ART26 https://doi.org/10.1145/3776668 Proc. ACM Program. Lang., Vol. 10, No. POPL, Article 26. Publication date: January 2026. arXiv:2511.23283v1 [cs.PL] 28 Nov 2025 26:2 Alexandre Moine, Sam Westrick, and Joseph Tassarotti harder to reproduce and debug. These challenges also extend to formal methods for such programs, where nondeterminism makes various analyses and verification techniques more complex. For these reasons, there has long been interest in methods for deterministic parallel programming. A range of algorithmic techniques [Blelloch et al. 2012], language designs [Blelloch et al. 1994; Kuper et al. 2014a], type systems [Bocchino Jr. et al. 2009], specialized operating systems and runtimes [Aviram et al. 2010], and various other approaches have been developed for making parallel programs deterministic. Researchers in this area have long noted that determinism is not simply a binary property, and in fact there is a spectrum of degrees of determinism. On one end of the spectrum is external determinism, which simply says that the input/output behavior of a program is deterministic. However, in an externally deterministic program, even if the final output is deterministic, the manner in which the computation takes place may be highly nondeterministic and vary across runs. As a result, external determinism does not eliminate all of the programming challenges associated with nondeterminism. For example, a programmer who attaches a debugger to an externally deterministic program may still see different internal behaviors across different runs, complicating efforts to understand the programâ€™s behavior. A stronger property, called internal determinism, requires in addition that the structure and internal steps of a computation are deterministic. More formally, in an internally deterministic program, for a given input, every execution will generate the same computation graph, a trace that captures the dependencies of operations and their results. With this strong form of determinism, we can reason about the programâ€™s behavior by considering any one sequential traversal of operations in the computation graph. This is useful, because as Blelloch et al. [2012] put it: In addition to returning deterministic results, internal determinism has many advan- tages including ease of reasoning about the code, ease of verifying correctness, ease of debugging, ease of defining invariants, ease of defining good coverage for testing, and ease of formally, informally and experimentally reasoning about performance. Although ensuring internal determinism might seem expensive, Blelloch et al. [2012] have shown that by using a core set of algorithmic techniques and building blocks, it is possible to develop fast and scalable internally deterministic algorithms for a range of benchmark problems. In this paper, we explore the meaning and benefits of internal determinism from the perspective of program verification. If one of the advantages of internal determinism is that it simplifies reasoning about programs, then it should be possible to exploit this property in the form of new reasoning rules in a program logic. To do so, we first define a property we call schedule-independent safety, which holds for a parallel program ğ‘’if, to verify that every execution of ğ‘’is safe (i.e. never triggers undefined behavior or a failing assert), it suffices to prove that at least one interleaving of operations in ğ‘’is terminating and safe. Internal determinism implies schedule-independent safety, and it is this property that makes reasoning about internally deterministic programs simpler. Schedule- independent safety recalls the motto of Dumasâ€™ Three Musketeers, â€œall for one and one for allâ€: the safety of all interleavings amounts to the safety of one of them. Building on this observation, we develop Musketeer, a separation logic for proving that a program satisfies schedule-independent safety. Although Musketeer is formulated as a unary program logic, schedule-independent safety is a âˆ€âˆ€hyperproperty [Clarkson and Schneider 2010], since it relates safety of any chosen execution of a program ğ‘’to all other executions of ğ‘’. Thus, to prove the soundness of Musketeer, we encode Musketeer triples into a new relational logic called ChainedLog. In contrast to most prior relational concurrent separation logics, which are restricted to âˆ€âˆƒhyperproperties, ChainedLog supports âˆ€âˆ€ hyperproperties using a judgement we call a chained triple. Proc. ACM Program. Lang., Vol. 10, No. POPL, Article 26. Publication date: January 2026. All for One and One for All: Program Logics for Exploiting Internal Determinism in Parallel Programs 26:3 Intuitively, the high-level reasoning rules of Musketeer restrict the user to verify only internally- deterministic programs. However, while internally deterministic programs always satisfy schedule- independent safety, the converse is false: a program may be nondeterministic because it observes actions from concurrent tasks, but it may do so without jeopardizing safety. In order to verify such programs (Â§7.2, Â§7.3), we use the fact that Musketeer is defined in terms of the more flexible and more complex ChainedLog, and drop down to this low-level logic to conduct the proof. We next explore how to exploit schedule-independent safety to simplify verification of programs. To that end, we present a logic called Angelic that allows one to angelically select and verify one sequential ordering of operations in a parallel program. Angelic is sound to apply to programs that satisfy schedule-independent safety because the safety and termination of the one ordering verified during the proof will imply safety for all other executions. This is in contrast to standard concurrent separation logics, in which one must consider all possible orderings during a proof. Using these logics, we verify a number of examples from the literature on internal determinism and related properties. First, we show how to use Musketeer to prove properties about language- based approaches for enforcing internal determinism. In particular, because Musketeer is a higher- order impredicative logic, Musketeer can encode logical relations models for type systems that are designed to enforce internal determinism. We start by applying this to a simple ownership-based affine type system we call MiniDet. The resulting logical relations model for MiniDet shows that every well-typed program satisfies schedule-independent safety. Next we use Musketeer to prove specifications for priority writes and deterministic concurrent hash sets, two of the core primitives that Blelloch et al. [2012] use in several of their examples of internally deterministic algorithms. Using these specifications, we extend MiniDet and its logical relations model with typing rules for priority writes and hash sets, showing that schedule-independent safety is preserved. Finally, putting these pieces together, we turn to parallel array deduplication, one of the example benchmark problems considered by Blelloch et al. [2012]. We first show that an implementation of the algorithm they propose for this problem can be syntactically-typed in MiniDet, thereby showing that it is schedule-independent safe. Next, we use Angelic to verify a correctness property for this algorithm. Although the algorithm is written using a parallel for-loop that does concurrent insertions into a hash set, by using Angelic, we can reason as if the parallel loop was a standard, sequential loop, thereby simplifying verification. Contributions. The contributions of this paper are the following: â€¢ We identify schedule-independent safety as a key property of deterministic parallel programs. â€¢ We present Musketeer, a separation logic for proving that a program satisfies schedule- independent safety, meant to be used as a tool for proving automatic approaches correct. â€¢ We present Angelic, a separation logic for proving that one interleaving safely terminates. â€¢ We use Musketeer to verify properties of MiniDet, an affine type system guaranteeing schedule-independent safety. â€¢ We verify that priority writes and a deterministic concurrent hash set satisfy schedule- independent safety using Musketeer, and then use this property to verify a deduplication algorithm using Angelic. â€¢ We formally verify all the presented results [Moine et al. 2025], including the soundness of the logics and the examples, in the Rocq prover using the Iris framework [Jung et al. 2018]. 2 Key Ideas In this section, we first give a simple motivating example (Â§2.1), describe some of the core concepts behind how Musketeer guarantees schedule-independent safety (Â§2.2), and conclude by showing some of the rules of Angelic that allow for reasoning sequentially about a parallel program (Â§2.3). Proc. ACM Program. Lang., Vol. 10, No. POPL, Article 26. Publication date: January 2026. 26:4 Alexandre Moine, Sam Westrick, and Joseph Tassarotti M-Assert {âŠ¤} assertğ‘£{ğœ†ğ‘¤_. âŒœğ‘¤= () âˆ§ğ‘£= trueâŒ} M-KSplit counterğ‘£(ğ‘1 + ğ‘2) (ğ‘–1 + ğ‘–2) âŠ£âŠ¢counterğ‘£ğ‘1 ğ‘–1 âˆ—counterğ‘£ğ‘2 ğ‘–2 M-KRef {âŠ¤} ref ğ‘–{ğœ†ğ‘£_. counterğ‘£1ğ‘–} M-KAdd {counterğ‘£ğ‘ğ‘–} atomic_addğ‘£ğ‘—{ğœ†_ _. counterğ‘£ğ‘(ğ‘–+ ğ‘—)} M-KGet {counterğ‘£1ğ‘–} getğ‘£{ğœ†ğ‘¤_. âŒœğ‘¤= ğ‘–âŒâˆ—counterğ‘£1ğ‘–} M-Par {ğ‘ƒ1} ğ‘’1 {ğ‘„1} {ğ‘ƒ2} ğ‘’2 {ğ‘„2} {ğ‘ƒ1 âˆ—ğ‘ƒ2} parğ‘’1 ğ‘’2 {ğœ†ğ‘£ğ‘¥. âˆƒğ‘£1 ğ‘£2 ğ‘¥1 ğ‘¥2. âŒœğ‘£= (ğ‘£1, ğ‘£2) âˆ§ğ‘¥= (ğ‘¥1,ğ‘¥2)âŒâˆ—ğ‘„1 ğ‘£1 ğ‘¥1 âˆ—ğ‘„2 ğ‘£2 ğ‘¥2} Fig. 1. Reasoning Rules for a Concurrent Counter and Key Reasoning Rules of Musketeer 2.1 A Motivating Example Our example program is named dumas and appears below: dumas â‰œ ğœ†ğ‘›. letğ‘Ÿ= ref 0 in par (ğœ†_. atomic_addğ‘Ÿ1802) (ğœ†_. atomic_addğ‘Ÿ42); assert (getğ‘Ÿ== ğ‘›) The dumas program takes an argument ğ‘›. It first allocates a reference ğ‘Ÿinitialized to 0, and then calls in parallel two closures, one that atomically adds 1802 to ğ‘Ÿ, and the other that atomically adds 42. After the parallel phase, the function asserts that the content of ğ‘Ÿis equal to ğ‘›. Imagine we wish to prove that (dumas 1844) is safeâ€”that is, for every interleaving, the program will never get stuck, and in particular the assertion will succeed. Of course, many existing concurrent separation logics can easily prove this. In such logics, one can use an invariant assertion to reason about the shared access to ğ‘Ÿby the two parallel threads. This invariant would ensure that, no matter which order the threads perform their additions, after both have finished ğ‘Ÿwill contain 1844. We propose an alternate approach that simplifies reasoning by exploiting the internal determinism in programs like dumas. In our approach, we first prove in a light-weight way that, for any given value of ğ‘›, the order of the parallel additions in (dumasğ‘›) does not affect the outcome of the assert. Then, to prove safety of (dumasğ‘›) for the specific value of ğ‘›= 1844, we can just pick one possible ordering and verify safety of that ordering. 2.2 Verifying Schedule-Independent Safety with Musketeer Our first contribution is Musketeer, a logic for proving that a program satisfies schedule-independent safety, i.e. that safety of any one complete execution implies safety of all possible executions. Although Musketeer is itself a program logic, we stress that Musketeer is not meant to be used directly. Rather, Musketeer is a kind of intermediate logic designed for proving the soundness of other light-weight, automatic approaches of ensuring schedule-independent safety such as type systems. For instance, our main case study focuses on using Musketeer to show the soundness of an affine type system guaranteeing schedule-independent safety (Â§7). Nevertheless, for the sake of explaining the ideas behind Musketeer, here we explain the reasoning rules that would allow one to verify manually the schedule-independent safety of (dumasğ‘›) for all ğ‘›. Key reasoning rules. Musketeer takes the form of a unary separation logic with triples written {ğ‘ƒ} ğ‘’{ğ‘„}, where ğ‘ƒis a precondition, ğ‘’the program being verified and ğ‘„the postcondition. The postcondition ğ‘„is of the form ğœ†ğ‘£ğ‘¥. ğ‘…, where ğ‘£is the value being returned by the execution of ğ‘’and ğ‘¥is a ghost return value. We explain ghost return values in detail later, but for now, they can be thought of as a special way to existentially quantify variables in the postcondition. This Proc. ACM Program. Lang., Vol. 10, No. POPL, Article 26. Publication date: January 2026. All for One and One for All: Program Logics for Exploiting Internal Determinism in Parallel Programs 26:5 Musketeer triple guarantees the following hyper-property: â€œif one execution of ğ‘’is safe starting from a heap satisfying ğ‘ƒand terminates, then every execution of ğ‘’is safe starting from a heap satisfying ğ‘ƒand all terminating executions will end in a heap satisfying ğ‘„â€. The upper part of Figure 1 shows the main reasoning rules we use for our example (in these rules, the horizontal bar is an implication in the meta-logic). While the assertions and rules of Musketeer are similar to standard separation logic rules, there are two key differences. First, Musketeer does not provide the usual disjunction or existential elimination rules from separation logic. That is, to prove a triple of the form {ğ‘ƒ1 âˆ¨ğ‘ƒ2} ğ‘’{ğ‘„}, we cannot in general do case analysis on the precondition and reduce this to proving {ğ‘ƒ1} ğ‘’{ğ‘„} and {ğ‘ƒ2} ğ‘’{ğ‘„}. As we will see later, this restriction is necessary because the imprecision in disjunctions and existentials can encode nondeterministic behavior, where different executions pick different witnesses. Second, unlike traditional separation logic rules, rules in Musketeer do not guarantee safety. Rather, they guarantee that safety is independent of scheduling. Thus, these rules often have weaker preconditions than standard separation logic rules. The rule M-Assert illustrates this unusual aspect of Musketeer. This rule applies to an expression assertğ‘£, for an arbitrary value ğ‘£, and has a trivial precondition. The postcondition has the pure facts that the return value ğ‘¤is () and that ğ‘£equals true, i.e. that the assert did not fail. In contrast, the standard separation logic rule for assertğ‘£requires the user to prove that ğ‘£= true! This is because the expression assertğ‘£is safe only if the value ğ‘£= true (Â§3.2). So in conventional separation logic, where a triple implies safety, the obligation is to show that the assert will be safe. However, in Musketeer, the rule M-Assert corresponds exactly to the â€œmottoâ€ of Musketeer triples: if one execution of assertğ‘£is safe and terminates with value ğ‘¤such that ğ‘¤= () and ğ‘£= true, then every execution of assertğ‘£is safe and terminates with value ğ‘¤= (), and ğ‘£= true in those executions too. This property is true in a trivial way: since the argument ğ‘£in assertğ‘£is already a value, there is only one possible safe execution for assertğ‘£, and such an execution is possible only if ğ‘£= true.1 On the contrary, M-Par has a standard shape. This rule allows for verifying the parallel primitive parğ‘’1 ğ‘’2. It requires the user to split the precondition into two parts ğ‘ƒ1 and ğ‘ƒ2, and to establish the two triples {ğ‘ƒ1} ğ‘’1 {ğ‘„1} and {ğ‘ƒ2} ğ‘’2 {ğ‘„2}. The postcondition of the rule asserts that the value ğ‘£ being returned is an immutable pair (ğ‘£1, ğ‘£2) and the ghost return value ğ‘¥is itself a pair of two ghost return values ğ‘¥1 and ğ‘¥2, such that ğ‘„ğ‘£1 ğ‘¥1 and ğ‘„ğ‘£2 ğ‘¥2 hold. Verifying dumas. The other rules in Figure 1 are the reasoning rules for the concurrent counter we use in dumas. They make use of a predicate counterğ‘£ğ‘ğ‘–, asserting that ğ‘£is a concurrent counter with fractional ownership ğ‘âˆˆ(0; 1]. When ğ‘= 1 the assertion represents exclusive ownership of the counter, in which case ğ‘–is the value stored in the counter. Otherwise, it asserts ownership of a partial share of the counter, and ğ‘–is the contribution added to the counter with this share. M-KSplit shows that counter can be split into several shares. M-KRef verifies ref ğ‘–, has a trivial precondition and returns a counter initialized to ğ‘–with fraction 1. M-KAdd verifies atomic_addğ‘£ğ‘—, where the share may have an arbitrary fraction. M-KGet verifies getğ‘£, requiring that counterğ‘£1ğ‘–holds. The fraction is 1, preventing a concurrent add to ğ‘£. Such a concurrent add would introduce nondeterminism based on the relative ordering of the add and get, thereby breaking schedule-independent safety. Using the above rules, we can show that for any ğ‘›, {âŠ¤} (dumasğ‘›) {ğœ†_ _. âŠ¤}, that is, without precondition, the safety of (dumasğ‘›) is scheduling independent. To do so, we use M-KRef to 1Note that Musketeer supports a bind rule (M-Bind, Figure 7) that allows the user to reason under an evaluation context. Hence, Musketeer supports reasoning on an expression (assertğ‘’), for an arbitrary expression ğ‘’. To conduct such a proof, the user should first apply M-Bind and focus on ğ‘’, show that ğ‘’itself satisfies schedule-independent safety, and then for any value ğ‘£to which ğ‘’may reduce, apply M-Assert on the remaining expression (assert ğ‘£). Proc. ACM Program. Lang., Vol. 10, No. POPL, Article 26. Publication date: January 2026. 26:6 Alexandre Moine, Sam Westrick, and Joseph Tassarotti âŠ¤âŠ¢run (assert true) {ğœ†ğ‘£. âŒœğ‘£= ()âŒ} A-Assert runğ‘’1 {ğœ†ğ‘£1. runğ‘’2 {ğœ†ğ‘£2.ğœ“(ğ‘£1, ğ‘£2)}} âŠ¢run (parğ‘’1 ğ‘’2) {ğœ“} A-ParSeqL runğ‘’2 {ğœ†ğ‘£2. runğ‘’1 {ğœ†ğ‘£1.ğœ“(ğ‘£1, ğ‘£2)}} âŠ¢run (parğ‘’1 ğ‘’2) {ğœ“} A-ParSeqR âŠ¤âŠ¢run (ref ğ‘–) {ğœ†ğ‘£. âˆƒâ„“. âŒœğ‘£= â„“âŒâˆ—â„“â†¦â†’ğ‘–} A-Ref â„“â†¦â†’ğ‘–âŠ¢run (atomic_addğ‘£ğ‘—) {ğœ†_. â„“â†¦â†’(ğ‘–+ ğ‘—)} A-Add â„“â†¦â†’ğ‘–âŠ¢run (get â„“) {ğœ†ğ‘£. âŒœğ‘£= ğ‘–âŒâˆ—â„“â†¦â†’ğ‘–} A-Get Fig. 2. Reasoning Rules for a Concurrent Counter and Key Reasoning Rules of Angelic initialize the counter, getting counterğ‘Ÿ1 0, which we split into counterğ‘Ÿ(1/2) 0 âˆ—counterğ‘Ÿ(1/2) 0, and then use M-Par. The counterğ‘Ÿ(1/2) 0 given to each thread is sufficient to reason about the add they each perform, and when we combine the shares they give back, we get counterğ‘Ÿ1 1844. Using M-KRef, we know that the getğ‘Ÿreturns 1844, leaving us to show {âŠ¤} assert (1844 == ğ‘›) {ğœ†_ _. âŠ¤}. At this point, we would get stuck in a standard separation logic proof, because the standard rule for assert would require us to prove that (1844 == ğ‘›) evaluates to true. However, that would only be the case if ğ‘›was in fact 1844. Instead, in Musketeer, we can use a rule showing that (1844 == ğ‘›) will evaluate to some Boolean ğ‘, regardless of what value ğ‘›is. At that point, we can use M-Assert to conclude, even though we donâ€™t know which value ğ‘will take. 2.3 Verifying That One Interleaving is Safe and Terminates with Angelic Now that we know that for all ğ‘›, (dumasğ‘›) satisfies schedule-independent safety, we can prove that (dumas 1844) is safe just by showing that one interleaving is safe and terminates. For such a simple example, it would suffice at this point to simply execute (dumas 1844) once and observe one safe, terminating execution. We would then be able to conclude that all possible executions are safe. However, for more complex examples (for example, programs that are parameterized by an argument from an infinite type), we propose Angelic, a program logic for verifying that one interleaving is safe and terminates. Angelic uses a form of weakest-precondition reasoning, with specifications taking the form ğœ‘âŠ¢runğ‘’{ğœ“}, where ğœ‘is the precondition, ğ‘’the program being verified, and ğœ“the postcondition, of the form ğœ†ğ‘£.ğœ‘â€², where ğ‘£is the value being returned. In order to guarantee termination, Angelicâ€™s WP is defined as a total weakest precondition, that is, the WP is defined as a least fixpoint and does not mention the so-called later modality. Such a construction is standard, Krebbers et al. [2025, Â§4] describes the differences between a WP for partial and total correctness. Hence, runğ‘’{ğœ†_. âŠ¤} guarantees that one execution of ğ‘’is safe and terminates. Figure 2 presents a few reasoning rules for Angelic. It is helpful to read these rules backwards, applying the rule to a goal that matches the right side of the turnstile âŠ¢and ending up with a goal of proving the left side. A-Assert verifies an assertion, for which the argument must be the Boolean true.2 Indeed, since Angelic guarantees safety, the proof burden is now to show that the assert will succeed. A-ParSeqL says that to verify parğ‘’1 ğ‘’2, it suffices to verify sequentially ğ‘’1 and then ğ‘’2. A-ParSeqR lets us verify the reverse order instead, reasoning first about ğ‘’2 and then ğ‘’1. As we will explain later on (Â§6.2), Angelic more generally allows for selecting any interleaving of steps within ğ‘’1 and ğ‘’2 by â€œjumpingâ€ between the two expressions during a proof. Finally, A-Ref, A-Add and A-Get shows how to reason on a concurrent counter. First, these rules do not involve any new predicate, and manipulate the plain points-to assertion linked with the counter. Second, no fractions or invariants are involved. Indeed, in Angelic, there is no need to split and join assertions, as the parallel primitive can be verified sequentially in any order. 2Angelic supports a bind rule (A-Bind, Figure 11). As in Musketeer, A-Bind allows for reasoning under an evaluation context. In combination with A-Assert, the user may reason about an expression (assertğ‘’) for an arbitrary expression ğ‘’. Proc. ACM Program. Lang., Vol. 10, No. POPL, Article 26. Publication date: January 2026. All for One and One for All: Program Logics for Exploiting Internal Determinism in Parallel Programs 26:7 Values V ğ‘£::= () | ğ‘âˆˆ{true, false} | ğ‘–âˆˆZ | â„“âˆˆL | (ğ‘£, ğ‘£) | Ë†ğœ‡ğ‘“ğ‘¥.ğ‘’ Primitives âŠ²âŠ³::= + | âˆ’| Ã— | Ã· | mod | == | < | â‰¤| > | â‰¥| âˆ¨| âˆ§ Expressions ğ‘’::= ğ‘£,ğ‘¤ value ğ‘¥ variable letğ‘¥= ğ‘’inğ‘’ sequencing if ğ‘’thenğ‘’elseğ‘’ conditional ğœ‡ğ‘“ğ‘¥.ğ‘’ abstraction ğ‘’ğ‘’ call ğ‘’âŠ²âŠ³ğ‘’ primitive operation prodğ‘’ğ‘’ product projğ‘˜âˆˆ{1,2} ğ‘’ projections assertğ‘’ assertion alloc ğ‘’ array allocation ğ‘’[ğ‘’] array load ğ‘’[ğ‘’] â†ğ‘’ array store lengthğ‘’ array length parğ‘’ğ‘’ parallelism ğ‘’|| ğ‘’ active parallel tuple CASğ‘’ğ‘’ğ‘’ğ‘’ compare-and-swap Contexts ğ¾::= letğ‘¥= â–¡inğ‘’ | if â–¡thenğ‘’elseğ‘’ | alloc â–¡ | length â–¡ | assert â–¡ | ğ‘’[â–¡] | â–¡[ğ‘£] | ğ‘’[ğ‘’] â†â–¡ | ğ‘’[â–¡] â†ğ‘£ | â–¡[ğ‘£] â†ğ‘£ | ğ‘’âŠ²âŠ³â–¡ | â–¡âŠ²âŠ³ğ‘£ | ğ‘’â–¡ | â–¡ğ‘£ | CASğ‘’ğ‘’ğ‘’â–¡ | CASğ‘’ğ‘’â–¡ğ‘£ | CASğ‘’â–¡ğ‘£ğ‘£ | CAS â–¡ğ‘£ğ‘£ğ‘£ | prodğ‘’â–¡ | prod â–¡ğ‘£ | projğ‘˜â–¡ Fig. 3. Syntax of MusketLang Using these rules, we can verify that âŠ¢run (dumas 1844) {ğœ†_. âŠ¤} holds, which implies that there exists one interleaving that is safe and terminates. Combined with the fact that this program has schedule-independent safety, we conclude that (dumas 1844) is always safe. 3 Syntax and Semantics MusketLang is a call-by-value lambda calculus with mutable state and parallelism. We first present its syntax (Â§3.1) and then its semantics (Â§3.2). MusketLang is similar to HeapLang, the language that ships with Iris, except that it implements structured parallelism instead of fork-based concurrency. 3.1 Syntax Figure 3 presents the syntax of MusketLang. A value ğ‘£âˆˆV is either the unit value (), a Boolean ğ‘âˆˆ {true, false}, an idealized integer ğ‘–âˆˆZ, a location â„“from an infinite set of locations L, an immutable product (ğ‘£1, ğ‘£2) of two values, or a recursive function Ë†ğœ‡ğ‘“ğ‘¥.ğ‘’. An expression ğ‘’describe a computation in MusketLang. Recursive functions are written ğœ‡ğ‘“ğ‘¥.ğ‘’. For non-recursive functions, we write ğœ†ğ‘¥.ğ‘’â‰œğœ‡_ğ‘¥.ğ‘’. We define functions with multiple arguments as a chain of function constructors. Mutable state is available through arrays. Parallelism is available through a primitive parğ‘’1 ğ‘’2, which evaluates to an active parallel tuple ğ‘’1 || ğ‘’2. Such a tuple evaluates the two expressions in parallel and returns their result as an immutable product. MusketLang also has a primitive compare-and-swap instruction CASğ‘’1 ğ‘’2 ğ‘’3 ğ‘’4, which targets an array entry and has 4 parameters: the array location, the offset into the array, the old value and the new value. References are defined as arrays of size 1 with the following operations: ref â‰œğœ†ğ‘¥. letğ‘Ÿ= alloc 1 inğ‘Ÿ[0] â†ğ‘¥; ğ‘Ÿ get â‰œğœ†ğ‘Ÿ.ğ‘Ÿ[0] set â‰œğœ†ğ‘Ÿğ‘£.ğ‘Ÿ[0] â†ğ‘£ An evaluation context ğ¾describes an expression with a hole â–¡and dictates the right-to-left evaluation order of MusketLang. 3.2 Semantics Figure 4 presents the head reduction relation ğ‘’\ğœ head âˆ’âˆ’âˆ’â†’ğ‘’â€² \ğœâ€², describing a single step of expres- sion ğ‘’with store ğœinto expression ğ‘’â€² and store ğœâ€². A store is a map from location to arrays, modeled as a list of values. We write âˆ…for the empty store and ğœ(â„“) for the list of values at location â„“in ğœ. To insert or update a location â„“with array Â®ğ‘£in store ğœ, we write [â„“:= Â®ğ‘£]ğœ, and similarly write Proc. ACM Program. Lang., Vol. 10, No. POPL, Article 26. Publication date: January 2026. 26:8 Alexandre Moine, Sam Westrick, and Joseph Tassarotti HeadIfTrue if true thenğ‘’1 elseğ‘’2 \ğœ head âˆ’âˆ’âˆ’âˆ’â†’ğ‘’1 \ğœ HeadIfFalse if false thenğ‘’1 elseğ‘’2 \ğœ head âˆ’âˆ’âˆ’âˆ’â†’ğ‘’2 \ğœ HeadCallPrim ğ‘£1 âŠ²âŠ³ğ‘£2 pure âˆ’âˆ’âˆ’â†’ğ‘£ ğ‘£1 âŠ²âŠ³ğ‘£2 \ğœ head âˆ’âˆ’âˆ’âˆ’â†’ğ‘£\ğœ HeadAbs ğœ‡ğ‘“ğ‘¥.ğ‘’\ğœ head âˆ’âˆ’âˆ’âˆ’â†’Ë†ğœ‡ğ‘“ğ‘¥.ğ‘’\ğœ HeadLetVal letğ‘¥= ğ‘£inğ‘’\ğœ head âˆ’âˆ’âˆ’âˆ’â†’[ğ‘£/ğ‘¥]ğ‘’\ğœ HeadAlloc 0 â‰¤ğ‘– â„“âˆ‰dom(ğœ) alloc ğ‘–\ğœ head âˆ’âˆ’âˆ’âˆ’â†’â„“\ [â„“:= ()ğ‘–]ğœ HeadLoad ğœ(â„“) = Â®ğ‘¤ 0 â‰¤ğ‘–< | Â®ğ‘¤| Â®ğ‘¤(ğ‘–) = ğ‘£ â„“[ğ‘–] \ğœ head âˆ’âˆ’âˆ’âˆ’â†’ğ‘£\ğœ HeadStore ğœ(â„“) = Â®ğ‘¤ 0 â‰¤ğ‘–< | Â®ğ‘¤| â„“[ğ‘–] â†ğ‘£\ğœ head âˆ’âˆ’âˆ’âˆ’â†’() \ [â„“:= [ğ‘–:= ğ‘£] Â®ğ‘¤]ğœ HeadAssert assert true \ğœ head âˆ’âˆ’âˆ’âˆ’â†’() \ğœ HeadProduct prodğ‘£1 ğ‘£2 \ğœ head âˆ’âˆ’âˆ’âˆ’â†’(ğ‘£1, ğ‘£2) \ğœ HeadProj ğ‘˜âˆˆ{1; 2} projğ‘˜(ğ‘£1, ğ‘£2) \ğœ head âˆ’âˆ’âˆ’âˆ’â†’ğ‘£ğ‘˜\ğœ HeadLength ğœ(â„“) = Â®ğ‘¤ ğ‘–= | Â®ğ‘¤| length â„“\ğœ head âˆ’âˆ’âˆ’âˆ’â†’ğ‘–\ğœ HeadCASSucc ğœ(â„“) = Â®ğ‘¤ 0 â‰¤ğ‘–< | Â®ğ‘¤| Â®ğ‘¤(ğ‘–) = ğ‘£ CAS â„“ğ‘–ğ‘£ğ‘£â€² \ğœ head âˆ’âˆ’âˆ’âˆ’â†’true \ [â„“:= [ğ‘–:= ğ‘£â€²] Â®ğ‘¤]ğœ HeadCASFail ğœ(â„“) = Â®ğ‘¤ 0 â‰¤ğ‘–< | Â®ğ‘¤| Â®ğ‘¤(ğ‘–) = ğ‘£0 ğ‘£0 â‰ ğ‘£ CAS â„“ğ‘–ğ‘£ğ‘£â€² \ğœ head âˆ’âˆ’âˆ’âˆ’â†’false \ğœ HeadCall ( Ë†ğœ‡ğ‘“ğ‘¥.ğ‘’) ğ‘£\ğœ head âˆ’âˆ’âˆ’âˆ’â†’[( Ë†ğœ‡ğ‘“ğ‘¥.ğ‘’)/ğ‘“][ğ‘¥/ğ‘£]ğ‘’\ğœ HeadFork parğ‘’1 ğ‘’2 \ğœ head âˆ’âˆ’âˆ’âˆ’â†’ğ‘’1 || ğ‘’2 \ğœ HeadJoin ğ‘£1 || ğ‘£2 \ğœ head âˆ’âˆ’âˆ’âˆ’â†’(ğ‘£1, ğ‘£2) \ğœ Fig. 4. Head Reduction Relation StepHead ğ‘’\ğœ head âˆ’âˆ’âˆ’âˆ’â†’ğ‘’â€² \ğœâ€² ğ‘’\ğœâˆ’â†’ğ‘’â€² \ğœâ€² StepCtx ğ‘’\ğœâˆ’â†’ğ‘’â€² \ğœâ€² ğ¾âŸ¨ğ‘’âŸ©\ğœâˆ’â†’ğ¾âŸ¨ğ‘’â€²âŸ©\ğœâ€² StepParL ğ‘’1 \ğœâˆ’â†’ğ‘’â€² 1 \ğœâ€² ğ‘’1 || ğ‘’2 \ğœâˆ’â†’ğ‘’â€² 1 || ğ‘’2 \ğœâ€² StepParR ğ‘’2 \ğœâˆ’â†’ğ‘’â€² 2 \ğœâ€² ğ‘’1 || ğ‘’2 \ğœâˆ’â†’ğ‘’1 || ğ‘’â€² 2 \ğœâ€² Fig. 5. Main Reduction Relation [ğ‘–:= ğ‘¤]Â®ğ‘£to update offset ğ‘–with value ğ‘¤in array Â®ğ‘£. The length of an array Â®ğ‘£is written as |Â®ğ‘£|, and ğ‘£ğ‘– represents an array of size ğ‘–initialized with value ğ‘£. Most of the reduction rules are standard. For example, HeadAlloc allocates an array initialized with the unit value and returns its location, which is selected nondeterministically. HeadLoad and HeadStore perform loads and stores, respectively. HeadCASSucc and HeadCASFail performs an atomic compare-and-swap at an offset in an array. HeadAssert reduces an assert statement to a unit if the asserted value is true; asserts of false are stuck expressions. HeadFork performs a fork, converting a primitive par operation into an active parallel tuple. HeadJoin takes an active parallel tuple where both sides have reached a value and converts it into an immutable product. Figure 5 presents the main reduction relation ğ‘’\ğœâˆ’â†’ğ‘’â€² \ğœâ€², describing a parallel step of computation, potentially under an evaluation context. StepHead performs a head step. StepCtx performs a computation step under an evaluation context. StepParL and StepParR implement parallelism: these two rules allow for the main reduction relation to perform nondeterministically a step to the left or right side of an active parallel tuple, respectively. We write the reflexive-transitive closure of the reduction relation as ğ‘’\ğœâˆ’â†’âˆ—ğ‘’â€² \ğœâ€². Proc. ACM Program. Lang., Vol. 10, No. POPL, Article 26. Publication date: January 2026. All for One and One for All: Program Logics for Exploiting Internal Determinism in Parallel Programs 26:9 RedHead ğ‘’\ğœ head âˆ’âˆ’âˆ’âˆ’â†’ğ‘’â€² \ğœâ€² Redğ‘’ğœ RedCtx Redğ‘’ğœ Red (ğ¾âŸ¨ğ‘’âŸ©) ğœ RedPar ğ‘’1 âˆ‰V âˆ¨ğ‘’2 âˆ‰V ğ‘’1 âˆ‰V =â‡’Redğ‘’1 ğœ ğ‘’2 âˆ‰V =â‡’Redğ‘’2 ğœ Red (ğ‘’1 || ğ‘’2) ğœ Notstuckğ‘’ğœâ‰œğ‘’âˆˆV âˆ¨Redğ‘’ğœ Safeğ‘’â‰œâˆ€ğ‘’â€² ğœâ€². (ğ‘’\ âˆ…âˆ’â†’âˆ—ğ‘’â€² \ğœâ€²) =â‡’Notstuckğ‘’â€² ğœâ€² SISafety ğ‘’â‰œâˆ€ğ‘£ğœ. (ğ‘’\ âˆ…âˆ’â†’âˆ—ğ‘£\ğœ) =â‡’Safeğ‘’ Fig. 6. Definition of the Red, Notstuck, Safe, and SISafety Predicates 4 A Separation Logic for Proving Schedule-Independent Safety In this section, we present Musketeer in more detail. First, we define schedule-independent safety (Â§4.1). Next, we introduce our notations for triples and assertions (Â§4.2) and then present the reasoning rules of Musketeer (Â§4.3). We conclude with one of the main technical challenges in working with Musketeer, the absence of a rule for eliminating existentials, and explain how we overcame this with the novel concept of ghost return values (Â§4.4). 4.1 Definition of Schedule-Independent Safety Let us make formal the definition of schedule-independent safety, that is, the property guaranteeing our motto â€œif one execution of ğ‘’is safe and terminates, then every execution of ğ‘’is safeâ€. What does it mean for a parallel program to be safe? We say that the configuration ğ‘’\ğœis not stuck if either ğ‘’is a value, or every parallel task in ğ‘’that has not reached a value can take a stepâ€”in the latter case, we call the configuration reducible. A program is defined to be safe if every configuration it can reach is not stuck. In particular, if a program ğ‘’is safe, then no assertion in ğ‘’can fail, since an assert of a false value is not reducible. Figure 6 gives the formal definitions. The upper part of Figure 6 defines the property Redğ‘’ğœ, asserting that the configuration ğ‘’\ğœis reducible. RedHead asserts that if ğ‘’can take a head step, then it is reducible. RedCtx asserts that the reducibility of an expression ğ¾âŸ¨ğ‘’âŸ©follows from reducibility of ğ‘’. RedPar asserts that an active parallel tuple ğ‘’1 || ğ‘’2 is reducible if at least one sub-expression is not a value (otherwise, a join is possible), and each sub-expression that is not a value is reducible. The lower part of Figure 6 asserts that the property Notstuckğ‘’ğœholds if and only if either ğ‘’is a value or Redğ‘’ğœholds. Then, Safeğ‘’says that if ğ‘’\ âˆ…can reach ğ‘’â€² \ğœâ€² in zero or more steps, then Notstuckğ‘’â€² ğœâ€². Finally, the main property SISafety ğ‘’, asserting that the safety of ğ‘’ is schedule-independent, is defined. The property says that if some execution of ğ‘’reaches a value ğ‘£, then ğ‘’is safe. The soundness Theorem 4.1 of Musketeer guarantees that, for a verified program ğ‘’, the property SISafety ğ‘’holds. 4.2 Triples and Assertions As we saw, Musketeer is a separation logic whose main judgement takes the form of a triple {ğ‘ƒ} ğ‘’{ğ‘„}. In this triple, ğ‘ƒis the precondition, ğ‘’the program being verified, and ğ‘„the postcondition. The postcondition is of the form ğœ†ğ‘£ğ‘¥. ğ‘ƒâ€², where ğ‘£is the value being returned by the execution of ğ‘’and ğ‘¥is a ghost return value returned by the verification of ğ‘’. Both ğ‘ƒand ğ‘ƒâ€² are separation logic assertions, and can be understood as heap predicates: they describe the content of a heap. We write ğ‘ƒâˆ—ğ‘ƒâ€² for the separating conjunction, ğ‘ƒâˆ’âˆ—ğ‘ƒâ€² for the separating implication and âŒœğ‘ƒâŒwhen the property ğ‘ƒholds in the meta-logic (i.e. Rocq). Musketeer offers fractional [Bornat et al. 2005; Boyland 2003] points-to assertions â„“â†¦â†’ğ‘Â®ğ‘£. This assertion says that the location â„“points to the array Â®ğ‘£with fraction ğ‘âˆˆ(0; 1]. When ğ‘= 1 we simply write â„“â†¦â†’Â®ğ‘£. We use the term vProp for the type of assertions that can be used in Musketeer pre/post-conditions. Proc. ACM Program. Lang., Vol. 10, No. POPL, Article 26. Publication date: January 2026. 26:10 Alexandre Moine, Sam Westrick, and Joseph Tassarotti M-If ( ğ‘£= true =â‡’{ğ‘ƒ} ğ‘’1 {ğ‘„} ) ( ğ‘£= false =â‡’{ğ‘ƒ} ğ‘’2 {ğ‘„} ) {ğ‘ƒ} if ğ‘£thenğ‘’1 elseğ‘’2 {ğ‘„} M-Conseq ğ‘ƒâˆ’âˆ—ğ‘ƒâ€² {ğ‘ƒâ€²} ğ‘’{ğ‘„â€²} âˆ€ğ‘£ğ‘¥. ğ‘„ğ‘£ğ‘¥âˆ’âˆ—ğ‘„â€² ğ‘£ğ‘¥ {ğ‘ƒ} ğ‘’{ğ‘„} M-Val ğ‘ƒâˆ’âˆ—ğ‘„ğ‘£ğ‘¥ {ğ‘ƒ} ğ‘£{ğ‘„} M-Alloc {âŠ¤} alloc ğ‘¤{ğœ†ğ‘£(â„“,ğ‘–). âŒœğ‘£= â„“âˆ§ğ‘¤= ğ‘–âˆ§0 â‰¤ğ‘–âŒâˆ—â„“â†¦â†’()ğ‘–} M-Load {â„“â†¦â†’ğ‘Â®ğ‘£} â„“[ğ‘¤] {ğœ†ğ‘£â€² ğ‘–. âŒœğ‘¤= ğ‘–âˆ§0 â‰¤ğ‘–< |Â®ğ‘£| âˆ§Â®ğ‘£(ğ‘–) = ğ‘£â€²âŒâˆ—â„“â†¦â†’ğ‘Â®ğ‘£} M-Store {â„“â†¦â†’Â®ğ‘£} â„“[ğ‘¤] â†ğ‘£â€² {ğœ†ğ‘£â€²â€² ğ‘–. âŒœğ‘£â€²â€² = () âˆ§ğ‘¤= ğ‘–âˆ§0 â‰¤ğ‘–< |Â®ğ‘£|âŒâˆ—â„“â†¦â†’[ğ‘–:= ğ‘£â€²]Â®ğ‘£} M-Bind {ğ‘ƒ} ğ‘’{ğœ†ğ‘£ğ‘¥. ğ‘„â€² ğ‘£ğ‘¥} âˆ€ğ‘£ğ‘¥. {ğ‘„â€² ğ‘£ğ‘¥} ğ¾âŸ¨ğ‘£âŸ©{ğ‘„} {ğ‘ƒ} ğ¾âŸ¨ğ‘’âŸ©{ğ‘„} M-Frame {ğ‘ƒ} ğ‘’{ğ‘„} {ğ‘ƒâˆ—ğ‘ƒâ€²} ğ‘’{ğœ†ğ‘£ğ‘¥. ğ‘„ğ‘£ğ‘¥âˆ—ğ‘ƒâ€²} Fig. 7. Selected Reasoning Rules of Musketeer (extends Figure 1) As described before, the Musketeer triple {ğ‘ƒ} ğ‘’{ğ‘„} can be intuitively read as implying the following hyper-property: â€œif one execution of ğ‘’is safe starting from a heap satisfying ğ‘ƒand terminates, then every execution of ğ‘’is safe starting from a heap satisfying ğ‘ƒand all terminating executions will end in a heap satisfying ğ‘„â€. If ğ‘ƒand ğ‘„are trivial, then this implies the SISafety property. This is captured formally in the soundness theorem of the logic. Theorem 4.1 (Soundness of Musketeer). If {âŠ¤} ğ‘’{ğœ†_ _. âŠ¤} holds, then SISafety ğ‘’holds. At first, this soundness theorem might seem weak, since it focuses on safety of all executions. What if we instead want to show that every terminating execution satisfies a stronger postcondi- tion ğ‘„? In general, Theorem 4.1 does not directly imply such a stronger property, but recall that in MusketLang, safety implies that no assert fails. Thus, by annotating a program with appropriate assert statements, we can encode various specifications in terms of safety. We illustrated this aspect in our dumas example (Â§2.1), where safety implied that the return value across all executions would equal a particular number. Although Musketeer is a unary logic with judgements referring to a single program ğ‘’, the above statement reveals that the judgements are relating together multiple executions of that program. To make this work, under the hood, Musketeerâ€™s vProp assertions describe not one but two heaps, corresponding to two executions of the program. This has ramifications for some proof rules (Â§4.4). Later, we will see how vProp assertions can be encoded into assertions in a relational logic that makes these two different heaps more explicit. 4.3 Reasoning Rules for Musketeer Figure 7 presents selected reasoning rules of Musketeer. Recall that because Musketeer triples do not imply safety, these rules differ from familiar separation logic rules. We have previously seen this in the rule M-Assert. A similar phenomenon happens in M-If, which targets the expression if ğ‘£thenğ‘’1 elseğ‘’2. In standard separation logic, one must prove that ğ‘£is a Boolean, since otherwise the if-statement would get stuck. However, in M-If, the user does not have to prove that ğ‘£is a Boolean. Instead, the rule requires the user to verify the two sides of the if-statement under the hypothesis that ğ‘£was the Boolean associated with the branch. M-Alloc, M-Load and M-Store are similar to their standard separation logic counterparts, except that they do not require the user to show that the allocation size or the loaded or stored offset are valid integers. M-Alloc targets the expression alloc ğ‘¤and has a trivial pre-condition. The postcondition asserts that the value being returned is a location â„“and that ğ‘¤is a non-negative integerâ€“recall that we can think of the ghost return value (â„“,ğ‘–) as if it were just a special way of Proc. ACM Program. Lang., Vol. 10, No. POPL, Article 26. Publication date: January 2026. All for One and One for All: Program Logics for Exploiting Internal Determinism in Parallel Programs 26:11 existentially quantifying the variables â„“and ğ‘–in the postcondition. The postcondition additionally contains the points-to assertion â„“â†¦â†’()ğ‘–asserting that â„“points to the array of size ğ‘–initialized with the unit value. M-Load and M-Store follow the same pattern. M-Alloc might surprise the reader, since based on the interpretation of triples we described above, the postcondition seems to imply that every execution of the allocation will return the same location â„“. Yet allocation in MusketLang is not deterministic. The resolution of this seeming contra- diction, is that because MusketLang does not allow for â€œconstructingâ€ a location (e.g. transforming an integer into a location), there is no way for the program to observe the nondeterminism of allocations. Hence, from the reasoning point-of-view we can conduct the proof as if allocations were made deterministically. This subtlety will appear in the model of Musketeer (Â§5.2). M-Bind allows for reasoning under a context, and is very similar to the standard separation logic Bind rule, except that in the second premise, we quantify over not just the possible return values ğ‘£, but also the ghost return value ğ‘¥. M-Val allows for concluding a proof about a value, allowing the user of the rule to pick an arbitrary ghost return value ğ‘¥. M-Frame shows that Musketeer supports framing. M-Conseq is the consequence rule of Musketeer: it allows for weakening the precondition and strengthening the postcondition. 4.4 Existential Reasoning with Ghost Return Values In separation logic, existential quantification is essential for modularity. Among other things, it allows for concealing intermediate pointers behind an abstraction barrier. To see how this is typically done, let us consider an example making use of the following indirection function that creates a reference to a reference: indirection â‰œğœ†ğ‘£. ref (ref ğ‘£) Without using ghost return value, a possible specification for indirectionğ‘£would be: {âŠ¤} indirectionğ‘£{ğœ†ğ‘¤_. âˆƒâ„“. âŒœğ‘¤= â„“âŒâˆ—âˆƒâ„“â€². â„“â†¦â†’[â„“â€²] âˆ—â„“â€² â†¦â†’[ğ‘£]} In the above specification, the first existential quantification on â„“does not hide or abstract over anything, since the returned value ğ‘¤uniquely characterizes â„“. However, the existential quantifica- tion on â„“â€² is more interesting, as it forms an abstraction barrier: it hides this intermediate location. Let us now focus on a client of indirection, and try to verify the following triple: {âŠ¤} get (indirectionğ‘£) {ğœ†_ _. âŠ¤} Making use of M-Bind and then applying the above specification for indirection, we obtain: {âˆƒâ„“. âŒœğ‘¤= â„“âŒâˆ—âˆƒâ„“â€². â„“â†¦â†’[â„“â€²] âˆ—â„“â€² â†¦â†’[ğ‘£]} getğ‘¤{ğœ†_ _. âŠ¤} (intermediate) We now need to eliminate the existentials on â„“and â„“â€² in the precondition by introducing universally- quantified variables in the meta-logic. More precisely, we would like to apply the following standard separation logic rule: âˆ€ğ‘¥. {ğ‘ƒğ‘¥} ğ‘’{ğ‘„} {âˆƒğ‘¥. ğ‘ƒğ‘¥} ğ‘’{ğ‘„} However, Musketeer does not support this rule. Indeed, although Musketeer is formulated as a unary logic, it relates two executions of the same program. As we previously alluded to (Â§4.2), Musketeerâ€™s vProp assertions are, under the hood, tracking not one, but two heaps: one for each execution of the same program. The fact that preconditions describe two heaps implies that the precondition âˆƒğ‘¥. ğ‘ƒğ‘¥has two interpretationsâ€”one for each heap of the two executions of ğ‘’being tracked by the triple. Although the precondition holds in both heaps, the witness ğ‘¥might differ between the two. Proc. ACM Program. Lang., Vol. 10, No. POPL, Article 26. Publication date: January 2026. 26:12 Alexandre Moine, Sam Westrick, and Joseph Tassarotti Whereas, in the premise of the above rule, quantifying over ğ‘¥at the meta-level means that ğ‘¥is treated as the same in both executions. We present a detailed example of such a case in Appendix A. As a result, Musketeer only supports the weaker rule M-ElimExist, allowing an existential to be eliminated when the precondition guarantees that the witness is unique. M-ElimExist (âˆ€ğ‘¥. ğ‘ƒğ‘¥âˆ’âˆ—âŒœğ‘ˆğ‘¥âŒ) (âˆ€ğ‘¥ğ‘¦.ğ‘ˆğ‘¥âˆ§ğ‘ˆğ‘¦=â‡’ğ‘¥= ğ‘¦) (âˆ€ğ‘¥. {ğ‘ƒğ‘¥} ğ‘’{ğ‘„}) {âˆƒğ‘¥. ğ‘ƒğ‘¥} ğ‘’{ğ‘„} For example, in the above intermediate triple, M-ElimExist would allow to eliminate the quantification on â„“, since it is uniquely characterized by ğ‘¤. However, M-ElimExist is tedious to use in practice. Moreover, sometimes objects are not uniquely characterized by the precondition, and yet are chosen deterministically, so that the witnesses ought to be the same in both executions. For example, in the above intermediate triple, M-ElimExist cannot be used to eliminate the quantification on â„“â€². To solve this issue, we introduce ghost return values. In a Musketeer triple {ğ‘ƒ} ğ‘’{ğœ†ğ‘£ğ‘¥. ğ‘„ğ‘£ğ‘¥}, the ghost return value ğ‘¥is an object (of an arbitrary type, which is formally a parameter of the triple) that will eventually be chosen by the user when they apply M-Val. We think of the bound variable ğ‘¥ as if it were existentially quantified, but the key is that the eventual â€œwitnessâ€ selected when using M-Val will be the same across the two executions under consideration. As a result, instead of having to use the weak M-ElimExist to eliminate ğ‘¥, the ghost return value is automatically eliminated in a strong way by M-Bind. Let us go back to our indirection example. We prove a specification for indirection in which â„“â€² is bound in a ghost return value, instead of as an existential: {âŠ¤} indirectionğ‘£{ğœ†ğ‘£â„“â€². âˆƒâ„“. âŒœğ‘£= â„“âŒâˆ—â„“â†¦â†’[â„“â€²] âˆ—â„“â€² â†¦â†’[ğ‘£]} As we use this specification to reason about (get (indirectionğ‘£)), M-Bind will eliminate â„“â€² auto- matically, and we can use M-ElimExist to eliminate â„“, reducing the proof to: {â„“â†¦â†’[â„“â€²] âˆ—â„“â€² â†¦â†’[ğ‘£]} get â„“{ğœ†_ _. âŠ¤} allowing us to proceed and conclude, since there is no longer an existential to eliminate. We extensively use ghost return values for the verification of MiniDet, our case study (Â§7). For instance, we use a ghost return value to record the content of references in the typing environment. 5 Unchaining the Reasoning with Chained Triples For an expression ğ‘’, a Musketeer triple guarantees the property â€œif one execution of ğ‘’is safe and terminates, then every execution of ğ‘’is safeâ€. In order to justify the validity of the reasoning rules for Musketeer triples, we generalize the above property and define an intermediate logic called ChainedLog which targets two expressions ğ‘’ğ‘™and ğ‘’ğ‘Ÿand guarantees the property â€œif one execution of ğ‘’ğ‘™is safe and terminates, then every execution of ğ‘’ğ‘Ÿis safeâ€. We first present chained triples (Â§5.1) and present some associated reasoning rules (Â§5.2). Finally, we explain how we encode Musketeer triples using chained triples (Â§5.3). 5.1 Chained Triples as a Generalization of Musketeer Triples In ChainedLog, a chained triple takes the form: {ğœ‘ğ‘™} ğ‘’ğ‘™{ğœ“ğ‘™| ğœ‘ğ‘Ÿ} ğ‘’ğ‘Ÿ{ğœ“ğ‘Ÿ} The assertions ğœ‘ğ‘™and ğœ‘ğ‘Ÿare the preconditions of ğ‘’ğ‘™and ğ‘’ğ‘Ÿ, respectively. The assertionsğœ“ğ‘™andğœ“ğ‘Ÿare both of the form ğœ†ğ‘£.ğœ‘, where ğ‘£is a return value, and are the postconditions of ğ‘’ğ‘™and ğ‘’ğ‘Ÿ, respectively. Intuitively, the above chained triple says that, if there exists a reduction of ğ‘’ğ‘™starting from a heap Proc. ACM Program. Lang., Vol. 10, No. POPL, Article 26. Publication date: January 2026. All for One and One for All: Program Logics for Exploiting Internal Determinism in Parallel Programs 26:13 satisfying ğœ‘ğ‘™, that is safe and terminates on a final heap with a value ğ‘£ğ‘™satisfying ğœ“ğ‘™ğ‘£ğ‘™, then every reduction of ğ‘’ğ‘Ÿstarting from a heap satisfying ğœ‘ğ‘Ÿis safe and if it terminates, it does so on a final heap with a value ğ‘£ğ‘Ÿsatisfying ğœ“ğ‘Ÿğ‘£ğ‘Ÿ. Moreover, chained triples guarantee determinism (for simplicity, see our commentary of C-Par), that is, ğ‘£ğ‘™= ğ‘£ğ‘Ÿ. Formally, we have the following soundness theorem: Theorem 5.1 (Soundness of Chained Triples). If {âŠ¤} ğ‘’1 {_. âŠ¤| âŠ¤} ğ‘’2 {ğœ†_. âŠ¤} holds, and if there exists a value ğ‘£and a store ğœsuch that ğ‘’1 \ âˆ…âˆ’â†’âˆ—ğ‘£\ğœ, then for every ğ‘’â€² and ğœâ€² such that ğ‘’2 \ âˆ…âˆ’â†’âˆ—ğ‘’â€² \ğœâ€², the property Safeğ‘’â€²ğœâ€² holds. In particular, chained triples do not guarantee safety for ğ‘’ğ‘™, but they do guarantee safety for ğ‘’ğ‘Ÿ. We call the triples â€œchainedâ€ because enjoy the following rule that allows us to chain facts from one execution to the other: C-Chain {ğœ‘ğ‘™} ğ‘’ğ‘™{ğœ†ğ‘£ğ‘™.ğœ“ğ‘™ğ‘£ğ‘™âˆ—ğœ‘| ğœ‘ğ‘Ÿ} ğ‘’ğ‘Ÿ{ğœ†ğ‘£ğ‘Ÿ.ğœ“ğ‘Ÿ} {ğœ‘ğ‘™} ğ‘’ğ‘™{ğœ†ğ‘£ğ‘™.ğœ“ğ‘™ğ‘£ğ‘™| ğœ‘âˆ’âˆ—ğœ‘ğ‘Ÿ} ğ‘’ğ‘Ÿ{ğœ†ğ‘£ğ‘Ÿ.ğœ“ğ‘Ÿ} It is best to read this rule from the bottom up. Below the line, using the precondition for ğ‘’ğ‘Ÿrequires showing ğœ‘. Above the line, the rule allows us to discharge this assumption by showing that ğœ‘holds in the postcondition of ğ‘’ğ‘™. That is, if some knowledge ğœ‘is needed in order to verify the safety of ğ‘’ğ‘Ÿ, then this knowledge can be gained from an execution of ğ‘’ğ‘™. Assertions ğœ‘of ChainedLog are ground Iris assertions of type iProp. As previously intuited (Â§4.2), they include two forms of points-to assertions, one for each side of the triple. We write â„“â†¦â†’ğ‘™ ğ‘Â®ğ‘£ the points-to assertion for the left expression, and â„“â†¦â†’ğ‘Ÿ ğ‘Â®ğ‘£for the right expression. Moreover, ChainedLog makes use of a left-allocation token, written leftalloc â„“. This (non-persistent) assertion witnesses that â„“has been allocated by the left expression and plays a key role for allocations. 5.2 Reasoning Rules for Chained Triples Figure 8 presents selected reasoning rules for chained triples. Before commenting on these rules, let us underline a caveat of chained triples, explaining in part why we only use them as a model for Musketeer: chained triples do not support a Bind rule.3 Hence, non-structural rules for chained triples explicitly mentions a stack of contexts, written Â®ğ¾. Let us again start with the rules for reasoning about an assertion. C-AssertL allows for reasoning about assertğ‘£on the left-hand side. Because this rule targets the left hand-side, there is no safety- related proof obligation, hence the premise of the rule allows the user to suppose that ğ‘£= true. C-AssertR is, on the contrary, similar to a standard separation logic rule for assertions: the assertion must target a Boolean, and this Boolean must be true. C-AllocL allows for reasoning about an allocation of an array on the left-hand side. Again, there is no safety proof obligation, so the user gets to suppose that the argument of the allocation is a non-negative integer. The precondition is then augmented with a points-to assertion to a universally quantified location â„“as well as the allocation token leftalloc â„“. This latter assertion plays a role in C-AllocR, which allows for reasoning about an allocation on the right-hand side. Indeed, the assertion leftalloc â„“appears in the precondition of the right-hand side. This assertion allows for predicting the location allocated on the right-hand side. As a result, the premise of C-AllocR does not universally quantify over the location allocatedâ€“the name â„“is reused. The user can transmit a leftalloc â„“assertion from the left-hand side to the right-hand side using C-FrameL and C-Chain. This rule may seem surprising, since allocation is nondeterministic in MusketLang, yet this rule appears to ensure that the right-hand side allocation returns the same location as the left-hand 3The absence of a Bind rule comes from the chaining intention of these triples: the user needs to terminate the reasoning on the whole left-hand side expression before reasoning on the right-hand side. Proc. ACM Program. Lang., Vol. 10, No. POPL, Article 26. Publication date: January 2026. 26:14 Alexandre Moine, Sam Westrick, and Joseph Tassarotti C-AssertL ğ‘£= true =â‡’{ğœ‘ğ‘™} Â®ğ¾ğ‘™âŸ¨()âŸ©{ğœ“ğ‘™| ğœ‘ğ‘Ÿ} Â®ğ¾ğ‘ŸâŸ¨ğ‘’ğ‘ŸâŸ©{ğœ“ğ‘Ÿ} {ğœ‘ğ‘™} Â®ğ¾ğ‘™âŸ¨assertğ‘£âŸ©{ğœ“ğ‘™| ğœ‘ğ‘Ÿ} Â®ğ¾ğ‘ŸâŸ¨ğ‘’ğ‘ŸâŸ©{ğœ“ğ‘Ÿ} C-AssertR {ğœ‘ğ‘™} Â®ğ¾ğ‘™âŸ¨ğ‘’ğ‘™âŸ©{ğœ“ğ‘™| ğœ‘ğ‘Ÿ} Â®ğ¾ğ‘ŸâŸ¨()âŸ©{ğœ“ğ‘Ÿ} {ğœ‘ğ‘™} Â®ğ¾ğ‘™âŸ¨ğ‘’ğ‘™âŸ©{ğœ“ğ‘™| ğœ‘ğ‘Ÿ} Â®ğ¾ğ‘ŸâŸ¨assert trueâŸ©{ğœ“ğ‘Ÿ} C-AllocL âˆ€â„“ğ‘–. ğ‘£= ğ‘–âˆ§0 â‰¤ğ‘–=â‡’{ğœ‘ğ‘™âˆ—â„“â†¦â†’ğ‘™()ğ‘–âˆ—leftalloc â„“} Â®ğ¾ğ‘™âŸ¨â„“âŸ©{ğœ“ğ‘Ÿ| ğœ‘ğ‘Ÿ} Â®ğ¾ğ‘ŸâŸ¨ğ‘’ğ‘ŸâŸ©{ğœ“ğ‘Ÿ} {ğœ‘ğ‘™} Â®ğ¾ğ‘™âŸ¨alloc ğ‘£âŸ©{ğœ“ğ‘Ÿ| ğœ‘ğ‘Ÿ} Â®ğ¾ğ‘ŸâŸ¨ğ‘’ğ‘ŸâŸ©{ğœ“ğ‘Ÿ} C-AllocR 0 â‰¤ğ‘– {ğœ‘ğ‘™} Â®ğ¾ğ‘™âŸ¨ğ‘’ğ‘™âŸ©{ğœ“ğ‘™| ğœ‘ğ‘Ÿâˆ—â„“â†¦â†’ğ‘Ÿ()ğ‘–} Â®ğ¾ğ‘ŸâŸ¨â„“âŸ©{ğœ“ğ‘Ÿ} {ğœ‘ğ‘™} Â®ğ¾ğ‘™âŸ¨ğ‘’ğ‘™âŸ©{ğœ“ğ‘™| ğœ‘ğ‘Ÿâˆ—leftalloc â„“} Â®ğ¾ğ‘ŸâŸ¨alloc ğ‘–âŸ©{ğœ“ğ‘Ÿ} C-LoadL âˆ€ğ‘–ğ‘¤. ğ‘£= ğ‘–âˆ§0 < ğ‘–â‰¤|Â®ğ‘£| âˆ§ğ‘¤= Â®ğ‘£(ğ‘–) =â‡’{ğœ‘ğ‘™âˆ—â„“â†¦â†’ğ‘™ ğ‘Â®ğ‘£} Â®ğ¾ğ‘™âŸ¨Â®ğ‘¤âŸ©{ğœ“ğ‘Ÿ| ğœ‘ğ‘Ÿ} Â®ğ¾ğ‘ŸâŸ¨ğ‘’ğ‘ŸâŸ©{ğœ“ğ‘Ÿ} {ğœ‘ğ‘™âˆ—â„“â†¦â†’ğ‘™ ğ‘Â®ğ‘£} Â®ğ¾ğ‘™âŸ¨â„“[ğ‘£]âŸ©{ğœ“ğ‘Ÿ| ğœ‘ğ‘Ÿ} Â®ğ¾ğ‘ŸâŸ¨ğ‘’ğ‘ŸâŸ©{ğœ“ğ‘Ÿ} C-LoadR 0 < ğ‘–â‰¤|Â®ğ‘£| âˆ§ğ‘¤= Â®ğ‘£(ğ‘–) {ğœ‘ğ‘™} Â®ğ¾ğ‘™âŸ¨ğ‘’ğ‘™âŸ©{ğœ“ğ‘™| ğœ‘ğ‘Ÿâˆ—â„“â†¦â†’ğ‘Ÿ ğ‘Â®ğ‘£} Â®ğ¾ğ‘ŸâŸ¨ğ‘¤âŸ©{ğœ“ğ‘Ÿ} {ğœ‘ğ‘™} Â®ğ¾ğ‘™âŸ¨ğ‘’ğ‘™âŸ©{ğœ“ğ‘™| ğœ‘ğ‘Ÿâˆ—â„“â†¦â†’ğ‘Ÿ ğ‘Â®ğ‘£} Â®ğ¾ğ‘ŸâŸ¨â„“[ğ‘–]âŸ©{ğœ“ğ‘Ÿ} C-Par {ğœ‘ğ‘™1} ğ‘’ğ‘™1 {ğœ“ğ‘™1 | ğœ‘ğ‘Ÿ1} ğ‘’ğ‘Ÿ1 {ğœ“ğ‘Ÿ1} {ğœ‘ğ‘™2} ğ‘’ğ‘™2 {ğœ“ğ‘™2 | ğœ‘ğ‘Ÿ2} ğ‘’ğ‘Ÿ2 {ğœ“ğ‘Ÿ2} âˆ€ğ‘£1 ğ‘¥1 ğ‘£2 ğ‘¥2. {ğœ“ğ‘™1ğ‘£1 ğ‘¥1 âˆ—ğœ“ğ‘™2 ğ‘£2 ğ‘¥2} Â®ğ¾ğ‘™âŸ¨(ğ‘£1, ğ‘£2)âŸ©{ğœ“ğ‘™| ğœ“ğ‘Ÿ1ğ‘£1 ğ‘¥1 âˆ—ğœ“ğ‘Ÿ2 ğ‘£2 ğ‘¥2} Â®ğ¾ğ‘ŸâŸ¨(ğ‘£1, ğ‘£2)âŸ©{ğœ“ğ‘Ÿ} {ğœ‘ğ‘™1 âˆ—ğœ‘ğ‘™2} Â®ğ¾ğ‘™âŸ¨parğ‘’ğ‘™1 ğ‘’ğ‘™2âŸ©{ğœ“ğ‘™| ğœ‘ğ‘Ÿ1 âˆ—ğœ‘ğ‘Ÿ2} Â®ğ¾ğ‘ŸâŸ¨parğ‘’ğ‘Ÿ1 ğ‘’ğ‘Ÿ2âŸ©{ğœ“ğ‘Ÿ} C-FrameL {ğœ‘ğ‘™} ğ‘’ğ‘™{ğœ“ğ‘™| ğœ‘ğ‘Ÿ} ğ‘’ğ‘Ÿ{ğœ“ğ‘Ÿ} {ğœ‘ğ‘™âˆ—ğœ‘0} ğ‘’ğ‘™{ğœ“ğ‘™âˆ—ğœ‘0 | ğœ‘ğ‘Ÿ} ğ‘’ğ‘Ÿ{ğœ“ğ‘Ÿ} C-FrameR {ğœ‘ğ‘™} ğ‘’ğ‘™{ğœ“ğ‘™| ğœ‘ğ‘Ÿ} ğ‘’ğ‘Ÿ{ğœ“ğ‘Ÿ} {ğœ‘ğ‘™} ğ‘’ğ‘™{ğœ“ğ‘™| ğœ‘ğ‘Ÿâˆ—ğœ‘0} ğ‘’ğ‘Ÿ{ğœ†ğ‘£ğ‘Ÿ.ğœ“ğ‘Ÿğ‘£ğ‘Ÿâˆ—ğœ‘0} Fig. 8. Selected Reasoning Rules for Chained Triples side. The key is that a right-hand points-to assertion of the form â„“â†¦â†’ğ‘Ÿ ğ‘Â®ğ‘£does not mean that the specific location â„“has that value in the right-hand side execution. Rather, it means that there exists some location which points to Â®ğ‘£on the right-hand side, and we can reason as if that location were equivalent to â„“, under some implicit permutation renaming of locations. In other words, as we alluded to earlier in Section 4.3 when discussing the nondeterminism of allocation in Musketeer, the logic ensures that the specific location of an allocation does not matter, since we do not support casting integers to pointers. Our approach of using the leftalloc â„“assertion has two consequences. First, as we will see (Â§5.3), it will allow us to define Musketeer triples in terms of chained triples where both the left- and right-hand side coincide; such a definition would be impossible if the allocation on the left and on the right-hand side could return different names. Second, it bounds the number of allocations on the right-hand side by the number of allocations on the left-hand side. We posit that this limitation can be lifted by distinguishing between synchronized locations, whose name come from the left-hand side, and unsynchronized one. We were able to conduct our case studies without such a feature. C-LoadL and C-LoadR follow the same spirit as the previous rules: the rule for the left-hand side has no safety proof obligation, but the right-hand size has a standard separation logic shape. C-Par targets a parallel primitive and is a synchronization point: both the left- and right-hand side must face a parallel primitive. The rule mimics a standard Par rule on both sides at once. In particular, it requires the user to split the preconditions of the left- and right-hand sides, which will be given to the corresponding side of the active parallel pair. The bottom premise of C-Par requires the user to verify the continuation, after the execution of the parallel primitive ended. This premise also show the (external) determinism guaranteed by chained triple: the execution is resumed on both sides with the same result of the parallel execution: the immutable pair (ğ‘£1, ğ‘£2). Note also that both sides agree on the ghost return values. Proc. ACM Program. Lang., Vol. 10, No. POPL, Article 26. Publication date: January 2026. All for One and One for All: Program Logics for Exploiting Internal Determinism in Parallel Programs 26:15 vProp â‰œB â†’iProp âˆ€ğ‘¥. ğ‘ƒğ‘¥â‰œğœ†ğ‘. âˆ€ğ‘¥. ğ‘ƒğ‘¥ğ‘ ğ‘ƒ1 âˆ—ğ‘ƒ2 â‰œğœ†ğ‘. ğ‘ƒ1 ğ‘âˆ—ğ‘ƒ2 ğ‘ âˆƒğ‘¥. ğ‘ƒğ‘¥â‰œğœ†ğ‘. âˆƒğ‘¥. ğ‘ƒğ‘¥ğ‘ ğ‘ƒ1 âˆ’âˆ—ğ‘ƒ2 â‰œğœ†ğ‘. ğ‘ƒ1 ğ‘âˆ’âˆ—ğ‘ƒ2 ğ‘ â„“â†¦â†’ğ‘Â®ğ‘£â‰œğœ†ğ‘. if ğ‘then â„“â†¦â†’ğ‘™ ğ‘Â®ğ‘£else â„“â†¦â†’ğ‘Ÿ ğ‘Â®ğ‘£ Fig. 9. Definition of vProp assertions {ğ‘ƒ} ğ‘’{ğ‘„} â‰œâˆ€Â®ğ¾ğœ‘ğ‘™ğœ‘ğ‘Ÿğœ“ğ‘™ğœ“ğ‘Ÿ.   âˆ€ğ‘£ğ‘¥. {ğ‘„ğ‘£ğ‘¥true âˆ—ğœ‘ğ‘™} Â®ğ¾âŸ¨ğ‘£âŸ©{ğœ“ğ‘™| ğ‘„ğ‘£ğ‘¥false âˆ—ğœ‘ğ‘Ÿ} Â®ğ¾âŸ¨ğ‘£âŸ©{ğœ“ğ‘Ÿ}  âˆ’âˆ— {ğ‘ƒtrue âˆ—ğœ‘ğ‘™} Â®ğ¾âŸ¨ğ‘’âŸ©{ğœ“ğ‘™| ğ‘ƒfalse âˆ—ğœ‘ğ‘Ÿ} Â®ğ¾âŸ¨ğ‘’âŸ©{ğœ“ğ‘Ÿ} Fig. 10. Definition of Musketeer Triples 5.3 Encoding Musketeer in ChainedLog We now discuss how to encode Musketeer into ChainedLog. Recall that Musketeerâ€™s assertions have the type vProp. We encode these as functions from Booleans to iProp, the ground type of ChainedLog assertions. The idea is that the vProp tracks two heaps, and we use the Boolean parameter of the function to indicate which side of the ChainedLog the assertion is being interpreted to: true indicates the left side, and false the right side. The formal definition of vProp assertions appears in Figure 9. The Boolean parameter is threaded through the separating star and implication, and similarly for the âˆ€and âˆƒquantifier. The points-to assertion simply cases over the Boolean and returns the left or right version of the points-to. Entailment is defined as ğ‘ƒ1 âŠ¢ğ‘ƒ2 â‰œâˆ€ğ‘. ğ‘ƒ1 ğ‘âŠ¢ğ‘ƒ2 ğ‘. Next, we can encode Musketeer triples as shown in Figure 10. A Musketeer triple {ğ‘ƒ} ğ‘’{ğ‘„} is mapped to a chained triple where both sides refer to the expression ğ‘’use the precondition ğ‘ƒ instantiated with Booleans corresponding to the appropriate side. Because chained triples do not support a bind rule, the encoding is written in a continuation passing style: rather than having ğ‘„ in the post-condition of the chained triple, we instead quantify over an evaluation context Â®ğ¾that represents an arbitrary continuation to run after ğ‘’. This continuation is assumed to satisfy a chained tripled in which ğ‘„occurs in the preconditions. We additionally quantify over several assertions ğœ‘ğ‘™, ğœ‘ğ‘Ÿ, ğœ“ğ‘™, and ğœ“ğ‘Ÿthat are used to represent additional resources used by the continuation. 6 A Separation Logic for Verifying One Interleaving We now return to Angelic, our program logic verifying that one interleaving of a MusketLang program is safe and terminates. We first present the assertions of Angelic (Â§6.1) and then present selected reasoning rules (Â§6.2). 6.1 Assertions of Angelic Assertions of Angelic are Iris assertions of type iProp, written ğœ‘. The fractional points-to assertion of Angelic takes the form â„“â†¦â†’ğ‘Â®ğ‘£(while we reuse the syntax of the points-to assertion from Musketeer, the two assertions are differentâ€”recall that Angelic and Musketeer are totally disjoint). A key aspect of Angelic is that this logic has two reasoning modes. First, the running mode takes the form runğ‘’{ğœ“}, where ğ‘’is the expression being logically â€œrunâ€ and ğœ“is a postcondition, The assertion runğ‘’{ğœ“} is close to a weakest-precondition (WP). In fact, it enjoys all the rules of a standard separation logic WP. However, the running mode enjoys additional rules that allow one to dynamically â€œselectâ€ and verify just one interleaving. This selection is made possible thanks to a second mode, that we call the scheduler mode. The scheduler mode involves two key assertions. First, ğ”¤ğ”¬ğ”ğ”©is an opaque assertion, intuitively representing the proof obligation to verify the whole program. Second, the assertion yielded ğœ‹ğ‘’asserts the ownership of the task ğœ‹, and that this task yielded facing expression ğ‘’. Proc. ACM Program. Lang., Vol. 10, No. POPL, Article 26. Publication date: January 2026. 26:16 Alexandre Moine, Sam Westrick, and Joseph Tassarotti A-Alloc âŒœ0 â‰¤ğ‘–âŒ run (alloc ğ‘–) {ğœ†ğ‘£. âˆƒâ„“. â„“â†¦â†’()ğ‘–} A-Load âŒœ0 â‰¤ğ‘–< |Â®ğ‘£|âŒ â„“â†¦â†’ğ‘Â®ğ‘£ run (â„“[ğ‘–]) {ğ‘¤. âŒœğ‘¤= Â®ğ‘£(ğ‘–)âŒâˆ—â„“â†¦â†’ğ‘Â®ğ‘£} A-Bind runğ‘’{ğœ†ğ‘£. run (ğ¾âŸ¨ğ‘£âŸ©) {ğœ“}} run (ğ¾âŸ¨ğ‘’âŸ©) {ğœ“} A-Store âŒœ0 â‰¤ğ‘–< |Â®ğ‘£|âŒ â„“â†¦â†’Â®ğ‘£ run (â„“[ğ‘–] â†ğ‘£â€²) {ğ‘¤. âŒœğ‘¤= ()âŒâˆ—â„“â†¦â†’[ğ‘–:= ğ‘£â€²]Â®ğ‘£} A-Call run ([ Ë†ğœ‡ğ‘“ğ‘¥.ğ‘’/ğ‘“][ğ‘£/ğ‘¥]ğ‘’) {ğœ“} run ( Ë†ğœ‡ğ‘“ğ‘¥.ğ‘’) ğ‘£{ğœ“} A-Conseq runğ‘’{ğœ“â€²} ( âˆ€ğ‘£. ğœ“â€² ğ‘£âˆ’âˆ—ğœ“ğ‘£) runğ‘’{ğœ“} Yield âˆ€ğœ‹. yielded ğœ‹ğ‘’âˆ’âˆ—(âˆ€ğ‘£. yielded ğœ‹ğ‘£âˆ’âˆ—ğœ“ğ‘£âˆ’âˆ—ğ”¤ğ”¬ğ”ğ”©) âˆ’âˆ—ğ”¤ğ”¬ğ”ğ”© runğ‘’{ğœ“} Resume yielded ğœ‹ğ‘’ runğ‘’{ğœ†ğ‘£. yielded ğœ‹ğ‘£âˆ’âˆ—ğ”¤ğ”¬ğ”ğ”©} ğ”¤ğ”¬ğ”ğ”© Fork âˆ€ğœ‹1 ğœ‹2. yielded ğœ‹1 ğ‘’1 âˆ’âˆ—yielded ğœ‹2 ğ‘’2 âˆ’âˆ—(âˆ€ğ‘£1 ğ‘£2. yielded ğœ‹1 ğ‘£1 âˆ’âˆ—yielded ğœ‹2 ğ‘£2 âˆ’âˆ—ğœ“(ğ‘£1, ğ‘£2) âˆ’âˆ—ğ”¤ğ”¬ğ”ğ”©) âˆ’âˆ—ğ”¤ğ”¬ğ”ğ”© run (parğ‘’1 ğ‘’2) {ğœ“} Fig. 11. Selected Reasoning Rules of Angelic (extends Figure 2) The logic satisfies the following soundness theorem: Theorem 6.1 (Soundness of Angelic). If runğ‘’{ğœ†_. âŠ¤} holds, then there exists a value ğ‘£and a store ğœsuch that ğ‘’\ âˆ…âˆ’â†’âˆ—ğ‘£\ğœ. 6.2 Reasoning Rules of Angelic Figure 11 presents the key reasoning rules allowing the user to select and verify an interleaving. These inference rules are at the iProp level: their premises are implicitly separated by âˆ—, and the implication between the premise and the conclusion is stated as the entailement âŠ¢. The upper part of Figure 11 showcases that the run mode of Angelic is, for its sequential part, similar to a standard separation logic. A-Alloc performs an allocation, A-Load a load and A-Store a storeâ€”here, the allocation size and various offsets must be valid. A-Call verifies a function call. A-Conseq shows that the user can make the postcondition stronger. A-Bind allows for reasoning under an evaluation context. The lower part of Figure 11 focuses on the scheduler mode of Angelic. Yield asserts (reading the rule from bottom to top) that the proof of runğ‘’{ğœ“} can pause, and switch to the scheduler modeâ€”that is, a proof where the target is ğ”¤ğ”¬ğ”ğ”©. To prove this target, the user gets to assume that some (universally quantified) task ğœ‹yielded with expression ğ‘’, and that when this expression will have reduced to a value ğ‘£satisfying ğœ“, then ğ”¤ğ”¬ğ”ğ”©will hold. Resume is the companion rule of Yield: it asserts that in order to prove ğ”¤ğ”¬ğ”ğ”©, the user has to give up the ownership of a task ğœ‹facing an expression ğ‘’and switch back to the running mode to verify that runğ‘’{ğœ†ğ‘£. yielded ğœ‹ğ‘£âˆ’âˆ—ğ”¤ğ”¬ğ”ğ”©}. Fork shows the real benefit of the scheduler mode. This rule asserts that, for verifying the parallel primitive parğ‘’1 ğ‘’2, the user can switch to the scheduler mode. In this mode, the user gets to suppose that two tasks ğœ‹1 and ğœ‹2 yielded at ğ‘’1 and ğ‘’2, respectively. Moreover, the user can suppose that, when these two tasks would have completed their execution and reached values ğ‘£1 and ğ‘£2 such that ğœ“(ğ‘£1, ğ‘£2) hold, the ğ”¤ğ”¬ğ”ğ”©will hold. At this point, the user can choose which of ğ‘’1 and ğ‘’2 to begin verifying using Resume. Recall in Section 2.3 we saw rules A-ParSeqL and A-ParSeqR allowing one to verify a parallel composition by picking either a left-then-right or right-then-left sequential ordering. These two rules can be derived from the more general constructs of Angelic that we have now seen. For Proc. ACM Program. Lang., Vol. 10, No. POPL, Article 26. Publication date: January 2026. All for One and One for All: Program Logics for Exploiting Internal Determinism in Parallel Programs 26:17 ğœâ‰œâŠ¥| empty | unit | bool | int | ğœâ†’ğœ| (ğœÃ— ğœ) | refğœ Î“ âˆˆVar â‡€ğœ empty Â· empty â‰œempty int Â· int â‰œint unit Â· unit â‰œunit (ğœ1 Ã— ğœ2) Â· (ğœâ€² 1 Ã— ğœâ€² 2) â‰œ((ğœ1 Â· ğœâ€² 1) Ã— (ğœ2 Â· ğœâ€² 2)) bool Â· bool â‰œbool (ğœ1 â†’ğœ2) Â· (ğœâ€² 1 â†’ğœâ€² 2) â‰œif (ğœ1 = ğœâ€² 1 âˆ§ğœ2 = ğœâ€² 2) thenğœ1 â†’ğœ2 else âŠ¥ Fig. 12. Syntax of MiniDet Type System example, in order to show that A-ParSeqL holds, we first apply Fork, then use Resume for the expression ğ‘’1. We then use A-Conseq with Resume for expression ğ‘’2 and conclude. 7 Case Studies To showcase Musketeer, we start by using it to prove the soundness of a simple affine type system that ensures schedule-independent safety (Â§7.1). We then extend this type system with two core algorithmic primitives proposed by Blelloch et al. [2012] for ensuring internal determinacy: priority writes (Â§7.2) and deterministic hash sets (Â§7.3). Interestingly, while these primitives appear to be internally deterministic to their client, their implementation is not: they observe internal state of shared data structures that may be concurrently modified. Yet, we show that they satisfy schedule- independent safety. Because all well-typed programs in this system have schedule-independent safety, we can use Angelic to reason about them, as we demonstrate by verifying a parallel list deduplication example (Â§7.4). 7.1 MiniDet: An Affine Type System for Determinism This section presents MiniDet, an affine type system for MusketLang that ensures determinism. Like many other substructural type systems, the types in MiniDet can be thought of as tracking ownership of resources such as array references, thereby preventing threads from accessing shared resources in a way that would introduce nondeterministic behaviors. Syntax. The syntax of types in MiniDet appears in Figure 12. A type ğœis either the invalid type âŠ¥ (used only internally), the empty type, describing an unknown value without ownership, the unit type unit, the Boolean type bool, the integer type int, the arrow type ğœ1 â†’ğœ2, the immutable product (ğœ1 Ã— ğœ2) or the reference type refğœ. A typing environment Î“ is a finite map from variables to types. We write dom(Î“) for its domain. The type system is affine meaning that, when splitting a typing context in two, a variable can only appear in one sub-context at a time. However, variables with types whose inhabitants have no associated notion of ownership, or variables with types with fractional reasoning, can be split and joined. In order to capture this notion, we equip types with a monoid operation _ Â· _ taking two types as arguments and producing a new type. In particular, when ğœÂ· ğœ= ğœ, it means that a variable of type ğœcan be duplicated. The definition of the monoid operation appears in the lower part of Figure 12. The missing cases are all sent to âŠ¥. In particular these definitions prevent a reference from being duplicated. We extend the monoid operation to typing environments by defining Î“1 Â· Î“2 as the function that maps the variable ğ‘¥to ğœ1 if Î“1(ğ‘¥) = ğœ1 and ğ‘¥is not in the domain of Î“2, ğœ2 if Î“2(ğ‘¥) = ğœ2 and ğ‘¥is not in the domain of Î“1, and ğœ1 Â· ğœ2 if Î“1(ğ‘¥) = ğœ1 and Î“2(ğ‘¥) = ğœ2. The typing judgement of MiniDet takes the form Î“ âŠ¢ğ‘’: ğœâŠ£Î“â€², and asserts that ğ‘’has type ğœ and transforms the typing environment Î“ into Î“â€². Typing rules. Selected typing rules appear in Figure 13. T-Var types variable ğ‘¥at type ğœif ğ‘¥ has type ğœin the typing environment. The returned environment is empty. T-Unit, T-Bool and rule T-Int type unboxed values. T-Assert types an assert primitive. T-Let types a let-binding Proc. ACM Program. Lang., Vol. 10, No. POPL, Article 26. Publication date: January 2026. 26:18 Alexandre Moine, Sam Westrick, and Joseph Tassarotti T-Var {ğ‘¥:= ğœ} âŠ¢ğ‘¥: ğœâŠ£âˆ… T-Unit âˆ…âŠ¢() : unit âŠ£âˆ… T-Bool âˆ…âŠ¢ğ‘: bool âŠ£âˆ… T-Int âˆ…âŠ¢ğ‘–: int âŠ£âˆ… T-Assert Î“ âŠ¢ğ‘’: bool âŠ£Î“â€² Î“ âŠ¢assertğ‘’: unit âŠ£Î“â€² T-Let Î“1 âŠ¢ğ‘’1 : ğœ1 âŠ£Î“â€² 1 [ğ‘¥:= ğœ1]Î“â€² 1 âŠ¢ğ‘’2 : ğœ2 âŠ£Î“2 Î“1 âŠ¢letğ‘¥= ğ‘’1 inğ‘’2 : ğœ2 âŠ£delğ‘¥Î“2 T-Weak Î“1 âŠ†Î“â€² 1 Î“2 âŠ†Î“â€² 2 Î“â€² 1 âŠ¢ğ‘’: ğœâŠ£Î“â€² 2 Î“1 âŠ¢ğ‘’: ğœâŠ£Î“2 T-Abs Î“ = Î“ Â· Î“ [ğ‘“:= ğœâ†’ğœâ€²][ğ‘¥:= ğœ]Î“ âŠ¢ğ‘’: ğœâ€² âŠ£âˆ… Î“ âŠ¢ğœ‡ğ‘“ğ‘¥.ğ‘’: ğœâ†’ğœâ€² âŠ£âˆ… T-App Î“1 âŠ¢ğ‘’1 : ğœâŠ£Î“2 Î“2 âŠ¢ğ‘’2 : ğœâ†’ğœâ€² âŠ£Î“3 Î“1 âŠ¢ğ‘’2 ğ‘’1 : ğœâ€² âŠ£Î“3 T-Ref Î“ âŠ¢ğ‘’: ğœâŠ£Î“â€² Î“ âŠ¢ref ğ‘’: refğœâŠ£Î“â€² T-Get {ğ‘¥:= refğœ} âŠ¢getğ‘¥: ğœâŠ£{ğ‘¥:= ref empty} T-Set Î“ âŠ¢ğ‘’: ğœâŠ£{ğ‘¥:= ref empty} Â· Î“â€² Î“ âŠ¢setğ‘¥ğ‘’: unit âŠ£{ğ‘¥:= refğœ} Â· Î“â€² T-Par Î“1 âŠ¢ğ‘’1 : ğœ1 âŠ£Î“â€² 1 Î“2 âŠ¢ğ‘’2 : ğœ2 âŠ£Î“â€² 2 Î“1 Â· Î“2 âŠ¢parğ‘’1 ğ‘’2 : (ğœ1 Ã— ğœ2) âŠ£Î“â€² 1 Â· Î“â€² 2 T-Frame Î“ âŠ¢ğ‘’: ğœâŠ£Î“â€² Î“0 Â· Î“ âŠ¢ğ‘’: ğœâŠ£Î“0 Â· Î“â€² Fig. 13. Selected Typing Rules of MiniDet letğ‘¥= ğ‘’1 inğ‘’2 at typeğœ2 with initial context Î“1 if ğ‘’1 has typeğœ1 under the same context and produces context Î“2, and if ğ‘’2 has type ğœ2 under the context Î“1 in which ğ‘¥has type ğœ1. The produced context of the let-binding is Î“2 from which ğ‘¥has been deleted. T-Abs types a function with recursive name ğ‘“, argument ğ‘¥and body ğ‘’, of type ğœâ†’ğœâ€² and with typing environment Î“. This environment must be duplicable, that is Î“ = Î“ Â· Î“. This duplicability implies that Î“ contains no types with ownership, that is, for now, no references. The precondition requires that ğ‘’has type ğœâ€² in Î“, augmented with ğ‘“ of type ğœâ†’ğœâ€² and ğ‘¥of type ğœ. T-App types a function call and is straightforward. T-Ref types a reference allocation. T-Get types a get operation on a variable ğ‘¥. This rule requires that ğ‘¥is of some type refğœ, returns a type ğœand updates the binding of ğ‘¥to ref empty. This is because get returns the ownership of the content of the cellâ€”meaning that the cell does not hold recursive ownership of its contents anymore.4 T-Set is the dual, and types the expression setğ‘¥ğ‘’. This rule requires that ğ‘’is of some type ğœand that, in the resulting environment, ğ‘¥is of type ref empty. The set operation returns unit and updates the type of ğ‘¥to refğœ, â€œfillingâ€ the cell. T-Par types a parallel primitive, and is similar to the related separation logic rules. Indeed, T-Par requires splitting the context in two parts, that will be used to type separately the two sub-tasks, whose result typing context will be merged in the result typing context of the rule. Finally, T-Frame allows for framing a part of the context for local reasoning, and T-Weak allows for removing bindings from the input and output typing environments. Soundness of MiniDet. The above system prevents data-races, and hence guarantees that well- typed programs have schedule-indepedent safety, as formalized by the following lemma. Lemma 7.1 (Soundness of MiniDet). If âˆ…âŠ¢ğ‘’: ğœâŠ£âˆ…holds, then SISafety ğ‘’holds. To prove this theorem, we use program logic-based semantic typing [Timany et al. 2024b]. With this technique, we associate a triple (in our case, a Musketeer triple) to a typing judgement, and 4We could have derived another rule for get on a reference whose content is not tied to any ownership. We follow this approach when extending the type system with priority writes (Â§7.2). Proc. ACM Program. Lang., Vol. 10, No. POPL, Article 26. Publication date: January 2026. All for One and One for All: Program Logics for Exploiting Internal Determinism in Parallel Programs 26:19 ğ‘ â‰œsinvalid | snone | sprodğ‘ ğ‘ | srefğ‘£ğ‘ | sarrowğ›¾ ğ‘€âˆˆVar â‡€ğœ ğ‘‰âˆˆVar â‡€V J empty | snone | ğ‘£K â‰œâŠ¤ J bool | snone | ğ‘£K â‰œâŒœâˆƒğ‘. ğ‘£= ğ‘âŒ J unit | snone | ğ‘£K â‰œâŒœğ‘£= ()âŒ J int | snone | ğ‘£K â‰œâŒœâˆƒğ‘–. ğ‘£= ğ‘–âŒ J (ğœ1 Ã— ğœ2) | sprodğ‘ 1 ğ‘ 2 | ğ‘£K â‰œâˆƒğ‘£1 ğ‘£2. âŒœğ‘£= (ğ‘£1, ğ‘£2)âŒâˆ—Jğœ1 | ğ‘ 1 | ğ‘£1 K âˆ—Jğœ2 | ğ‘ 2 | ğ‘£2 K J refğœ| srefğ‘¤ğ‘ | ğ‘£K â‰œâˆƒâ„“. âŒœğ‘£= â„“âŒâˆ—â„“â†¦â†’[ğ‘¤] âˆ—Jğœ| ğ‘ | ğ‘¤K Jğœâ†’ğœâ€² | sarrowğ›¾| ğ‘£K â‰œâˆƒğ‘ƒ.ğ›¾Zâ‡’ğ‘ƒâˆ— ğ‘ƒâˆ— onlyleft ( âˆ€ğ‘¤ğ‘ . {âŠ²ğ‘ƒâˆ—Jğœ| ğ‘ | ğ‘¤K} (ğ‘£ğ‘¤) {ğœ†ğ‘£â€² ğ‘ â€². Jğœâ€² | ğ‘ â€² | ğ‘£â€² K}) J Î“ | ğ‘€| ğ‘‰K â‰œâŒœdom(Î“) = dom(ğ‘€) = dom(ğ‘‰)âŒâˆ—âˆ—ğ‘¥âˆˆdom(Î“) J Î“(ğ‘¥) | ğ‘€(ğ‘¥) | ğ‘‰(ğ‘¥) K where onlyleft (ğ‘ƒ) â‰œğœ†ğ‘. if ğ‘then (ğ‘ƒtrue) else âŠ¤ J Î“ âŠ¢ğ‘’: ğœâŠ£Î“â€² K â‰œâˆ€ğ‘€ğ‘‰. {J Î“ | ğ‘€| ğ‘‰K} ([ğ‘‰/]ğ‘’) {ğœ†ğ‘£(ğ‘ , ğ‘€â€²). âŒœÎ“ â‰ˆÎ“â€² âˆ§ğ‘€â‰ˆğ‘€â€²âŒâˆ—Jğœ| ğ‘ | ğ‘£K âˆ—J Î“â€² | ğ‘€â€² | ğ‘‰|dom(Î“â€²) K} Fig. 14. Semantic Interpretation of MiniDet show that whenever the typing judgement holds, the corresponding triple is valid. The soundness theorem of the type system is then derived from the soundness of the underlying logic. The Musketeer triple associated to a typing judgement makes use of a logical relation. Typically, when using program logic-based semantic typing, a logical relation is a relation expressed in the assertions of the underlying logic that relates a type to a value it inhabits. In our case, however, the logical relation involves three parameters: a type, a value, and a shape. The shape captures the â€œdeterminismâ€ of each type and will be used in connection with ghost return values. For example, the shape of a reference is the actual value stored in this reference, and the shape of a function records that the functionâ€™s environment is deterministic. Figure 14 defines the format of shapes. A shape ğ‘ as either an invalid shape (whose purpose is similar to the invalid type, as we equip shapes with a monoid operation), the none shape, storing no information, the product shape sprodğ‘ 1 ğ‘ 2, the reference shape srefğ‘£ğ‘ , where ğ‘£represents the content of the reference and ğ‘ the shape associated with ğ‘£and finally the arrow shape sarrowğ›¾, where ğ›¾is the name of an Iris ghost cell [Jung et al. 2018]. The logical relation Jğœ| ğ‘ | ğ‘£K, shown in Figure 14 then relates a type ğœ, a shape ğ‘ , and a value ğ‘£. This relation is itself of type vProp. Unboxed types are interpreted as expected, associated the with snone shape. Products must be associated to the product shape and a product value, and the interpretation must recursively hold. For the reference type refğœ, the shape must be a reference shape srefğ‘¤ğ‘ , ğ‘£must be a location â„“such that â„“points to ğ‘¤and that recursively Jğœ| ğ‘ | ğ‘¤K holds. Note that the interpretation of a reference expresses the ownership of the associated points-to. Besides, the content of the reference ğ‘¤is not existentially quantified, but rather given by the shape. The case of an arrow ğœâ†’ğœâ€² is subtle and differs from the approach used in other program logic based logical relations. In the usual approach, the interpretation of ğœâ†’ğœâ€² says that ğ‘£is in the relation if for any ğ‘¤in the interpretation of ğœ, a Hoare triple of a certain form holds for the application ğ‘£ğ‘¤. Unfortunately, this approach cannot be used directly with Musketeer. The reason is that the usual approach exploits the fact that the underlying logic is higher-order and impredicative, so that a Hoare triple is itself an assertion that can appear in the pre/post-condition of another triple. In contrast, in Musketeer, the assertions appearing in pre/post-conditions are vProps, but the triple itself is not a vProp, it is an iProp in the underlying chained logic, as we saw in Â§5. To work around this, we define an operation onlyleft that takes an iProp and coerces it into a vProp by requiring the proposition to only hold for the left-hand side. Using this, the logical relation asserts that, only in the left case, for any value ğ‘¤and shape ğ‘ , a Hoare triple holds for ğ‘£ğ‘¤. In this triple, the precondition requires Jğœ| ğ‘ | ğ‘¤K, and the postcondition says that the result will satisfy Proc. ACM Program. Lang., Vol. 10, No. POPL, Article 26. Publication date: January 2026. 26:20 Alexandre Moine, Sam Westrick, and Joseph Tassarotti the interpretation of ğœâ€². The precondition additionally requires ğ‘ƒto hold for some existentially quantified vProp predicate ğ‘ƒ. ( Technically, ğ‘ƒis assumed to hold under a later modality âŠ², but this detail can be ignored.) This ğ‘ƒwill correspond to the resources associated with whatever variables from a typing environment the function closes over. Thus, ğ‘ƒis required to hold under the Iris persistent modality , ensuring that the proposition is duplicableâ€”recall that the typing rule T-Abs requires functions to close over only duplicable environments. Finally, there is one last trick: to ensure that this existential quantification over ğ‘ƒcan later be eliminated using M-ElimExist, the witness is made unique by using an Iris saved predicate assertion, lifted at the vProp level and written ğ›¾Zâ‡’ğ‘ƒ, which states that ğ›¾is the name of a ghost variable that stores the assertion ğ‘ƒ. The ğ›¾ here is bound as part of the shape sarrowğ›¾. Since a ghost variable can only store one proposition, only one ğ‘ƒcan satisfy this assertion. Figure 14 then defines the interpretation of a typing environment Î“, a shape environment ğ‘€ and a value environment ğ‘‰, written J Î“ | ğ‘€| ğ‘‰K as the lifting per-variable ğ‘¥of the logical relation. Using this, we obtain the interpretation of the typing judgement Î“ âŠ¢ğ‘’: ğœâŠ£Î“â€². This interpretation universally quantifies over a shape environment ğ‘€and a variable environment ğ‘‰, and asserts a Musketeer triple. The precondition is the interpretation of the environments, and targets an expression [ğ‘‰/]ğ‘’, that is, the expression ğ‘’with variables replaced by values as specified by ğ‘‰. The postcondition binds a return value ğ‘£as well as a ghost return value consisting of a shape ğ‘ and a shape environment ğ‘€â€². The postcondition asserts that the two typing environment Î“ and Î“â€² are similar, written Î“ â‰ˆÎ“â€² and that the shape environments ğ‘€and ğ‘€â€² are also similar, with (overloaded) notation ğ‘€â‰ˆğ‘€â€². Intuitively these relations guarantee that variables did not change in nature in environments (e.g. a reference stayed a reference, and a reference shape stayed a reference shape, even if the content may have changed). We formally define these statements in Appendix B. The postcondition finally asserts that the return value is related to ğœand ğ‘ and that the returned environment Î“â€² is correct with ğ‘€â€² and the same variables ğ‘‰, dropping unneeded bindings. With these definitions, we state the fundamental lemma of the logical relation. Lemma 7.2 (Fundamental). If Î“ âŠ¢ğ‘’: ğœâŠ£Î“â€² holds then J Î“ âŠ¢ğ‘’: ğœâŠ£Î“â€² K holds too. From this lemma, it is easy to prove the soundness of MiniDet (Lemma 7.1). Let us suppose that âˆ…âŠ¢ğ‘’: ğœâŠ£âˆ…holds. We apply Lemma 7.2 and learn that J âˆ…âŠ¢ğ‘’: ğœâŠ£âˆ…K holds too. Unfolding definitions and applying M-Conseq, this fact implies that {âŠ¤} ğ‘’{ğœ†_ _. âŠ¤} holds. We conclude by applying the soundness of Musketeer (Theorem 4.1). 7.2 Priority Writes In this section, we extend MiniDet with rules for priority writes [Blelloch et al. 2012]. A priority write targets a reference ğ‘Ÿon an integer ğ‘¥and atomically updates the content ğ‘¦of ğ‘Ÿto ğ‘¥maxğ‘¦. As long as there are no concurrent reads, priority writes can happen in parallel: because max is associative and commutative, the order in which the parallel write operations happen does not matter. Conversely, so long as there are no ongoing concurrent writes, reads from the reference will be safe and deterministicâ€”and such reads can also happen in parallel. Thus, priority writes are deterministic so long as they are used in a phased manner, alternating between concurrent writes in one phase, and concurrent reads in the next. For simplicity, we consider priority writes on integers equipped with the max function. Implementation of priority writes. Figure 15 shows the implementation of priority references. Allocating a priority reference with palloc just allocates a reference. The priority read pread is just a plain get operation. A priority write pwrite is a function with recursive name ğ‘“taking two arguments: ğ‘Ÿ, the reference to update, and ğ‘¥, the integer to update the reference with. The function Proc. ACM Program. Lang., Vol. 10, No. POPL, Article 26. Publication date: January 2026. All for One and One for All: Program Logics for Exploiting Internal Determinism in Parallel Programs 26:21 palloc â‰œğœ†ğ‘›. ref ğ‘› pread â‰œğœ†ğ‘Ÿ. get ğ‘Ÿ pwrite â‰œğœ‡ğ‘“ğ‘Ÿğ‘¥. letğ‘¦= getğ‘Ÿin if ğ‘¥< ğ‘¦then () else if CASğ‘Ÿ0ğ‘¥ğ‘¦then () else ğ‘“ğ‘Ÿğ‘¥ Fig. 15. Implementation of Priority Writes ğœâ‰œÂ· Â· Â· | pwriteğ‘| preadğ‘ pwriteğ‘1 Â· pwriteğ‘2 â‰œpwrite (ğ‘1 + ğ‘2) preadğ‘1 Â· preadğ‘2 â‰œpread (ğ‘1 + ğ‘2) T-PAlloc Î“ âŠ¢ğ‘’: int âŠ£Î“â€² Î“ âŠ¢pallocğ‘’: pwrite 1 âŠ£Î“â€² T-PWrite Î“ âŠ¢ğ‘’: int âŠ£Î“â€² Î“â€²(ğ‘¥) = pwriteğ‘ Î“ âŠ¢ğ‘’: pwrite ğ‘¥ğ‘’âŠ£Î“â€² T-PRead {ğ‘¥:= preadğ‘} âŠ¢preadğ‘¥: int âŠ£{ğ‘¥:= preadğ‘} T-Update Î“ { Î“â€² Î“â€² âŠ¢ğ‘’: ğœâŠ£Î“â€²â€² Î“ âŠ¢ğ‘’: ğœâŠ£Î“â€²â€² U-Refl ğœ{ ğœ U-Pair ğœ1 { ğœâ€² 1 ğœ2 { ğœâ€² 2 (ğœ1 Ã— ğœ2) { (ğœâ€² 1 Ã— ğœâ€² 2) U-R2W pread 1 { pwrite 1 U-W2R pwrite 1 { pread 1 Fig. 16. Extension of MiniDet with Priority Writes tests if the content ğ‘¦of the reference is greater than ğ‘¥. If ğ‘¥< ğ‘¦, the function returns, because ğ‘¥maxğ‘¦= ğ‘¦. Else, the function attempts to overwrite ğ‘¦with ğ‘¥in ğ‘Ÿwith a CAS, and loops if it fails. As noted by Blelloch et al. [2012], if we break the abstractions of the priority reference, the implementation of pwrite is not internally deterministic: because pwrite reads ğ‘Ÿ, a location that can be written by a parallel task, different interleavings might see different values. However, because pwrite is carefully designed, these nondeterministic observations are not externally visible and do not impact the safety of the program. As we will see, this latter fact allow us to derive a Musketeer triple API to priority writes. However, because nondeterminism is involved internally in the implementation, we conduct the proof at the level of ChainedLog. Extension of MiniDet. Figure 16 shows how we extend our type system. We add two new type constructors, pwriteğ‘and preadğ‘, asserting that the reference is in a write phase with fraction ğ‘ or a read phase with fraction ğ‘, respectively. The monoid on types is extended to sum fractions. This definition implies, as we will see, that writes can happen in parallel with writes, and reads can happen in parallel with reads. The lower part of Figure 16 shows the new typing rules. T-PAlloc allocates a priority reference and returns a type pwrite 1. T-PWrite types a priority write on some reference ğ‘¥bound to the type pwriteğ‘. In particular, this rule does not require the full fraction 1, meaning that the write operation can happen in parallel of other write operations. T-PRead types a read similarly. Again this rule does not require the full fraction. T-Update allows for updating a typing context Î“ into Î“â€² as long as Î“ { Î“â€². This relation is defined pointwise over the elements of the environments as the update relation ğœ{ ğœâ€² which is defined last in Figure 16. U-Refl asserts that a type can stay the same, U-Pair distributes over pairs, U-R2W transforms a read type into a write one, if the fraction is the full permission 1. This precondition on the fraction is important: it asserts that no parallel task use the priority reference. U-W2R is symmetrical. Extending the soundness proof. To extend the soundness proof to support these new rules, we first prove specifications for the priority reference operations in Musketeer, shown in the upper part of Figure 17. These specifications involve two predicates: ispw â„“ğ‘ğ‘–, asserting that â„“is a priority reference, and that â„“is in its concurrent phase with fraction ğ‘and stores (at least) ğ‘–. Symmetrically, ispr â„“ğ‘ğ‘–asserts that â„“is in its read phase. The specification of pallocğ‘–asserts that this function Proc. ACM Program. Lang., Vol. 10, No. POPL, Article 26. Publication date: January 2026. 26:22 Alexandre Moine, Sam Westrick, and Joseph Tassarotti {âŠ¤} pallocğ‘– {ğœ†ğ‘Ÿ_. ispw â„“1ğ‘–} {ispw â„“ğ‘ğ‘–} pwrite â„“ğ‘—{ğœ†ğ‘Ÿâ„“. âŒœğ‘£= â„“âŒâˆ—ispw â„“ğ‘(ğ‘–max ğ‘—)} {ispr â„“ğ‘ğ‘–} pread â„“ {ğœ†ğ‘Ÿ_. âŒœğ‘£= ğ‘–âŒâˆ—ispr â„“1ğ‘–} ispw â„“(ğ‘1 + ğ‘2) (ğ‘–max ğ‘—) âŠ£âŠ¢ispw â„“ğ‘1 ğ‘–âˆ—ispw â„“ğ‘2 ğ‘— ispr â„“(ğ‘1 + ğ‘2) ğ‘–âŠ£âŠ¢ispr â„“ğ‘1 ğ‘–âˆ—ispr â„“ğ‘2 ğ‘– ispw â„“1ğ‘–âŠ£âŠ¢ispr â„“1ğ‘– ğ‘ â‰œÂ· Â· Â· | spwriteğ‘–| spreadğ‘– J pwriteğ‘| spwriteğ‘–| ğ‘£K â‰œâˆƒâ„“. âŒœğ‘£= â„“âŒâˆ—ispw â„“ğ‘ğ‘– J preadğ‘| spwriteğ‘–| ğ‘£K â‰œâˆƒâ„“. âŒœğ‘£= â„“âŒâˆ—ispr â„“ğ‘ğ‘– Fig. 17. Specifications of Priority Writes and Logical Interpretation alloc_fill â‰œ ğœ†ğ‘›ğ‘£. fill (alloc ğ‘›) ğ‘£ init â‰œ ğœ†â„ğ‘›. assert (ğ‘›â‰¥0); letğ‘‘= ref () in letğ‘= alloc_fillğ‘›ğ‘‘in (ğ‘,ğ‘‘,â„) elems â‰œ ğœ†(ğ‘,ğ‘‘,â„). filter_compactğ‘ğ‘‘ add â‰œ ğœ†(ğ‘,ğ‘‘,â„) ğ‘¥. letğ‘ğ‘¢ğ‘¡= ğœ‡ğ‘“ğ‘¥ğ‘–. letğ‘¦= ğ‘[ğ‘–] in ifğ‘¥== ğ‘¦then () else ifğ‘¥== ğ‘‘then (if CASğ‘ğ‘–ğ‘‘ğ‘¥then () else ğ‘“ğ‘¥ğ‘–) else let ğ‘—= (ğ‘–+ 1) mod (lengthğ‘) in ifğ‘¥< ğ‘¦then ğ‘“ğ‘¥ğ‘—else (if CASğ‘ğ‘–ğ‘¦ğ‘¥then ğ‘“ğ‘¦ğ‘—else ğ‘“ğ‘¥ğ‘–) in ğ‘ğ‘¢ğ‘¡ğ‘¥((â„ğ‘–) mod (lengthğ‘)) Fig. 18. Implementation of a Deterministic Concurrent Hash Set call returns a location â„“such that ispw â„“ğ‘1 holds. The specification of pwrite â„“ğ‘—updates a share ispw â„“ğ‘ğ‘–into ispw â„“ğ‘(ğ‘–max ğ‘—). The specification of pread â„“asserts that this function call returns the content of a priority reference, if this reference is in its read phase. The central part of Figure 17 shows the splitting and joining rules of the ispw and ispr assertions. It also shows that one can update a ispw assertion into a ispr assertion, and vice-versa, as long as the fraction in 1 (formally, these conversions involve the so-called ghost updates [Jung et al. 2018]). The lower part of Figure 17 intuits how we extend the logical relation backing the soundness of our type system. We add two shapes, one for each phase. We then extend the logical relation as expected, making use of the previous assertions. 7.3 Deterministic Concurrent Hash Sets Next, we extend MiniDet with a deterministic concurrent hash set, inspired by Shun and Blelloch [2014]. This hash set allows for concurrent, lock-free insertion, and offers a function elems that returns an array with the inserted elements in some arbitrary but deterministic order. This hash set is implemented as an array, and makes use of open addressing and linear probing to handle collision. The key idea to ensure determinism is that neighboring elements in the array are ordered according to a certain total order relation. As we will see, insertion preserves the ordering, which in turn ensures determinism of the contents of the array. Shun and Blelloch [2014] also propose a deletion function, which we do not verify. The hash set usage must be phased: insertion is allowed to take place in parallel as long as no task calls the function elems. Implementation of our hash set. Figure 18 presents the implementation of the deterministic hash set. While in our mechanization we support a hash set over arbitrary values, for space constraints we present here an implementation specialized to integers, equipped with the comparison function <. A new hash set is initialized with the function initâ„ğ‘›, which returns a tuple (ğ‘,ğ‘‘,â„), where ğ‘is the underlying array, ğ‘‘is a dummy element (in our case, a fresh reference containing the unit value) representing an empty slot in the array. The function â„is the hash function. The implementation uses a helper routine, alloc_fillğ‘›ğ‘‘, which allocates an array and fills it with the value ğ‘£using a Proc. ACM Program. Lang., Vol. 10, No. POPL, Article 26. Publication date: January 2026. All for One and One for All: Program Logics for Exploiting Internal Determinism in Parallel Programs 26:23 ğœâ‰œÂ· Â· Â· | intarrayğ‘| intsetğ‘ intarrayğ‘1 Â· intarrayğ‘2 â‰œintarray (ğ‘1 + ğ‘2) intsetğ‘1 Â· intsetğ‘2 â‰œintset (ğ‘1 + ğ‘2) T-AAlloc Î“1 âŠ¢ğ‘’1 : int âŠ£Î“2 Î“2 âŠ¢ğ‘’2 : int âŠ£Î“3 Î“ âŠ¢alloc_fillğ‘’2 ğ‘’1 : intarray 1 âŠ£Î“3 T-ALoad Î“1 âŠ¢ğ‘’: int âŠ£Î“2 Î“2(ğ‘¥) = intarrayğ‘ Î“1 âŠ¢ğ‘¥[ğ‘’] : int âŠ£Î“2 T-AStore Î“1 âŠ¢ğ‘’1 : int âŠ£Î“2 Î“2 âŠ¢ğ‘’2 : int âŠ£Î“3 Î“3(ğ‘¥) = intarray 1 Î“ âŠ¢ğ‘¥[ğ‘’2] â†ğ‘’1 : unit âŠ£Î“3 T-SAlloc Î“ âŠ¢ğ‘’: int âŠ£Î“â€² (âˆ€ğ‘¥. {âŠ¤} â„ğ‘¥{ğœ†ğ‘£_. âŒœğ‘£= â„ğ‘ğ‘ â„(ğ‘¥)âŒ}) Î“ âŠ¢initâ„ğ‘’: intset 1 âŠ£Î“â€² T-SAdd Î“ âŠ¢ğ‘’: int âŠ£Î“â€² Î“â€²(ğ‘¥) = intsetğ‘ Î“ âŠ¢addğ‘¥ğ‘’: unit âŠ£Î“â€² T-SElems Î“ âŠ¢ğ‘’: intset 1 âŠ£Î“â€² Î“ âŠ¢elemsğ‘’: intarray 1 âŠ£Î“â€² Fig. 19. Extension of MiniDet with Integer Arrays and Hash Set function fill, which we omit for brevity. The function elems (ğ‘,ğ‘‘,â„) returns a fresh array containing the elements of ğ‘obtained by filtering those equal to the dummy element ğ‘‘. The key challenge in the design is to ensure that this operation will be deterministic: in conventional linear probing hash tables, the order of elements in the array would depend on the order of insertions, so concurrent insertions would lead to nondeterministic orders. To avoid this nondeterminism, the function add (ğ‘,ğ‘‘,â„) ğ‘¥, which inserts ğ‘¥in the hash set (ğ‘,ğ‘‘,â„), enforces an ordering on elements in the array according to the comparison function <. The code makes use of a recursive auxiliary function ğ‘ğ‘¢ğ‘¡, parameterized by an element ğ‘¥and an index ğ‘–, which tries to insert ğ‘¥at ğ‘–. The function ğ‘ğ‘¢ğ‘¡loads the content of the array ğ‘at offset ğ‘–and names it ğ‘¦. If ğ‘¦is equal to ğ‘¥, then ğ‘¥is already in the set and the function returns. If ğ‘¦is equal to the dummy element, the function tries a CAS to replace ğ‘¦with ğ‘¥, and loops in case the CAS fails. Otherwise, ğ‘¦ is an element distinct from ğ‘¥. The function names the next index ğ‘—= (ğ‘–+ 1) mod (lengthğ‘) and tests if ğ‘¥< ğ‘¦. If ğ‘¦is greater than ğ‘¥, the function tries to insert ğ‘¥at the next index ğ‘—by doing a recursive call of ğ‘“ğ‘¥ğ‘—. If ğ‘¥is greater than ğ‘¦, the function tries to replace ğ‘¦with ğ‘¥with a CAS, and loops if the CAS fails. If the CAS succeeds, the function removed ğ‘¦from the hash set, and must hence insert it again by doing a recursive call ğ‘“ğ‘¦ğ‘—. The function add then simply calls ğ‘ğ‘¢ğ‘¡to insert ğ‘¥at the initial index (â„ğ‘¥) mod (lengthğ‘). Extension of MiniDet. Figure 19 presents the extension of MiniDet with this hash set. To avoid issues related to ownership of the elements in the set, we consider a hash set containing integers. We add two new types: intarrayğ‘describing an array of integers with a fraction ğ‘and intsetğ‘a hash set of integers with a fraction ğ‘. The monoid on types is extended to sum the fractions. T-AAlloc types the allocation of an array filled with a default element. T-ALoad types a load operation on an array bound to the variable ğ‘¥. This operation requires any fraction of intarray. T-AStore types a store operation but requires full ownership of the arrayâ€”that is, the fraction 1. T-SAlloc allocates a hash set. This rule has one non-syntactical precondition, which cannot be handled by a type system. It requires that the hash functionâ„, the first parameter of add, implements some arbitrary pure function â„ğ‘ğ‘ â„: V â†’ğ‘. This proof can be derived in Musketeer, and ensures that calls to the hash function are deterministic. T-SAlloc returns a intset type with fraction 1. T-SAdd types an add operation on a hash set ğ‘¥with an arbitrary fraction ğ‘, meaning that this operation can happen in parallel. T-SElems types the elems operation, requiring the full ownership Proc. ACM Program. Lang., Vol. 10, No. POPL, Article 26. Publication date: January 2026. 26:24 Alexandre Moine, Sam Westrick, and Joseph Tassarotti (âˆ€ğ‘¥. {âŠ¤} â„ğ‘¥{ğœ†ğ‘£_. âŒœğ‘£= â„ğ‘ğ‘ â„(ğ‘¥)âŒ}) {âŠ¤} initâ„ğ‘–{ğœ†ğ‘£_. hashsetğ‘£1 âˆ…} {hashsetğ‘£ğ‘ğ‘‹} addğ‘£ğ‘–{ğœ†ğ‘Ÿ_. hashsetğ‘£ğ‘({ğ‘–} âˆªğ‘‹)} {hashsetğ‘£1ğ‘‹} elemsğ‘£{ğœ†ğ‘£â€² (â„“, Â®ğ‘¤). âŒœğ‘£â€² = â„“âŒâˆ—â„“â†¦â†’Â®ğ‘¤} hashsetğ‘£(ğ‘1 + ğ‘2) (ğ‘‹1 âˆªğ‘‹2) âŠ£âŠ¢hashsetğ‘£ğ‘1 ğ‘‹1 âˆ—hashsetğ‘£ğ‘2 ğ‘‹2 ğ‘  â‰œ Â· Â· Â· | sintsetğ‘‹ J intsetğ‘| sintsetğ‘‹| ğ‘£K â‰œ hashsetğ‘£ğ‘ğ‘‹ Fig. 20. Specifications of a Deterministic Hash Set and Logical Interpretation parfor â‰œË†ğœ‡ğ‘“. ğœ†ğ‘–ğ‘—ğ‘˜. if (ğ‘—âˆ’ğ‘–) ==0 then () else if (ğ‘—âˆ’ğ‘–) == 1 then ğ‘˜ğ‘– else let ğ‘šğ‘–ğ‘‘= ğ‘–+ ((ğ‘—âˆ’ğ‘–)/2) in par (ğ‘“ğ‘–ğ‘šğ‘–ğ‘‘ğ‘˜) (ğ‘“ğ‘šğ‘–ğ‘‘ğ‘—ğ‘˜) dedup â‰œğœ†â„ğ‘. letğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡= 0 in letğ‘™ğ‘’ğ‘›= lengthğ‘in letğ‘ = initâ„(ğ‘™ğ‘’ğ‘›+ 1) in parforğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ‘™ğ‘’ğ‘›(ğœ†ğ‘–. addğ‘ (ğ‘[ğ‘–])); prodğ‘(elemsğ‘ ) Fig. 21. Implementation of parfor and dedup Functions of a hash set, and producing a fresh array. This operation consumes the hash set argument; this is for simplicity: the hash set is only read and is in fact preserved by the operation. Extending the soundness proof. The upper part of Figure 20 presents the Musketeer specifications of the hash set operations. These specifications make use of an assertion hashsetğ‘£ğ‘ğ‘‹asserting that ğ‘£is a hash set with fraction ğ‘and content at least ğ‘‹, a set of values. When ğ‘= 1, then ğ‘‹is exactly the set of values in the set. The specification of initâ„ğ‘–returns a fresh set with fraction 1 and no elements, provided that the parameter â„behaves correctly. The specification of addğ‘£ğ‘–verifies the insertion of an integer ğ‘–in a hash set ğ‘£with an arbitrary fraction ğ‘and current content ğ‘‹, which the function call updates to ({ğ‘–} âˆªğ‘‹). Since we specialize to hash sets of integers, we know that the inserted value will not be the dummy element. In our mechanization, we offer a more general specification, allowing the user to insert other pointers as long as they ensure that the inserted pointer is not the dummy element. Perhaps most importantly, the specification of elemsğ‘£consumes an assertion hashsetğ‘£1ğ‘‹with fraction 1 and produces an array â„“with a deterministic content Â®ğ‘¤. Figure 20 then gives the reasoning rule for splitting a hashset assertion, enabling parallel use. The lower part of Figure 20 shows how we extend the logical relation. We add a shape sintsetğ‘‹, where ğ‘‹a set of integers. The interpretation of intsetğ‘with shape sintsetğ‘‹and value ğ‘£is then simply hashsetğ‘£ğ‘ğ‘‹. 7.4 Deduplication via Concurrent Hashing For our last example, we consider array deduplication, one of the parallel benchmark problems proposed by Blelloch et al. [2012]. The task is to take an array of elements and return an array containing the same elements but with duplicates removed. The solution proposed by Blelloch et al. [2012] is to simply insert all the elements in parallel into a deterministic hash set and then return the elements of the hash set. Figure 21 presents dedup, an implementation of this algorithm in MusketLang. To do the parallel inserts, it uses a helper routine called parforğ‘–ğ‘—ğ‘˜, which runs (ğ‘˜ğ‘›) in parallel for all ğ‘›between ğ‘–and ğ‘—. Our goal is to prove that dedup satisfies schedule-independent safety, and then prove a specification in Angelic. Throughout this proof, we assume that we have some hash function â„such that âˆ€ğ‘¥. {âŠ¤} (â„ğ‘¥) {ğœ†ğ‘£_. âŒœğ‘£= â„ğ‘ğ‘ â„ğ‘¥âŒ} and âˆ€ğ‘¥. run (â„ğ‘¥) {ğœ†ğ‘£. âŒœğ‘£= â„ğ‘ğ‘ â„ğ‘¥âŒ}, where â„ğ‘ğ‘ â„is some function in the meta-logic. Our first step is to show that dedup can be typed in MiniDet. This follows by using a typing rule for parfor (given in Appendix C.1), and the earlier typing rules we derived for the hash set. Using Proc. ACM Program. Lang., Vol. 10, No. POPL, Article 26. Publication date: January 2026. All for One and One for All: Program Logics for Exploiting Internal Determinism in Parallel Programs 26:25 these, we derive âˆ…âŠ¢dedupâ„: intarrayğ‘â†’(intarrayğ‘Ã— intarray 1) âŠ£âˆ…. Thus, for a well-typed input array ğ‘, dedupâ„ğ‘satisfies schedule-independent safety. We then verify dedup using Angelic. The proof uses Angelic reasoning rules for the hash set, shown in Appendix C.2, which are similar to the earlier Musketeer specifications (Â§7.3), except for three key points. First, the Angelic specification shows that, for a set ğ‘£with content ğ‘‹, elemsğ‘£ returns an array Â®ğ‘¤which contains just the elements of the set ğ‘‹. Second, the representation predicate for the hash set has no fraction: there is never a need for splitting it in Angelic. Third, as we require the user to prove termination, the representation predicate tracks how many elements have been inserted, and does not allow inserting into a full table. Finally, we use a derived specification for parforğ‘–ğ‘—ğ‘˜that allows us to reason about it as if it were a sequential for-loop: forspecğ‘–ğ‘—ğ‘˜ğœ‘âŠ¢run (parforğ‘–ğ‘—ğ‘˜) {ğœ†ğ‘£. âŒœğ‘£= ()âŒâˆ—ğœ‘} Here, forspecğ‘–ğ‘—ğ‘˜ğœ‘is defined recursively as forspecğ‘–ğ‘—ğ‘˜ğœ‘â‰œ  âŒœğ‘–â‰¥ğ‘—âŒâˆ—ğœ‘ âˆ¨  âŒœğ‘–< ğ‘—âŒâˆ—run (ğ‘˜ğ‘–) {ğœ†ğ‘£. âŒœğ‘£= ()âŒâˆ—forspec (ğ‘–+ 1) ğ‘—ğ‘˜ğœ‘}  In this definition, either ğ‘–â‰¥ğ‘—and the postcondition holds (since there are no recursive calls to be done), or ğ‘–< ğ‘—, and the user has to verify ğ‘˜ğ‘–, and show that forspec (ğ‘–+ 1) ğ‘—ğ‘˜ğœ‘holds afterward. Essentially, this generalizes the idea we saw earlier in A-ParSeqL, by having us verify an interleaving that executes each task sequentially from ğ‘–to ğ‘—. With these specifications, we deduce the following Angelic specification for dedup: â„“â†¦â†’ğ‘Â®ğ‘£âŠ¢run (dedupâ„â„“) {ğœ†ğ‘£. âˆƒâ„“â€² Â®ğ‘¤. â„“â†¦â†’ğ‘Â®ğ‘£âˆ—â„“â€² â†¦â†’Â®ğ‘¤âˆ—âŒœdeduped Â®ğ‘¤Â®ğ‘£âŒ} 8 Related Work Deterministic parallel languages. As shown in Section 7.1, Musketeer can be used to prove the soundness of language-based techniques for enforcing determinism. A large body of such techniques exist, and it would be interesting to apply Musketeer to some of these. In general, these languages typically ensure determinism by restricting side effects (e.g., in purely functional languages) or by providing the programmer with fine-grained control over scheduling of effects (e.g., in the form of a powerful type-and-effect system). Examples include seminal works such as Id [Arvind et al. 1989] and NESL [Blelloch et al. 1994] as well as related work on Deterministic Parallel Java [Bocchino Jr. et al. 2009, 2011], parallelism in Haskell [Jones et al. 2008; Keller et al. 2010; Chakravarty et al. 2011, 2001; Marlow et al. 2011], the LVars/LVish framework [Kuper et al. 2014a,b; Kuper and Newton 2013], Liquid Effects [Kawaguchi et al. 2012]. Manticore [Fluet et al. 2007], SAC [Scholz 2003], Halide [Ragan-Kelley et al. 2013], Futhark [Henriksen et al. 2017], and many others. It is typically challenging to formally prove sequentialization or determinization results for these kinds of languages, particularly in an expressive language with features like higher-order state and recursive types. For example, Krogh-Jespersen et al. [2017] point out that it took 25 years for the first results proving that in a type-and-effect system, appropriate types can ensure that a parallel pair is contextually equivalent to a sequential pair. They show how a program-logic based logical relation, like the one we used in Section 7, can vastly simplify such proofs. Musketeer provides a program logic that is well-suited for constructing models to prove whole-language determinism properties. Although not discussed in this paper, we have already completed a proof of schedule-independent safety for a simplified model of the LVars framework. We believe similar results may be possible for other deterministic-by-construction languages. Logic for hyperproperties. So-called relational program logics have been developed to prove hyperproperties. Naumann [2020] provides an extensive survey of these logics. A number of such Proc. ACM Program. Lang., Vol. 10, No. POPL, Article 26. Publication date: January 2026. 26:26 Alexandre Moine, Sam Westrick, and Joseph Tassarotti logics support very general classes of hyperproperties [Dâ€™Osualdo et al. 2022; Sousa and Dillig 2016]. However, most of the relational logics building on concurrent separation logic have been restricted âˆ€âˆƒhyperproperties [Liang and Feng 2016; Frumin et al. 2021; GÃ¤her et al. 2022; Timany et al. 2024a]. Because schedule-independent safety is a âˆ€âˆ€property, it falls outside the scope of these logics, which motivated our development of ChainedLog. In the world of âˆ€âˆ€hyperproperties, several Iris-based relational logics have been proposed. For example, Frumin et al. [2021] and Gregersen et al. [2021] verify variations of non-interference in a sequential setting. Both works require that both executions terminate. However, their underlying relational logics do not support Musketeerâ€™s distinctive feature: the chaining rule C-Chain. In another setting, Timany et al. [2017] present a logical relation showing that Haskellâ€™s ST monad [Launchbury and Peyton Jones 1995] properly encapsulates state. They show such a result using a state-independence property which intuitively asserts that, for a well-typed program, if one execution terminates with a particular initial heap, then every execution terminates with any other initial heap. Most logics for hyperproperties are structured as relational logics. However, some, like Musketeer, prove a hyperproperty through unary reasoning. For example, Dardinier and MÃ¼ller [2024], target arbitrary hyperproperties for a pure language, with a triple referring to a single expression, but with pre/post-conditions describing multiple executions. Eilers et al. [2023] present CommCSL, a concurrent separation logic for proving abstract commutativity, that is, where two operations commute up-to some abstract interface. This idea appears for example in the API for priority writes, which implies that writes commutes (Â§7.2). In contrast with our approach, CommCSL is globally parameterized by a set of specifications the logic ensures commute. In Musketeer, no such parameterization is needed: proof obligations are entirely internalized. Commutativity-Based Reasoning. Schedule-independent safety reduces the problem of verifying safety for all executions of a program to just verifying safety of any one terminating execution. This can be seen as an extreme form of a common technique in concurrent program verification, in which the set of possible executions of a program is partitioned into equivalence classes, and then a representative element of each equivalence class is verified [Farzan 2023]. This approach has its origins in the work of Lipton [1975], and typically uses some form of analysis to determine when statements in a program commute in order to restructure programs into an equivalent form that reduces the set of possible nondeterministic outcomes [Elmas et al. 2009; Kragl and Qadeer 2021; von Gleissenthall et al. 2019; Farzan et al. 2022]. For programs satisfying schedule-independent safety, there is effectively only one equivalence class, allowing a user of Angelic to dynamically select one ordering to verify. 9 Conclusion and Future Work Schedule-independent safety captures the essence of why internal determinism simplifies reasoning about parallel programs. In this paper, we have shown how Musketeer provides an expressive platform for proving that language-based techniques ensure schedule-independent safety, and how Angelic can take advantage of schedule-independent safety. One limitation of schedule-independent safety is that it is restricted to safety properties. In future work, it would be interesting to extend Musketeer for proving that liveness properties, such as termination, are also schedule-independent. Acknowledgments This work was supported by the National Science Foundation through grant no. 2318722 and 2319168. The authors thank the anonymous reviewers of the paper and associated artifact for their feedback. Proc. ACM Program. Lang., Vol. 10, No. POPL, Article 26. Publication date: January 2026. All for One and One for All: Program Logics for Exploiting Internal Determinism in Parallel Programs 26:27 unsafe â‰œletğ‘Ÿ= ref true in par (setğ‘Ÿtrue) (setğ‘Ÿfalse); assert (getğ‘Ÿ) Fig. 22. An Unsafe Code A A Counter-Example to the Existantial Elimination Rule in Musketeer In this section, we explain in more detail why adding the standard separation logic rule for elimi- nating an existential to Musketeer would be unsound. Consider the unsafe program presented in Figure 22. This program allocates a reference ğ‘Ÿ initialized to false, then executes in parallel two writes, the left one setting ğ‘Ÿto true, and the right one to false. After the parallel phase, the program asserts that the content of ğ‘Ÿis true. This program does not satisfy schedule-independent safety. Indeed, if the left write is scheduled before the right one, ğ‘Ÿwill contain false and the assert will fail. Hence, Musketeer must reject the unsafe program. Yet, let us attempt a Musketeer proof, and let us show that this proof would succeed if the user is able to eliminate an existential without restriction. Let us attempt to verify the following triple {âŠ¤} unsafe {ğœ†_ _. âŠ¤} After the allocation of ğ‘Ÿ, we have to verify {ğ‘Ÿâ†¦â†’false} par (setğ‘Ÿtrue) (setğ‘Ÿfalse); assert (getğ‘Ÿ) {ğœ†_ _. âŠ¤} Because the program next performs a concurrent write on the same location ğ‘Ÿ, we have to use an invariant in order to share the ownership of ğ‘Ÿbetween the two tasks. Let us pick the invariant (âˆƒğ‘¥.ğ‘Ÿâ†¦â†’ğ‘¥). We now have to verify { âˆƒğ‘¥.ğ‘Ÿâ†¦â†’ğ‘¥} par (setğ‘Ÿtrue) (setğ‘Ÿfalse); assert (getğ‘Ÿ) {ğœ†_ _. âŠ¤} Using M-Store and standard rules for invariants, we can easily establish the intermediate triple âˆ€ğ‘›. { âˆƒğ‘¥.ğ‘Ÿâ†¦â†’ğ‘¥} setğ‘Ÿğ‘›{ğœ†_ _. âŠ¤}. Using this intermediate triple, the fact that we can duplicate invariants and rules M-Par and M-Bind, we are left with proving { âˆƒğ‘¥.ğ‘Ÿâ†¦â†’ğ‘¥} assert (getğ‘Ÿ) {ğœ†_ _. âŠ¤} We apply M-Bind to focus on the sub-expression (getğ‘Ÿ) with the weakest possible intermediate postcondition ğ‘„â€², that is we instantiate ğ‘„â€² with (ğœ†_ _.âŠ¤). The two preconditions of M-Bind are { âˆƒğ‘¥.ğ‘Ÿâ†¦â†’ğ‘¥} getğ‘Ÿ{ğœ†_ _. âŠ¤} and âˆ€ğ‘£. {âŠ¤} assertğ‘£{ğœ†_ _. âŠ¤} The right triple immediately follows from M-Assert. Using the opening rule of invariants on the left triple, we have to verify {âˆƒğ‘¥.ğ‘Ÿâ†¦â†’ğ‘¥} getğ‘Ÿ{ğœ†_ _. âˆƒğ‘¥.ğ‘Ÿâ†¦â†’ğ‘¥} In order to conclude, one has to eliminate the existential, before using M-Load. Thankfully, Muske- teer prevents the user from eliminating the existential, and the proof ultimately fails. What happened here? The existential quantification onğ‘¥hid the fact that there are two possible scheduling-dependent witnesses (true and false). Proc. ACM Program. Lang., Vol. 10, No. POPL, Article 26. Publication date: January 2026. 26:28 Alexandre Moine, Sam Westrick, and Joseph Tassarotti S-Empty empty â‰ˆempty S-Unit unit â‰ˆunit S-Bool bool â‰ˆbool S-Int int â‰ˆint S-HashSet intsetğ‘1 â‰ˆintsetğ‘2 S-Array intarrayğ‘1 â‰ˆintarrayğ‘2 S-Ref refğœ1 â‰ˆrefğœ2 S-Arrow ğœ1 â†’ğœ2 â‰ˆğœ1 â†’ğœ2 S-Prod ğœ1 â‰ˆğœâ€² 1 ğœ2 â‰ˆğœâ€² 2 (ğœ1 Ã— ğœ2) â‰ˆ(ğœâ€² 1 Ã— ğœâ€² 2) S-PRead ğœ= preadğ‘2 âˆ¨ğœ= pwriteğ‘2 preadğ‘1 â‰ˆğœ S-PWrite ğœ= preadğ‘2 âˆ¨ğœ= pwriteğ‘2 pwriteğ‘1 â‰ˆğœ Fig. 23. Similar Predicate on Types S-SNone snone â‰ˆsnone S-SHashSet sintsetğ‘‹1 â‰ˆsintsetğ‘‹2 S-SArray sintarray Â®ğ‘£1 â‰ˆsintarray Â®ğ‘£2 S-SRef srefğ‘£1 â‰ˆrefğ‘£2 S-SArrow sarrowğ›¾â‰ˆsarrowğ›¾ S-SProd ğ‘ 1 â‰ˆğ‘ â€² 1 ğ‘ 2 â‰ˆğ‘ â€² 2 sprodğ‘ 1 ğ‘ 2 â‰ˆsprodğ‘ â€² 1 ğ‘ â€² 2 S-SPRead ğ‘ = spreadğ‘–2 âˆ¨ğ‘ = spwriteğ‘–2 spreadğ‘–1 â‰ˆğ‘  S-SWrite ğ‘ = spreadğ‘–2 âˆ¨ğ‘ = spwriteğ‘–2 spwriteğ‘–1 â‰ˆğ‘  Fig. 24. Similar Predicate on Shapes T-ParFor Î“(ğ‘¥) = Î“(ğ‘¦) = int Fractional Î“ Î“ğ‘“ âˆ€ğ‘. [ğ‘–:= int](Î“ğ‘“ğ‘) âŠ¢ğ‘’: unit âŠ£Î“ğ‘“ğ‘ Î“ âŠ¢parforğ‘¥ğ‘¦(ğœ†ğ‘–. ğ‘’) : unit âŠ£Î“ Fig. 25. A MiniDet Type for parfor B Definition of the Similarity between Typing and Shape Environments Figure 23 shows the definition of ğœ1 â‰ˆğœ2, asserting that the two MiniDet types ğœ1 and ğœ2 are similar (Â§7.1). This property asserts that both types have the same structure except that functions must be equal and that priority reads and priority writes are identified. Figure 24 shows the definition of ğ‘ 1 â‰ˆğ‘ 2, asserting that the two shapes ğ‘ 1 and ğ‘ 2 are similar. This property asserts that both shapes have the same structure, except that function shapes must be equal and that priority reads and priority writes are identified. We extend these two predicates to maps ğ‘š1 â‰ˆğ‘š2 as the trivial predicate for the keys not in the intersection of dom(ğ‘š1) and dom(ğ‘š2) and the similar predicate when a key appears in both maps. C Additional Explanations on the Concurrent Hash Set Example C.1 A Typing Rule for parfor In order to give a type in MiniDet to dedup (Â§7.4), we first give parfor a type, which we prove sound by dropping to the semantic model. T-ParFor, which appear in Figure 25, requires the two indices to be variables bound to integers, for simplicity. It then requires the environment Î“ to be fractional, that is, to contain only fractional assertion. This is witnessed by the precondition Fractional Î“ Î“ğ‘“which is defined as (âˆ€ğ‘›.ğ‘›â‰ 0 =â‡’Î“ = Â·ğ‘›(Î“ğ‘“ğ‘›)), that is, for every positive integer ğ‘›, Î“ğ‘“ğ‘›represents a n-th share of Î“. Finally, T-ParFor requires to type the last argument of parfor, which must be a function of the form ğœ†ğ‘–.ğ‘’. The precondition requires that ğ‘’is typeable while borrowing a share Î“ğ‘“ğ‘›of the environment. Proc. ACM Program. Lang., Vol. 10, No. POPL, Article 26. Publication date: January 2026. All for One and One for All: Program Logics for Exploiting Internal Determinism in Parallel Programs 26:29 A-HAlloc (âˆ€ğ‘¥. run (â„ğ‘¥) {ğœ†ğ‘£.âŒœğ‘£= â„ğ‘ğ‘ â„ğ‘¥âŒ}) run (initâ„ğ‘–) {ğœ†ğ‘£. ahashsetğ‘–ğ‘£âˆ…} A-HAdd âŒœğ‘ ğ‘–ğ‘§ğ‘’ğ‘‹< ğ‘–âŒ ahashsetğ‘–ğ‘£ğ‘‹ run (addğ‘£ğ‘¥) {ğœ†ğ‘¤. âŒœğ‘¤= ()âŒâˆ—ahashsetğ‘–ğ‘£({ğ‘¥} âˆªğ‘‹)} A-HElems ahashsetğ‘–ğ‘£ğ‘‹ run (elemsğ‘£) {ğœ†ğ‘£â€². âˆƒâ„“Â®ğ‘¤. âŒœğ‘£â€² = â„“âŒâˆ—â„“â†¦â†’Â®ğ‘¤âˆ—âŒœdedupedğ‘‹Â®ğ‘¤âŒ} Fig. 26. Angelic Specifications for a Concurrent Hash Set C.2 Angelic Reasoning Rules for our Concurrent Hash Set Figure 26 presents the Angelic reasoning rules for our councurrent hash set (Â§7.3). These spec- ifications involve a representation predicate ahashsetğ‘–ğ‘£ğ‘‹, where ğ‘–is the capacity (that is, the maximum number that can be contained in the set), ğ‘£is the hash set and ğ‘‹the logical set with the inserted element. Note that this predicate is not fractional, as there is no need to ever split it. A-HAlloc verifies initâ„ğ‘–. The precondition requires that the hash function â„implements a hash function in the meta-logic. A-HAdd verifies addğ‘£ğ‘¥. The precondition requires that ğ‘£is a set with content ğ‘‹and capacity ğ‘–. The user must ensure that the size of the set ğ‘‹is less than the capacity, in order to guarantee termination. The postcondition returns the set with an updated model. A-HElems verifies elemsğ‘£. The precondition requires ğ¶3 ğ‘–that ğ‘£is a set with content ğ‘‹. The postcondition returns a fresh array â„“pointing to Â®ğ‘¤such that dedupedğ‘‹Â®ğ‘¤holds. Proc. ACM Program. Lang., Vol. 10, No. POPL, Article 26. Publication date: January 2026. 26:30 Alexandre Moine, Sam Westrick, and Joseph Tassarotti References Arvind, Rishiyur S. Nikhil, and Keshav Pingali. 1989. I-Structures: Data Structures for Parallel Computing. ACM Trans. Program. Lang. Syst. 11, 4 (1989). doi:10.1145/69558.69562 Amittai Aviram, Shu-Chun Weng, Sen Hu, and Bryan Ford. 2010. Efficient System-Enforced Deterministic Parallelism. In 9th USENIX Symposium on Operating Systems Design and Implementation, OSDI 2010, October 4-6, 2010, Vancouver, BC, Canada, Proceedings, Remzi H. Arpaci-Dusseau and Brad Chen (Eds.). USENIX Association. http://www.usenix.org/ events/osdi10/tech/full_papers/Aviram.pdf Guy E. Blelloch, Jeremy T. Fineman, Phillip B. Gibbons, and Julian Shun. 2012. Internally deterministic parallel algorithms can be fast. In PPoPP â€™12 (New Orleans, Louisiana, USA). Guy E. Blelloch, Jonathan C. Hardwick, Jay Sipelstein, Marco Zagha, and Siddhartha Chatterjee. 1994. Implementation of a Portable Nested Data-Parallel Language. J. Parallel Distributed Comput. 21, 1 (1994). doi:10.1006/JPDC.1994.1038 Robert L. Bocchino Jr., Vikram S. Adve, Danny Dig, Sarita V. Adve, Stephen Heumann, Rakesh Komuravelli, Jeffrey Overbey, Patrick Simmons, Hyojin Sung, and Mohsen Vakilian. 2009. A type and effect system for deterministic parallel Java. In Proceedings of the 24th Annual ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications, OOPSLA 2009, October 25-29, 2009, Orlando, Florida, USA, Shail Arora and Gary T. Leavens (Eds.). ACM. doi:10.1145/1640089.1640097 Robert L. Bocchino Jr., Stephen Heumann, Nima Honarmand, Sarita V. Adve, Vikram S. Adve, Adam Welc, and Tatiana Shpeisman. 2011. Safe nondeterminism in a deterministic-by-default parallel language. In Proceedings of the 38th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL, Thomas Ball and Mooly Sagiv (Eds.). ACM. doi:10.1145/1926385.1926447 Richard Bornat, Cristiano Calcagno, Peter Oâ€™Hearn, and Matthew Parkinson. 2005. Permission accounting in separation logic. In Principles of Programming Languages (POPL). 259â€“270. http://www.cs.ucl.ac.uk/staff/p.ohearn/papers/permissions_ paper.pdf John Boyland. 2003. Checking Interference with Fractional Permissions. In Static Analysis Symposium (SAS) (Lecture Notes in Computer Science, Vol. 2694). Springer, 55â€“72. https://doi.org/10.1007/3-540-44898-5_4 Manuel M. T. Chakravarty, Gabriele Keller, Roman Lechtchinsky, and Wolf Pfannenstiel. 2001. Nepal - Nested Data Parallelism in Haskell. In Euro-Par 2001: Parallel Processing, 7th International Euro-Par Conference Manchester, UK August 28-31, 2001, Proceedings (Lecture Notes in Computer Science, Vol. 2150), Rizos Sakellariou, John A. Keane, John R. Gurd, and Len Freeman (Eds.). Springer. doi:10.1007/3-540-44681-8_76 Manuel M. T. Chakravarty, Gabriele Keller, Sean Lee, Trevor L. McDonell, and Vinod Grover. 2011. Accelerating Haskell array codes with multicore GPUs. In Proceedings of the POPL 2011 Workshop on Declarative Aspects of Multicore Programming, DAMP, Manuel Carro and John H. Reppy (Eds.). ACM. doi:10.1145/1926354.1926358 Michael R. Clarkson and Fred B. Schneider. 2010. Hyperproperties. J. Comput. Secur. 18, 6 (2010). doi:10.3233/JCS-2009-0393 Thibault Dardinier and Peter MÃ¼ller. 2024. Hyper Hoare Logic: (Dis-)Proving Program Hyperproperties. Proc. ACM Program. Lang. 8, PLDI (2024). doi:10.1145/3656437 Emanuele Dâ€™Osualdo, Azadeh Farzan, and Derek Dreyer. 2022. Proving hypersafety compositionally. Proc. ACM Program. Lang. 6, OOPSLA2 (2022). doi:10.1145/3563298 Marco Eilers, Thibault Dardinier, and Peter MÃ¼ller. 2023. CommCSL: Proving Information Flow Security for Concurrent Programs using Abstract Commutativity. Proc. ACM Program. Lang. 7, PLDI (June 2023). doi:10.1145/3591289 Tayfun Elmas, Shaz Qadeer, and Serdar Tasiran. 2009. A calculus of atomic actions. In Proceedings of the 36th ACM SIGPLAN- SIGACT Symposium on Principles of Programming Languages, POPL, Zhong Shao and Benjamin C. Pierce (Eds.). ACM. doi:10.1145/1480881.1480885 Azadeh Farzan. 2023. Commutativity in Automated Verification. In 38th Annual ACM/IEEE Symposium on Logic in Computer Science, LICS. IEEE. doi:10.1109/LICS56636.2023.10175734 Azadeh Farzan, Dominik Klumpp, and Andreas Podelski. 2022. Sound sequentialization for concurrent program verification. In PLDI â€™22: 43rd ACM SIGPLAN International Conference on Programming Language Design and Implementation, Ranjit Jhala and Isil Dillig (Eds.). ACM. doi:10.1145/3519939.3523727 Matthew Fluet, Mike Rainey, John H. Reppy, Adam Shaw, and Yingqi Xiao. 2007. Manticore: a heterogeneous parallel language. In Proceedings of the POPL 2007 Workshop on Declarative Aspects of Multicore Programming, DAMP, Neal Glew and Guy E. Blelloch (Eds.). ACM. doi:10.1145/1248648.1248656 Dan Frumin, Robbert Krebbers, and Lars Birkedal. 2021. ReLoC Reloaded: A Mechanized Relational Logic for Fine-Grained Concurrency and Logical Atomicity. Logical Methods in Computer Science 17, 3 (2021). https://arxiv.org/abs/2006.13635v3 Lennard GÃ¤her, Michael Sammler, Simon Spies, Ralf Jung, Hoang-Hai Dang, Robbert Krebbers, Jeehoon Kang, and Derek Dreyer. 2022. Simuliris: a separation logic framework for verifying concurrent program optimizations. Proceedings of the ACM on Programming Languages 6, POPL (2022), 1â€“31. https://doi.org/10.1145/3498689 Simon Oddershede Gregersen, Johan Bay, Amin Timany, and Lars Birkedal. 2021. Mechanized logical relations for termination-insensitive noninterference. Proc. ACM Program. Lang. 5, POPL (Jan. 2021). doi:10.1145/3434291 Proc. ACM Program. Lang., Vol. 10, No. POPL, Article 26. Publication date: January 2026. All for One and One for All: Program Logics for Exploiting Internal Determinism in Parallel Programs 26:31 Troels Henriksen, Niels G. W. Serup, Martin Elsman, Fritz Henglein, and Cosmin E. Oancea. 2017. Futhark: purely functional GPU-programming with nested parallelism and in-place array updates. In Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI, Albert Cohen and Martin T. Vechev (Eds.). ACM. doi:10.1145/3062341.3062354 Simon L. Peyton Jones, Roman Leshchinskiy, Gabriele Keller, and Manuel M. T. Chakravarty. 2008. Harnessing the Multicores: Nested Data Parallelism in Haskell. In IARCS Annual Conference on Foundations of Software Technology and Theoretical Computer Science (LIPIcs, Vol. 2), Ramesh Hariharan, Madhavan Mukund, and V. Vinay (Eds.). Schloss Dagstuhl - Leibniz-Zentrum fÃ¼r Informatik. doi:10.4230/LIPICS.FSTTCS.2008.1769 Ralf Jung, Robbert Krebbers, Jacques-Henri Jourdan, AleÅ¡ Bizjak, Lars Birkedal, and Derek Dreyer. 2018. Iris from the ground up: A modular foundation for higher-order concurrent separation logic. Journal of Functional Programming 28 (2018), e20. https://people.mpi-sws.org/~dreyer/papers/iris-ground-up/paper.pdf Ming Kawaguchi, Patrick Maxim Rondon, Alexander Bakst, and Ranjit Jhala. 2012. Deterministic parallelism via liquid effects. In ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI â€™12, Jan Vitek, Haibo Lin, and Frank Tip (Eds.). ACM. doi:10.1145/2254064.2254071 Gabriele Keller, Manuel M. T. Chakravarty, Roman Leshchinskiy, Simon L. Peyton Jones, and Ben Lippmeier. 2010. Regular, shape-polymorphic, parallel arrays in Haskell. In Proceedings of the 15th ACM SIGPLAN International Conference on Functional Programming, ICFP, Paul Hudak and Stephanie Weirich (Eds.). ACM. doi:10.1145/1863543.1863582 Bernhard Kragl and Shaz Qadeer. 2021. The Civl Verifier. In Formal Methods in Computer Aided Design, FMCAD 2021, New Haven, CT, USA, October 19-22, 2021. IEEE. doi:10.34727/2021/ISBN.978-3-85448-046-4_23 Robbert Krebbers, Luko van der Maas, and Enrico Tassi. 2025. Inductive Predicates via Least Fixpoints in Higher-Order Separation Logic. In 16th International Conference on Interactive Theorem Proving (ITP 2025) (Leibniz International Proceedings in Informatics (LIPIcs), Vol. 352), Yannick Forster and Chantal Keller (Eds.). Schloss Dagstuhl â€“ Leibniz- Zentrum fÃ¼r Informatik, Dagstuhl, Germany. doi:10.4230/LIPIcs.ITP.2025.27 Morten Krogh-Jespersen, Kasper Svendsen, and Lars Birkedal. 2017. A relational model of types-and-effects in higher-order concurrent separation logic. In Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages, POPL, Giuseppe Castagna and Andrew D. Gordon (Eds.). ACM. doi:10.1145/3009837.3009877 Lindsey Kuper and Ryan R. Newton. 2013. LVars: lattice-based data structures for deterministic parallelism. In Proceedings of the 2nd ACM SIGPLAN workshop on Functional high-performance computing, Clemens Grelck, Fritz Henglein, Umut A. Acar, and Jost Berthold (Eds.). ACM. doi:10.1145/2502323.2502326 Lindsey Kuper, Aaron Todd, Sam Tobin-Hochstadt, and Ryan R. Newton. 2014a. Taming the parallel effect zoo: extensible deterministic parallelism with LVish. In ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI â€™14, Michael F. P. Oâ€™Boyle and Keshav Pingali (Eds.). ACM. doi:10.1145/2594291.2594312 Lindsey Kuper, Aaron Turon, Neelakantan R. Krishnaswami, and Ryan R. Newton. 2014b. Freeze after writing: quasi- deterministic parallel programming with LVars. In The 41st Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL, Suresh Jagannathan and Peter Sewell (Eds.). ACM. doi:10.1145/2535838.2535842 John Launchbury and Simon Peyton Jones. 1995. State in Haskell. LISP and Symbolic Computation 8, 4 (1995), 293â€“341. http://dx.doi.org/10.1007/BF01018827 Hongjin Liang and Xinyu Feng. 2016. A program logic for concurrent objects under fair scheduling. SIGPLAN Not. 51, 1 (Jan. 2016). doi:10.1145/2914770.2837635 Richard J. Lipton. 1975. Reduction: A Method of Proving Properties of Parallel Programs. Commun. ACM 18, 12 (1975). doi:10.1145/361227.361234 Simon Marlow, Ryan Newton, and Simon L. Peyton Jones. 2011. A monad for deterministic parallelism. In Proceedings of the 4th ACM SIGPLAN Symposium on Haskell, Koen Claessen (Ed.). ACM. doi:10.1145/2034675.2034685 Alexandre Moine, Sam Westrick, and Joseph Tassarotti. 2025. All for One and One for All: Program Logics for Exploiting Internal Determinism in Parallel Programs (Artifact). doi:10.5281/zenodo.17653510 David A. Naumann. 2020. Thirty-Seven Years of Relational Hoare Logic: Remarks on Its Principles and History. In 9th International Symposium on Leveraging Applications of Formal Methods (Lecture Notes in Computer Science, Vol. 12477), Tiziana Margaria and Bernhard Steffen (Eds.). Springer. doi:10.1007/978-3-030-61470-6_7 Jonathan Ragan-Kelley, Connelly Barnes, Andrew Adams, Sylvain Paris, FrÃ©do Durand, and Saman P. Amarasinghe. 2013. Halide: a language and compiler for optimizing parallelism, locality, and recomputation in image processing pipelines. In ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI â€™13, Hans-Juergen Boehm and Cormac Flanagan (Eds.). ACM. doi:10.1145/2491956.2462176 Sven-Bodo Scholz. 2003. Single Assignment C: efficient support for high-level array operations in a functional setting. J. Funct. Program. 13, 6 (2003). doi:10.1017/S0956796802004458 Julian Shun and Guy E. Blelloch. 2014. Phase-concurrent hash tables for determinism. In 26th ACM Symposium on Parallelism in Algorithms and Architectures, SPAA, Guy E. Blelloch and Peter Sanders (Eds.). ACM. doi:10.1145/2612669.2612687 Proc. ACM Program. Lang., Vol. 10, No. POPL, Article 26. Publication date: January 2026. 26:32 Alexandre Moine, Sam Westrick, and Joseph Tassarotti Marcelo Sousa and Isil Dillig. 2016. Cartesian hoare logic for verifying k-safety properties. In Proceedings of the 37th ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI, Chandra Krintz and Emery D. Berger (Eds.). ACM. doi:10.1145/2908080.2908092 Amin Timany, Simon Oddershede Gregersen, LÃ©o Stefanesco, Jonas Kastberg Hinrichsen, LÃ©on Gondelman, Abel Nieto, and Lars Birkedal. 2024a. Trillium: Higher-Order Concurrent and Distributed Separation Logic for Intensional Refinement. Proc. ACM Program. Lang. 8, POPL (Jan. 2024). doi:10.1145/3632851 Amin Timany, Robbert Krebbers, Derek Dreyer, and Lars Birkedal. 2024b. A Logical Approach to Type Soundness. J. ACM 71, 6 (Nov. 2024). doi:10.1145/3676954 Amin Timany, LÃ©o Stefanesco, Morten Krogh-Jespersen, and Lars Birkedal. 2017. A logical relation for monadic encapsulation of state: proving contextual equivalences in the presence of runST. Proc. ACM Program. Lang. 2, POPL (Dec. 2017). doi:10.1145/3158152 Klaus von Gleissenthall, Rami GÃ¶khan Kici, Alexander Bakst, Deian Stefan, and Ranjit Jhala. 2019. Pretend synchrony: synchronous verification of asynchronous distributed programs. Proc. ACM Program. Lang. 3, POPL (2019). doi:10.1145/ 3290372 Received 2025-07-10; accepted 2025-11-06 Proc. ACM Program. Lang., Vol. 10, No. POPL, Article 26. Publication date: January 2026.